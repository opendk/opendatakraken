2014-11-28 13:53:12.777 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_dict
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   g_vc_src_obj_owner        t_object_name;
   g_vc_src_obj_dblink       t_object_name;
   /**
   * Generic metadata retrieval statements
   */
   -- PL/SQL block to store metadata in a tmp table.
   c_sql_import_metadata     t_string := 'BEGIN
		DELETE #targetObject#;
			
		INSERT INTO #targetObject# #targetColumns#
					#sourceSelect#;
		COMMIT;
	END;';
   c_sql_tab_part            t_string := 'SELECT COUNT (*)
  FROM all_tab_partitions#dblink#
 WHERE table_owner = :ow
   AND table_name = :tb';
   -- Code token to retrieve all columns of an object and their position inside the pk.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_obj_col_all         t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:p))
     AND table_name = TRIM(UPPER(:p))';
   -- Code token to retrieve pk columns of an object and their position inside the pk.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_obj_col_pk          t_string := 'SELECT tb.object_owner
					 , tb.object_name
					 , cc.column_name
					 , cc.position
				 FROM (SELECT object_owner
								, object_name
								, table_owner
								, table_name
							FROM (SELECT o.owner AS object_owner
										  , o.object_name
										  , CASE
												 WHEN o.object_type = ''VIEW''
													 THEN d.referenced_owner
												 ELSE o.owner
											 END AS table_owner
										  , CASE
												 WHEN o.object_type = ''VIEW''
													 THEN d.referenced_name
												 ELSE o.object_name
											 END AS table_name
										  , COUNT (*) over (PARTITION BY o.owner, o.object_name) AS referenced_cnt
									  FROM all_objects#dblink# o
										  , all_dependencies#dblink# d
									 WHERE o.owner = d.owner(+)
										AND o.object_name = d.name(+)
										AND d.referenced_type(+) = ''TABLE''
										AND o.object_type in (''TABLE'',''VIEW'',''MATERIALIZED VIEW''))
						  WHERE referenced_cnt = 1) tb
					 , all_constraints#dblink# co
					 , all_cons_columns#dblink# cc
				WHERE co.owner = tb.table_owner
				  AND co.table_name = tb.table_name
				  AND co.owner = cc.owner
				  AND co.table_name = cc.table_name
				  AND co.constraint_name = cc.constraint_name
				  AND co.constraint_type = ''P''';
   -- Code token to retrieve pk columns of an object and their position inside the pk.
   -- If the object is a view, it doesn't try to detect PK from dependencies.
   -- Works for both remote and local tables.
   c_sql_obj_col_pk_nodep    t_string := 'SELECT co.owner AS object_owner
                       , co.table_name AS object_name
                       , cc.column_name
                       , cc.position
                    FROM all_constraints#dblink# co
                       , all_cons_columns#dblink# cc
                   WHERE co.owner = cc.owner
                     AND co.table_name = cc.table_name
                     AND co.constraint_name = cc.constraint_name
                     AND co.constraint_type = ''P''';
   -- Get column properties for an object.
   -- Works for both remote and local tables.
   c_sql_col_def             t_string := 'SELECT tc.column_id
	   , tc.column_name
	   , cm.comments
       , tc.data_type
       , tc.data_length
       , tc.data_precision
       , tc.data_scale
       , tc.data_type ||
         CASE
            WHEN tc.data_type IN (''NUMBER'')
             AND tc.data_precision IS NOT NULL
             AND tc.data_scale IS NOT NULL
               THEN '' ('' || tc.data_precision || '','' || tc.data_scale || '')''
            WHEN tc.data_type LIKE (''%CHAR%'')
               THEN '' ('' || tc.char_length || '')''
         END AS column_def
		 , cs.position AS pk_position
    FROM all_tab_columns#dblink# tc
       , all_col_comments#dblink# cm 
	   , (#sql_obj_pk#) cs
   WHERE tc.owner = cm.owner(+)
     AND tc.table_name = cm.table_name(+)
     AND tc.column_name = cm.column_name(+)
	 AND tc.owner = cs.object_owner(+)
     AND tc.table_name = cs.object_name(+)
     AND tc.column_name = cs.column_name(+)
	 AND tc.owner = TRIM(UPPER(:ow))
     AND tc.table_name = TRIM(UPPER(:tb))
ORDER BY tc.column_id';
   -- Get all columns for a given obejct.
   -- Works for both remote and local tables.
   c_sql_col_all             t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))
ORDER BY column_id';
   -- Get all pk columns for a given obejct.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_col_pk              t_string := 'SELECT column_name
    FROM (#sql_obj_pk#)
	WHERE object_owner = TRIM(UPPER(:ow))
     AND object_name = TRIM(UPPER(:tb))
ORDER BY position';
   -- Get all non pk columns for a given obejct.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_col_npk             t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))
  MINUS
  SELECT column_name
    FROM (#sql_obj_pk#)
	WHERE object_owner = TRIM(UPPER(:ow))
     AND object_name = TRIM(UPPER(:tb))';
   -- Get all columns 2 given obejcts have in common.
   c_sql_col_common_all      t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:p))
     AND table_name = TRIM(UPPER(:p))
  INTERSECT
  SELECT column_name
    FROM all_tab_columns
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))';
   -- Get all non-pk columns 2 given obejcts have in common.
   c_sql_col_common_npk      t_string := '(SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow1))
     AND table_name = TRIM(UPPER(:tb1))
  MINUS
  SELECT column_name
    FROM (#sql_obj_pk#)
   WHERE object_owner = TRIM(UPPER(:ow1))
     AND object_name = TRIM(UPPER(:tb1)))
  INTERSECT
 (SELECT column_name
    FROM all_tab_columns
   WHERE owner = TRIM(UPPER(:ow2))
     AND table_name = TRIM(UPPER(:tb2))
  MINUS
  SELECT cc.column_name
    FROM all_constraints co
	   , all_cons_columns cc
   WHERE co.owner = cc.owner
     AND co.table_name = cc.table_name
     AND co.constraint_name = cc.constraint_name
     AND co.constraint_type = ''P''
     AND co.owner = TRIM(UPPER(:ow2))
     AND co.table_name = TRIM(UPPER(:tb2))
  MINUS
  SELECT column_name
	FROM all_part_key_columns
   WHERE owner = TRIM(UPPER(:ow2))
     AND name = TRIM(UPPER(:tb2)))';
   -- Get table comments
   c_sql_tab_comm            t_string := 'SELECT comments
  FROM all_tab_comments#dblink#
 WHERE owner = TRIM(UPPER(:ow))
   AND table_name = TRIM(UPPER(:tb))';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );

   /**
   * Substitute standard source parameters #owner# and #dblink# with the content
   * of the global variables g_vc_src_obj_owner and g_vc_src_obj_dblink
   *
   * @param p_vc_code_string     Parameterized string
   */
   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB);

   /**
   * Import metadata for table and table columns
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   * @param p_vc_target_object     target object for storing metadata
   * @param p_vc_target_columns    target columns for storing metadata
   */
   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   );

   /**
   * Build a list of columns belonging to a given object
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   *
   * @return table comment
   */
   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2;

   /**
   * Build a list of columns belonging to a given object
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   * @param p_vc_column_type       Type of the column to list (PK, non-PK, ALL)
   * @param p_vc_list_type         Type of list (comma separated, assignment, use of alias)
   * @param p_vc_alias1            First alias
   * @param p_vc_alias2            Second alias
   * @param p_vc_exclude_list      List of colums to exclude
   *
   * @return List of columns
   */
   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   /**
   * Build a list of columns belonging to a combination of 2 given objects
   * For example, columns in common between the 2 objects
   *
   * @param p_vc_dblink1           object 1 db link
   * @param p_vc_owner1            object 1 owner
   * @param p_vc_object1_name      object 1 name
   * @param p_vc_owner2            object 2 owner
   * @param p_vc_object2_name      object 2 name
   * @param p_vc_column_type       Type of the column to list (Common PK, Common non-PK, ALL)
   * @param p_vc_list_type         Type of list (comma separated, assignment, use of alias)
   * @param p_vc_alias1            First alias
   * @param p_vc_alias2            Second alias
   * @param p_vc_exclude_list      List of colums to exclude
   *
   * @return List of columns
   */
   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   /**
   * check if a table is partitioned
   *
   * @param p_vc_dblink       Db link for object
   * @param p_vc_owner        Owner of object
   * @param p_vc_object_name  Name of object
   */
   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN;

   /**
   * check if 2 objects have the same columns
   *
   * @param p_vc_dblink1       Db link for object 1
   * @param p_vc_owner1        Owner of object 1
   * @param p_vc_object1_name  Name of object 1
   * @param p_vc_owner2        Owner of object 2
   * @param p_vc_object2_name  Name of object 2
   */
   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN;

   /**
   * check if 2 objects have the same pk-columns
   *
   * @param p_vc_dblink1       Db link for object 1
   * @param p_vc_owner1        Owner of object 1
   * @param p_vc_object1_name  Name of object 1
   * @param p_vc_owner2        Owner of object 2
   * @param p_vc_object2_name  Name of object 2
   */
   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN;
END dwhutl_dict;
2014-11-28 13:53:12.829 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-def.sql executed
2014-11-28 13:53:12.830 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-impl.sql delimiter 
2014-11-28 13:53:12.832 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#dict
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   FUNCTION fct_column_in_list (
      p_vc_column_name    VARCHAR2
    , p_vc_column_list    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_l_column_list   DBMS_SQL.varchar2s;
      l_b_is_in_list    BOOLEAN := FALSE;
   BEGIN
      l_l_column_list :=
         p#frm#type.fct_string_to_list (
            p_vc_column_list
          , ','
         );

      FOR i IN l_l_column_list.FIRST .. l_l_column_list.LAST LOOP
         IF p_vc_column_name = l_l_column_list (i) THEN
            l_b_is_in_list := TRUE;
         END IF;
      END LOOP;

      RETURN l_b_is_in_list;
   END;

   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_SET_TEXT_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB)
   IS
      l_vc_prc_name   t_string := 'PRC_SET_SRC_PARAM';
   BEGIN
      prc_set_text_param (
         p_vc_code_string
       , 'owner'
       , CASE
            WHEN g_vc_src_obj_owner IS NOT NULL THEN
                  g_vc_src_obj_owner
               || '.'
         END
      );
      prc_set_text_param (
         p_vc_code_string
       , 'dblink'
       , CASE
            WHEN g_vc_src_obj_dblink IS NOT NULL THEN
                  '@'
               || g_vc_src_obj_dblink
         END
      );
   END prc_set_src_param;

   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   )
   IS
      l_sql_col_def           t_string := c_sql_col_def;
      l_sql_import_metadata   t_string := c_sql_import_metadata;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_text_param (
         l_sql_col_def
       , 'sql_obj_pk'
       , CASE
            WHEN p_b_check_dependencies THEN
               c_sql_obj_col_pk
            ELSE
               c_sql_obj_col_pk_nodep
         END
      );
      prc_set_src_param (l_sql_col_def);
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetObject'
       , p_vc_target_object
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetColumns'
       , CASE
            WHEN p_vc_target_columns IS NOT NULL THEN
                  '('
               || p_vc_target_columns
               || ')'
         END
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'sourceSelect'
       , l_sql_col_def
      );

      EXECUTE IMMEDIATE l_sql_import_metadata
         USING p_vc_owner
             , p_vc_object_name;

      COMMIT;
   END prc_import_metadata;

   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2
   IS
      l_sql_tab_comm   t_string := c_sql_tab_comm;
      l_vc_tab_comm    t_string;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_comm);

      EXECUTE IMMEDIATE l_sql_tab_comm
         INTO l_vc_tab_comm
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;
      RETURN l_vc_tab_comm;
   END fct_get_table_comment;

   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref       t_cur_ref;
      l_sql_col_all   t_string := c_sql_col_all;
      l_sql_col_npk   t_string := c_sql_col_npk;
      l_sql_col_pk    t_string := c_sql_col_pk;
      l_vc_buffer     t_string;
      l_vc_list       t_string;
      l_vc_owner      t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      l_vc_owner := NVL (p_vc_owner, USER);

      IF p_vc_column_type = 'ALL' THEN
         prc_set_src_param (l_sql_col_all);

         OPEN l_cur_ref FOR l_sql_col_all
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'PK' THEN
         prc_set_text_param (
            l_sql_col_pk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_pk);

         OPEN l_cur_ref FOR l_sql_col_pk
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'NPK' THEN
         prc_set_text_param (
            l_sql_col_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_npk);

         OPEN l_cur_ref FOR l_sql_col_npk
            USING l_vc_owner
                , p_vc_object_name
                , l_vc_owner
                , p_vc_object_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_NOTNULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_NULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type IN ('AND_NOTNULL', 'AND_NULL', 'AND_ALIAS') THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_list;

   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref              t_cur_ref;
      l_sql_col_common_all   t_string := c_sql_col_common_all;
      l_sql_col_common_npk   t_string := c_sql_col_common_npk;
      l_vc_buffer            t_string;
      l_vc_list              t_string;
      --
      l_vc_owner1            t_object_name;
      l_vc_owner2            t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink1;
      l_vc_owner1 := NVL (p_vc_owner1, USER);
      l_vc_owner2 := NVL (p_vc_owner2, USER);

      IF p_vc_column_type = 'COMMON_ALL' THEN
         prc_set_src_param (l_sql_col_common_all);

         OPEN l_cur_ref FOR l_sql_col_common_all
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name;
      ELSIF p_vc_column_type = 'COMMON_NPK' THEN
         prc_set_text_param (
            l_sql_col_common_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_common_npk);

         OPEN l_cur_ref FOR l_sql_col_common_npk
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type = 'AND_ALIAS' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_subset;

   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_n_cnt_part     NUMBER;
      l_sql_tab_part   t_string := c_sql_tab_part;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_part);

      EXECUTE IMMEDIATE l_sql_tab_part
         INTO l_n_cnt_part
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;

      IF l_n_cnt_part = 0 THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END fct_check_part;

   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_all_1   t_string;
      l_vc_col_all_2   t_string;
   BEGIN
      NULL;
   END fct_check_col;

   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_pk_1   t_string;
      l_vc_col_pk_2   t_string;
   BEGIN
      l_vc_col_pk_1 :=
         fct_get_column_list (
            p_vc_dblink1
          , p_vc_owner1
          , p_vc_object1_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      l_vc_col_pk_2 :=
         fct_get_column_list (
            NULL
          , p_vc_owner2
          , p_vc_object2_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      ROLLBACK;

      IF l_vc_col_pk_1 = l_vc_col_pk_2
      OR (l_vc_col_pk_1 IS NULL
      AND l_vc_col_pk_2 IS NULL) THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_check_pk;
BEGIN
   -- Versioning constants
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#dict;
2014-11-28 13:53:12.834 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_dict
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   FUNCTION fct_column_in_list (
      p_vc_column_name    VARCHAR2
    , p_vc_column_list    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_l_column_list   DBMS_SQL.varchar2s;
      l_b_is_in_list    BOOLEAN := FALSE;
   BEGIN
      l_l_column_list :=
         dwhutl_type.fct_string_to_list (
            p_vc_column_list
          , ','
         );

      FOR i IN l_l_column_list.FIRST .. l_l_column_list.LAST LOOP
         IF p_vc_column_name = l_l_column_list (i) THEN
            l_b_is_in_list := TRUE;
         END IF;
      END LOOP;

      RETURN l_b_is_in_list;
   END;

   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_SET_TEXT_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB)
   IS
      l_vc_prc_name   t_string := 'PRC_SET_SRC_PARAM';
   BEGIN
      prc_set_text_param (
         p_vc_code_string
       , 'owner'
       , CASE
            WHEN g_vc_src_obj_owner IS NOT NULL THEN
                  g_vc_src_obj_owner
               || '.'
         END
      );
      prc_set_text_param (
         p_vc_code_string
       , 'dblink'
       , CASE
            WHEN g_vc_src_obj_dblink IS NOT NULL THEN
                  '@'
               || g_vc_src_obj_dblink
         END
      );
   END prc_set_src_param;

   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   )
   IS
      l_sql_col_def           t_string := c_sql_col_def;
      l_sql_import_metadata   t_string := c_sql_import_metadata;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_text_param (
         l_sql_col_def
       , 'sql_obj_pk'
       , CASE
            WHEN p_b_check_dependencies THEN
               c_sql_obj_col_pk
            ELSE
               c_sql_obj_col_pk_nodep
         END
      );
      prc_set_src_param (l_sql_col_def);
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetObject'
       , p_vc_target_object
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetColumns'
       , CASE
            WHEN p_vc_target_columns IS NOT NULL THEN
                  '('
               || p_vc_target_columns
               || ')'
         END
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'sourceSelect'
       , l_sql_col_def
      );

      EXECUTE IMMEDIATE l_sql_import_metadata
         USING p_vc_owner
             , p_vc_object_name;

      COMMIT;
   END prc_import_metadata;

   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2
   IS
      l_sql_tab_comm   t_string := c_sql_tab_comm;
      l_vc_tab_comm    t_string;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_comm);

      EXECUTE IMMEDIATE l_sql_tab_comm
         INTO l_vc_tab_comm
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;
      RETURN l_vc_tab_comm;
   END fct_get_table_comment;

   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref       t_cur_ref;
      l_sql_col_all   t_string := c_sql_col_all;
      l_sql_col_npk   t_string := c_sql_col_npk;
      l_sql_col_pk    t_string := c_sql_col_pk;
      l_vc_buffer     t_string;
      l_vc_list       t_string;
      l_vc_owner      t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      l_vc_owner := NVL (p_vc_owner, USER);

      IF p_vc_column_type = 'ALL' THEN
         prc_set_src_param (l_sql_col_all);

         OPEN l_cur_ref FOR l_sql_col_all
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'PK' THEN
         prc_set_text_param (
            l_sql_col_pk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_pk);

         OPEN l_cur_ref FOR l_sql_col_pk
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'NPK' THEN
         prc_set_text_param (
            l_sql_col_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_npk);

         OPEN l_cur_ref FOR l_sql_col_npk
            USING l_vc_owner
                , p_vc_object_name
                , l_vc_owner
                , p_vc_object_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_NOTNULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_NULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type IN ('AND_NOTNULL', 'AND_NULL', 'AND_ALIAS') THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_list;

   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref              t_cur_ref;
      l_sql_col_common_all   t_string := c_sql_col_common_all;
      l_sql_col_common_npk   t_string := c_sql_col_common_npk;
      l_vc_buffer            t_string;
      l_vc_list              t_string;
      --
      l_vc_owner1            t_object_name;
      l_vc_owner2            t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink1;
      l_vc_owner1 := NVL (p_vc_owner1, USER);
      l_vc_owner2 := NVL (p_vc_owner2, USER);

      IF p_vc_column_type = 'COMMON_ALL' THEN
         prc_set_src_param (l_sql_col_common_all);

         OPEN l_cur_ref FOR l_sql_col_common_all
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name;
      ELSIF p_vc_column_type = 'COMMON_NPK' THEN
         prc_set_text_param (
            l_sql_col_common_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_common_npk);

         OPEN l_cur_ref FOR l_sql_col_common_npk
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type = 'AND_ALIAS' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_subset;

   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_n_cnt_part     NUMBER;
      l_sql_tab_part   t_string := c_sql_tab_part;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_part);

      EXECUTE IMMEDIATE l_sql_tab_part
         INTO l_n_cnt_part
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;

      IF l_n_cnt_part = 0 THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END fct_check_part;

   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_all_1   t_string;
      l_vc_col_all_2   t_string;
   BEGIN
      NULL;
   END fct_check_col;

   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_pk_1   t_string;
      l_vc_col_pk_2   t_string;
   BEGIN
      l_vc_col_pk_1 :=
         fct_get_column_list (
            p_vc_dblink1
          , p_vc_owner1
          , p_vc_object1_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      l_vc_col_pk_2 :=
         fct_get_column_list (
            NULL
          , p_vc_owner2
          , p_vc_object2_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      ROLLBACK;

      IF l_vc_col_pk_1 = l_vc_col_pk_2
      OR (l_vc_col_pk_1 IS NULL
      AND l_vc_col_pk_2 IS NULL) THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_check_pk;
BEGIN
   -- Versioning constants
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_dict;
2014-11-28 13:53:12.876 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-impl.sql executed
2014-11-28 13:53:12.876 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stmt/stmt-def.sql delimiter 
2014-11-28 13:53:12.878 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stmt
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version        CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url            CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version                 VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                     VARCHAR2 (1024);
   --
   --
   -- Enable/disable parallel execution
   c_token_enable_parallel_dml    CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION ENABLE PARALLEL DML'';';
   c_token_disable_parallel_dml   CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION DISABLE PARALLEL DML'';';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_table         CLOB := 'EXECUTE IMMEDIATE ''TRUNCATE TABLE #tableName# DROP STORAGE'';
          p#frm#trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# truncated'');';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_partition     CLOB := 'EXECUTE IMMEDIATE ''ALTER TABLE #tableName# TRUNCATE #partition#'';
          p#frm#trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# #partition# truncated'');';
   --
   -- Copy the content of a source table into a target table
   c_sql_insert_copy              CLOB := '
        INSERT /*+APPEND*/ INTO #targetIdentifier# #partition# (
               #utlColumnList#
               #targetColumnList#)
        SELECT #utlValueList#
               #sourceColumnList#
          FROM #sourceIdentifier#
               #filterClause#;';
   --
   -- Copy the content of a source table into a target table
   -- deduplicating source values among a defined natural key
   c_sql_insert_dedupl            CLOB := '
        INSERT /*+APPEND*/
          WHEN row_rank = 1
           AND #notNullClause#
          THEN INTO #targetIdentifier# #partition# (
                #utlColumnList#
                #targetColumnList#)
             VALUES (
                #utlValueList#
                #sourceColumnList#)
          ELSE INTO #duplIdentifier# #partition# (
                #utlColumnListForDupl#
                #targetColumnList#)
             VALUES (
                #utlValueListForDupl#
                #sourceColumnList#)
         SELECT #sourceColumnList#
              , ROW_NUMBER () over (PARTITION BY #pkColumnList# #deduplRankClause#) AS row_rank
           FROM #sourceIdentifier#
                #filterClause#;';
   --
   -- Store the difference between 2 tables
   c_sql_insert_diff_with_nk      CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT
                 #nvl2ColumnList#
                , CASE
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NULL
                        THEN ''I'' -- new row in src
                        WHEN src.rowid       IS NULL
                        AND trg.rowid        IS NOT NULL
                        AND trg.#dmlOpColumnName# <> ''D''
                        THEN ''D'' -- row was deleted in src
                        WHEN src.rowid      IS NOT NULL
                        AND trg.rowid       IS NOT NULL
                        AND trg.#dmlOpColumnName# = ''D''
                        THEN ''R'' -- row was deleted and now reappeared
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#historyClause#)
                        THEN ''H''
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#updateClause#)
                        THEN ''U''
                        ELSE NULL -- nothing to be done
                    END AS #dmlOpColumnName#
                  , trg.#validFromColumnName#
                  , trg.#validToColumnName#
                FROM #sourceIdentifier# #sourcePartition# src
                #joinType# OUTER JOIN 
                (SELECT *
                   FROM #targetIdentifier# #targetPartition#
                  WHERE #validToColumnName# > SYSDATE) trg
                ON    #joinClause#)
        WHERE #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Diff token of the staging 2 procedure - nk non-present
   c_sql_insert_diff_without_nk   CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT #targetColumnList#
             , CASE
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst = 0
                     THEN ''I''                                                                                                                                                          -- new row in src
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# = ''D''
                     THEN ''R''
                  WHEN cnt_in_src = 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# <> ''D''
                     THEN ''D''
                  ELSE NULL
               END AS #dmlOpColumnName#
             , #validFromColumnName#
             , #validToColumnName#
          FROM (SELECT   #targetColumnList#
                       , MAX (#dmlOpColumnName#) AS #dmlOpColumnName#
                       , MAX (#validFromColumnName#) AS #validFromColumnName#
                       , MAX (#validToColumnName#) AS #validToColumnName#
                       , COUNT (rowid_src) AS cnt_in_src
                       , COUNT (rowid_dst) AS cnt_in_dst
                    FROM (SELECT #targetColumnList#
                               , NULL AS #validFromColumnName#
                               , NULL AS #validToColumnName#
                               , NULL AS #dmlOpColumnName#
                               , ROWID AS rowid_src
                               , NULL AS rowid_dst
                            FROM #sourceIdentifier# #sourcePartition#
                          UNION ALL
                          SELECT #targetColumnList#
                               , #validFromColumnName#
                               , #validToColumnName#
                               , #dmlOpColumnName# AS #dmlOpColumnName#
                               , NULL AS rowid_src
                               , ROWID AS rowid_dst
                            FROM #targetIdentifier# #targetPartition#
                           WHERE #validToColumnName# > SYSDATE)
                GROUP BY #targetColumnList#))
        WHERE
            #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_close          CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# IN (''D'',''H'')) src
                  ON (#joinClause#)
        WHEN MATCHED THEN
             UPDATE
                 SET trg.#dmlOpColumnName# = src.#dmlOpColumnName# 
                   , trg.#validToColumnName# = SYSDATE
               WHERE trg.#validToColumnName# > SYSDATE;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_update         CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# = ''U'') src
                  ON (#joinClause#
                  AND trg.#validToColumnName# > SYSDATE)
        WHEN MATCHED THEN
             UPDATE
                 SET #matchedClause#
                     trg.#dmlOpColumnName# = src.#dmlOpColumnName#;';
   --
   --
   -- Merge token of the hist2 procedure - 2 separate statement
   c_sql_reconcile_insert         CLOB := '
      INSERT /*+APPEND*/
        INTO #targetIdentifier# #targetPartition# (
             #utlColumnList#
           , #targetColumnList#)
      SELECT #utlValueList#
           , #diffColumnList#
        FROM #diffIdentifier# #diffPartition#
       WHERE #dmlOpColumnName# IN (''H'', ''I'', ''R'');';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );
/*PROCEDURE prc_get_identifier (
   p_vc_dblink         VARCHAR2
 , p_vc_schema_name    VARCHAR2
 , p_vc_object_name    VARCHAR2
);*/
END p#frm#stmt;
2014-11-28 13:53:12.879 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stmt
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version        CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url            CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version                 VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                     VARCHAR2 (1024);
   --
   --
   -- Enable/disable parallel execution
   c_token_enable_parallel_dml    CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION ENABLE PARALLEL DML'';';
   c_token_disable_parallel_dml   CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION DISABLE PARALLEL DML'';';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_table         CLOB := 'EXECUTE IMMEDIATE ''TRUNCATE TABLE #tableName# DROP STORAGE'';
          dwhutl_trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# truncated'');';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_partition     CLOB := 'EXECUTE IMMEDIATE ''ALTER TABLE #tableName# TRUNCATE #partition#'';
          dwhutl_trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# #partition# truncated'');';
   --
   -- Copy the content of a source table into a target table
   c_sql_insert_copy              CLOB := '
        INSERT /*+APPEND*/ INTO #targetIdentifier# #partition# (
               #utlColumnList#
               #targetColumnList#)
        SELECT #utlValueList#
               #sourceColumnList#
          FROM #sourceIdentifier#
               #filterClause#;';
   --
   -- Copy the content of a source table into a target table
   -- deduplicating source values among a defined natural key
   c_sql_insert_dedupl            CLOB := '
        INSERT /*+APPEND*/
          WHEN row_rank = 1
           AND #notNullClause#
          THEN INTO #targetIdentifier# #partition# (
                #utlColumnList#
                #targetColumnList#)
             VALUES (
                #utlValueList#
                #sourceColumnList#)
          ELSE INTO #duplIdentifier# #partition# (
                #utlColumnListForDupl#
                #targetColumnList#)
             VALUES (
                #utlValueListForDupl#
                #sourceColumnList#)
         SELECT #sourceColumnList#
              , ROW_NUMBER () over (PARTITION BY #pkColumnList# #deduplRankClause#) AS row_rank
           FROM #sourceIdentifier#
                #filterClause#;';
   --
   -- Store the difference between 2 tables
   c_sql_insert_diff_with_nk      CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT
                 #nvl2ColumnList#
                , CASE
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NULL
                        THEN ''I'' -- new row in src
                        WHEN src.rowid       IS NULL
                        AND trg.rowid        IS NOT NULL
                        AND trg.#dmlOpColumnName# <> ''D''
                        THEN ''D'' -- row was deleted in src
                        WHEN src.rowid      IS NOT NULL
                        AND trg.rowid       IS NOT NULL
                        AND trg.#dmlOpColumnName# = ''D''
                        THEN ''R'' -- row was deleted and now reappeared
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#historyClause#)
                        THEN ''H''
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#updateClause#)
                        THEN ''U''
                        ELSE NULL -- nothing to be done
                    END AS #dmlOpColumnName#
                  , trg.#validFromColumnName#
                  , trg.#validToColumnName#
                FROM #sourceIdentifier# #sourcePartition# src
                #joinType# OUTER JOIN 
                (SELECT *
                   FROM #targetIdentifier# #targetPartition#
                  WHERE #validToColumnName# > SYSDATE) trg
                ON    #joinClause#)
        WHERE #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Diff token of the staging 2 procedure - nk non-present
   c_sql_insert_diff_without_nk   CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT #targetColumnList#
             , CASE
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst = 0
                     THEN ''I''                                                                                                                                                          -- new row in src
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# = ''D''
                     THEN ''R''
                  WHEN cnt_in_src = 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# <> ''D''
                     THEN ''D''
                  ELSE NULL
               END AS #dmlOpColumnName#
             , #validFromColumnName#
             , #validToColumnName#
          FROM (SELECT   #targetColumnList#
                       , MAX (#dmlOpColumnName#) AS #dmlOpColumnName#
                       , MAX (#validFromColumnName#) AS #validFromColumnName#
                       , MAX (#validToColumnName#) AS #validToColumnName#
                       , COUNT (rowid_src) AS cnt_in_src
                       , COUNT (rowid_dst) AS cnt_in_dst
                    FROM (SELECT #targetColumnList#
                               , NULL AS #validFromColumnName#
                               , NULL AS #validToColumnName#
                               , NULL AS #dmlOpColumnName#
                               , ROWID AS rowid_src
                               , NULL AS rowid_dst
                            FROM #sourceIdentifier# #sourcePartition#
                          UNION ALL
                          SELECT #targetColumnList#
                               , #validFromColumnName#
                               , #validToColumnName#
                               , #dmlOpColumnName# AS #dmlOpColumnName#
                               , NULL AS rowid_src
                               , ROWID AS rowid_dst
                            FROM #targetIdentifier# #targetPartition#
                           WHERE #validToColumnName# > SYSDATE)
                GROUP BY #targetColumnList#))
        WHERE
            #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_close          CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# IN (''D'',''H'')) src
                  ON (#joinClause#)
        WHEN MATCHED THEN
             UPDATE
                 SET trg.#dmlOpColumnName# = src.#dmlOpColumnName# 
                   , trg.#validToColumnName# = SYSDATE
               WHERE trg.#validToColumnName# > SYSDATE;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_update         CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# = ''U'') src
                  ON (#joinClause#
                  AND trg.#validToColumnName# > SYSDATE)
        WHEN MATCHED THEN
             UPDATE
                 SET #matchedClause#
                     trg.#dmlOpColumnName# = src.#dmlOpColumnName#;';
   --
   --
   -- Merge token of the hist2 procedure - 2 separate statement
   c_sql_reconcile_insert         CLOB := '
      INSERT /*+APPEND*/
        INTO #targetIdentifier# #targetPartition# (
             #utlColumnList#
           , #targetColumnList#)
      SELECT #utlValueList#
           , #diffColumnList#
        FROM #diffIdentifier# #diffPartition#
       WHERE #dmlOpColumnName# IN (''H'', ''I'', ''R'');';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );
/*PROCEDURE prc_get_identifier (
   p_vc_dblink         VARCHAR2
 , p_vc_schema_name    VARCHAR2
 , p_vc_object_name    VARCHAR2
);*/
END dwhutl_stmt;
2014-11-28 13:53:12.903 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stmt/stmt-def.sql executed
2014-11-28 13:53:12.903 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stmt/stmt-impl.sql delimiter 
2014-11-28 13:53:12.904 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#stmt
AS
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#stmt;
2014-11-28 13:53:12.905 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_stmt
AS
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_stmt;
2014-11-28 13:53:12.930 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stmt/stmt-impl.sql executed
2014-11-28 13:53:12.930 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/ddls/ddls-def.sql delimiter 
2014-11-28 13:53:12.931 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#ddls
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version     CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url         CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version              VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                  VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * Templates for entity objects
   */
   c_name_entity_tab           t_object_name := '#entityPrefix##entityName#_T';
   c_name_entity_cdc           t_object_name := '#entityPrefix##entityName#_CDC';
   c_name_entity_bkp           t_object_name := '#entityPrefix##entityName#_BKP';
   c_name_entity_cbk           t_object_name := '#entityPrefix##entityName#_CBK';
   c_name_entity_seq           t_object_name := '#entityPrefix##entityName#_SEQ';
   c_name_entity_id            t_object_name := '#entityName#_ID';
   c_name_entity_pk            t_object_name := '#entityPrefix##entityName#_PK';
   -- Template to create a standard entity table.
   c_template_entity_tab       CLOB := 'CREATE TABLE #entityTable# (
		 #entityId# number
	 , #columnDefinitionList#
	 , session_user VARCHAR2(100) DEFAULT USER
	 , os_user VARCHAR2(100) DEFAULT SYS_CONTEXT (''USERENV'', ''OS_USER'')
	 , create_date DATE DEFAULT SYSDATE
	 , update_date DATE DEFAULT SYSDATE
	 , CONSTRAINT #entityPK# PRIMARY KEY (#entityId#)
	)';
   -- Template to create a cdc table for a standard entity table.
   c_template_entity_cdc       CLOB := 'CREATE TABLE #entityCDC# (
		#entityId# NUMBER
	 , #columnDefinitionList#
	 , session_user VARCHAR2(100) DEFAULT USER
	 , os_user VARCHAR2(100) DEFAULT SYS_CONTEXT (''USERENV'', ''OS_USER'')
	 , create_date DATE DEFAULT SYSDATE
	 , update_date DATE DEFAULT SYSDATE
   , dml_operation VARCHAR2(100) DEFAULT ''INSERT''
	 , dml_date DATE DEFAULT SYSDATE
	)';
   -- Template to create a cdc trigger for a standard entity table
   c_template_entity_trg_cdc   CLOB := 'CREATE OR REPLACE TRIGGER #entityTable#dc
   AFTER INSERT OR UPDATE OR DELETE
   ON #entityTable#
   FOR EACH ROW
DECLARE
   l_vc_operation          VARCHAR2 (10);
BEGIN

   IF INSERTING
   THEN
      l_vc_operation        := ''INSERT'';
   ELSIF UPDATING
   THEN
      l_vc_operation        := ''UPDATE'';
   ELSIF DELETING
   THEN
      l_vc_operation        := ''DELETE'';
   END IF;
   
   -- Insert record into audit table
   CASE
      WHEN l_vc_operation IN (''INSERT'', ''UPDATE'')
      THEN
         INSERT INTO #entityCDC#
                     (#columnList#
                    , dml_operation
                     )
              VALUES (#columnListNew#
                    , l_vc_operation
                     );
      WHEN l_vc_operation IN (''DELETE'')
      THEN
         INSERT INTO #entityCDC#
                     (#columnList#
                    , dml_operation
                     )
              VALUES (#columnListOld#
                    , l_vc_operation
                     );
   END CASE;
END;';
   -- Template for the name of a sequence related to a standard entity table.
   c_template_entity_seq       CLOB := 'CREATE SEQUENCE #entitySequence#';
   -- Template for the insert trigger related to a standard entity table.
   c_template_entity_trg_ins   CLOB := 'CREATE OR REPLACE TRIGGER #entityTable#bi BEFORE
	INSERT
		ON #entityTable# FOR EACH ROW
BEGIN
	IF :NEW.#entityId# IS NULL THEN
		SELECT
			#entitySequence#.nextval
		INTO
			:NEW.#entityId#
		FROM
			DUAL;
	END IF;
END;';
   -- Template for the update trigger related to a standard entity table.
   c_template_entity_trg_upd   CLOB := 'CREATE OR REPLACE TRIGGER #entityTable#bu BEFORE
	UPDATE
		ON #entityTable# FOR EACH ROW
BEGIN
	:NEW.update_date := SYSDATE;
END;';
   /**
   * Package head code template
   */
   c_template_pkg_head         CLOB := 'CREATE OR REPLACE PACKAGE #pkgName# AS
/**
 * This package has been dynamically generated by the
 * ETL framework code generator
 *
 *
 * Version of the framework packages:
#generatingVersion#
 *
 */
   #varList#
   #prcList#

END #pkgName#;';
   /**
   * Package body code template
   */
   c_template_pkg_body         CLOB := 'CREATE OR REPLACE PACKAGE BODY #pkgName# AS
   #varList#
   #prcList#
END #pkgName#;';
   /**
   * Procedure head code template
   */
   c_template_prc_head         CLOB := '
   PROCEDURE #prcName# (
      #prcParameters#);';
   /**
   * Procedure body code template
   */
   c_template_prc_body         CLOB := '
   PROCEDURE #prcName# (
      #prcParameters#) IS
      l_vc_prc_name    VARCHAR2(50) := ''#prcName#'';
      l_d_start        DATE                       := SYSDATE;
      l_n_result       NUMBER;
      l_n_stat_id      NUMBER;
      l_b_ok           BOOLEAN;
      #varList#
   BEGIN
      #prcInitialize#
   
      p#frm#trac.log_sub_info (l_vc_prc_name, ''Start'');
      
      #prcBody#
      
      p#frm#trac.log_sub_info (l_vc_prc_name, ''Finish'');
        
      #prcFinalize#
        
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_error (l_vc_prc_name, ''Error'');
         #exceptionHandling#
         RAISE;
   END #prcName#;';
   /**
   * Function head code template
   */
   c_template_fct_head         CLOB := '
   FUNCTION #prcName# (
      #prcParameters#)
   RETURN #returnType#;';
   /**
   * Function body code template
   */
   c_template_fct_body         CLOB := '
   FUNCTION #prcName# (
      #prcParameters#)
   RETURN #returnType# IS
      l_vc_prc_name     VARCHAR2(50) := ''#prcName#'';
      #varList#
   BEGIN
      #prcInitialize#
      
      p#frm#trac.log_sub_info (l_vc_prc_name, ''Start'');
      
      #prcBody#
      
      p#frm#trac.log_sub_info (l_vc_prc_name, ''Finish'');
      RETURN #returnVar#>;
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_error (l_vc_prc_name, ''Error'');
         #exceptionHandling#
         RAISE;
   END #prcName#;';
   -- Create table template
   c_template_create_table     CLOB := 'CREATE TABLE #tableName# (#listColUtl##listColumns#) #storageClause#';
   -- Template to add a primary key
   c_template_create_pk        CLOB := 'ALTER TABLE #tableName# ADD (CONSTRAINT #pkName# PRIMARY KEY (#listColPk#) USING INDEX #storageClause#)';
   -- Template to add a primary key
   c_template_create_notnull   CLOB := 'ALTER TABLE #tableName# MODIFY (#columnName# NOT NULL)';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );

   /**
   * Execute a statement contained in a CLOB string
   *
   * @param p_sql_code      String containing the statement
   */
   PROCEDURE prc_execute (p_sql_code CLOB);

   /**
   * Copy the content of a given source table to a target table.
   * Only common columns are considered
   *
   * @param p_vc_table_name_trg    Target table
   * @param p_vc_table_name_src    Source table
   */
   PROCEDURE prc_migrate_table (
      p_vc_table_name_trg    VARCHAR2
    , p_vc_table_name_src    VARCHAR2
   );

   /**
   * Backup the content of a given source table
   * to a newly created target table with the same structure
   * Only common columns are considered
   *
   * @param p_vc_table_name    Source table
   * @param p_vc_backup_name   Backup table
   * @param p_b_raise_flag     Raise exception if backup table already exists
   */
   PROCEDURE prc_backup_table (
      p_vc_table_name     VARCHAR2
    , p_vc_backup_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   );

   /**
   * Drop an object
   *
   * @param p_vc_object_type   Object type
   * @param p_vc_object_name   Object name
   * @param p_b_raise_flag     Raise exception if object don't exists
   */
   PROCEDURE prc_drop_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   );

   /**
   * Create a synonym for a given object
   *
   * @param p_vc_object_name   Object name
   * @param p_vc_synonym_name  Synonym name
   * @param p_b_public         Crete public synonym if true
   * @param p_b_drop_flag      Drop existing synonym if true
   * @param p_b_raise_flag     Raise exception if error occurs
   */
   PROCEDURE prc_create_synonym (
      p_vc_object_name     VARCHAR2
    , p_vc_synonym_name    VARCHAR2
    , p_b_public           BOOLEAN DEFAULT FALSE
    , p_b_drop_flag        BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   );

   /**
   * Create an object
   *
   * @param p_vc_object_type   Object type
   * @param p_vc_object_name   Object name
   * @param p_vc_object_ddl    Object creation ddl
   * @param p_b_drop_flag      Drop existing synonym if true
   * @param p_b_raise_flag     Raise exception if error occurs
   */
   PROCEDURE prc_create_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_object_ddl     CLOB
    , p_b_drop_flag       BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   );

   /**
   * Create entity related objects
   *
   * @param p_vc_entity_name       Entity name
   * @param p_vc_entity_fields     Entity column definitions
   * @param p_vc_create_mode       Entity creation mode ('DROP','DEFAULT')
   * @param p_b_public_flag        Create public synonym if true
   * @param p_b_migrate_flag       Migrate content in the newly created table
   * @param p_b_cdc_flag           Create cdc table and triggers
   */
   PROCEDURE prc_create_entity (
      p_vc_entity_prefix    VARCHAR2
    , p_vc_entity_name      VARCHAR2
    , p_vc_entity_fields    VARCHAR2
    , p_vc_create_mode      VARCHAR2 DEFAULT 'DEFAULT'
    , p_b_public_flag       BOOLEAN DEFAULT FALSE
    , p_b_migrate_flag      BOOLEAN DEFAULT FALSE
    , p_b_cdc_flag          BOOLEAN DEFAULT FALSE
   );
END p#frm#ddls;
2014-11-28 13:53:12.932 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_ddls
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version     CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url         CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version              VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                  VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * Templates for entity objects
   */
   c_name_entity_tab           t_object_name := '#entityPrefix##entityName#_T';
   c_name_entity_cdc           t_object_name := '#entityPrefix##entityName#_CDC';
   c_name_entity_bkp           t_object_name := '#entityPrefix##entityName#_BKP';
   c_name_entity_cbk           t_object_name := '#entityPrefix##entityName#_CBK';
   c_name_entity_seq           t_object_name := '#entityPrefix##entityName#_SEQ';
   c_name_entity_id            t_object_name := '#entityName#_ID';
   c_name_entity_pk            t_object_name := '#entityPrefix##entityName#_PK';
   -- Template to create a standard entity table.
   c_template_entity_tab       CLOB := 'CREATE TABLE #entityTable# (
		 #entityId# number
	 , #columnDefinitionList#
	 , session_user VARCHAR2(100) DEFAULT USER
	 , os_user VARCHAR2(100) DEFAULT SYS_CONTEXT (''USERENV'', ''OS_USER'')
	 , create_date DATE DEFAULT SYSDATE
	 , update_date DATE DEFAULT SYSDATE
	 , CONSTRAINT #entityPK# PRIMARY KEY (#entityId#)
	)';
   -- Template to create a cdc table for a standard entity table.
   c_template_entity_cdc       CLOB := 'CREATE TABLE #entityCDC# (
		#entityId# NUMBER
	 , #columnDefinitionList#
	 , session_user VARCHAR2(100) DEFAULT USER
	 , os_user VARCHAR2(100) DEFAULT SYS_CONTEXT (''USERENV'', ''OS_USER'')
	 , create_date DATE DEFAULT SYSDATE
	 , update_date DATE DEFAULT SYSDATE
   , dml_operation VARCHAR2(100) DEFAULT ''INSERT''
	 , dml_date DATE DEFAULT SYSDATE
	)';
   -- Template to create a cdc trigger for a standard entity table
   c_template_entity_trg_cdc   CLOB := 'CREATE OR REPLACE TRIGGER #entityTable#dc
   AFTER INSERT OR UPDATE OR DELETE
   ON #entityTable#
   FOR EACH ROW
DECLARE
   l_vc_operation          VARCHAR2 (10);
BEGIN

   IF INSERTING
   THEN
      l_vc_operation        := ''INSERT'';
   ELSIF UPDATING
   THEN
      l_vc_operation        := ''UPDATE'';
   ELSIF DELETING
   THEN
      l_vc_operation        := ''DELETE'';
   END IF;
   
   -- Insert record into audit table
   CASE
      WHEN l_vc_operation IN (''INSERT'', ''UPDATE'')
      THEN
         INSERT INTO #entityCDC#
                     (#columnList#
                    , dml_operation
                     )
              VALUES (#columnListNew#
                    , l_vc_operation
                     );
      WHEN l_vc_operation IN (''DELETE'')
      THEN
         INSERT INTO #entityCDC#
                     (#columnList#
                    , dml_operation
                     )
              VALUES (#columnListOld#
                    , l_vc_operation
                     );
   END CASE;
END;';
   -- Template for the name of a sequence related to a standard entity table.
   c_template_entity_seq       CLOB := 'CREATE SEQUENCE #entitySequence#';
   -- Template for the insert trigger related to a standard entity table.
   c_template_entity_trg_ins   CLOB := 'CREATE OR REPLACE TRIGGER #entityTable#bi BEFORE
	INSERT
		ON #entityTable# FOR EACH ROW
BEGIN
	IF :NEW.#entityId# IS NULL THEN
		SELECT
			#entitySequence#.nextval
		INTO
			:NEW.#entityId#
		FROM
			DUAL;
	END IF;
END;';
   -- Template for the update trigger related to a standard entity table.
   c_template_entity_trg_upd   CLOB := 'CREATE OR REPLACE TRIGGER #entityTable#bu BEFORE
	UPDATE
		ON #entityTable# FOR EACH ROW
BEGIN
	:NEW.update_date := SYSDATE;
END;';
   /**
   * Package head code template
   */
   c_template_pkg_head         CLOB := 'CREATE OR REPLACE PACKAGE #pkgName# AS
/**
 * This package has been dynamically generated by the
 * ETL framework code generator
 *
 *
 * Version of the framework packages:
#generatingVersion#
 *
 */
   #varList#
   #prcList#

END #pkgName#;';
   /**
   * Package body code template
   */
   c_template_pkg_body         CLOB := 'CREATE OR REPLACE PACKAGE BODY #pkgName# AS
   #varList#
   #prcList#
END #pkgName#;';
   /**
   * Procedure head code template
   */
   c_template_prc_head         CLOB := '
   PROCEDURE #prcName# (
      #prcParameters#);';
   /**
   * Procedure body code template
   */
   c_template_prc_body         CLOB := '
   PROCEDURE #prcName# (
      #prcParameters#) IS
      l_vc_prc_name    VARCHAR2(50) := ''#prcName#'';
      l_d_start        DATE                       := SYSDATE;
      l_n_result       NUMBER;
      l_n_stat_id      NUMBER;
      l_b_ok           BOOLEAN;
      #varList#
   BEGIN
      #prcInitialize#
   
      dwhutl_trac.log_sub_info (l_vc_prc_name, ''Start'');
      
      #prcBody#
      
      dwhutl_trac.log_sub_info (l_vc_prc_name, ''Finish'');
        
      #prcFinalize#
        
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_error (l_vc_prc_name, ''Error'');
         #exceptionHandling#
         RAISE;
   END #prcName#;';
   /**
   * Function head code template
   */
   c_template_fct_head         CLOB := '
   FUNCTION #prcName# (
      #prcParameters#)
   RETURN #returnType#;';
   /**
   * Function body code template
   */
   c_template_fct_body         CLOB := '
   FUNCTION #prcName# (
      #prcParameters#)
   RETURN #returnType# IS
      l_vc_prc_name     VARCHAR2(50) := ''#prcName#'';
      #varList#
   BEGIN
      #prcInitialize#
      
      dwhutl_trac.log_sub_info (l_vc_prc_name, ''Start'');
      
      #prcBody#
      
      dwhutl_trac.log_sub_info (l_vc_prc_name, ''Finish'');
      RETURN #returnVar#>;
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_error (l_vc_prc_name, ''Error'');
         #exceptionHandling#
         RAISE;
   END #prcName#;';
   -- Create table template
   c_template_create_table     CLOB := 'CREATE TABLE #tableName# (#listColUtl##listColumns#) #storageClause#';
   -- Template to add a primary key
   c_template_create_pk        CLOB := 'ALTER TABLE #tableName# ADD (CONSTRAINT #pkName# PRIMARY KEY (#listColPk#) USING INDEX #storageClause#)';
   -- Template to add a primary key
   c_template_create_notnull   CLOB := 'ALTER TABLE #tableName# MODIFY (#columnName# NOT NULL)';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );

   /**
   * Execute a statement contained in a CLOB string
   *
   * @param p_sql_code      String containing the statement
   */
   PROCEDURE prc_execute (p_sql_code CLOB);

   /**
   * Copy the content of a given source table to a target table.
   * Only common columns are considered
   *
   * @param p_vc_table_name_trg    Target table
   * @param p_vc_table_name_src    Source table
   */
   PROCEDURE prc_migrate_table (
      p_vc_table_name_trg    VARCHAR2
    , p_vc_table_name_src    VARCHAR2
   );

   /**
   * Backup the content of a given source table
   * to a newly created target table with the same structure
   * Only common columns are considered
   *
   * @param p_vc_table_name    Source table
   * @param p_vc_backup_name   Backup table
   * @param p_b_raise_flag     Raise exception if backup table already exists
   */
   PROCEDURE prc_backup_table (
      p_vc_table_name     VARCHAR2
    , p_vc_backup_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   );

   /**
   * Drop an object
   *
   * @param p_vc_object_type   Object type
   * @param p_vc_object_name   Object name
   * @param p_b_raise_flag     Raise exception if object don't exists
   */
   PROCEDURE prc_drop_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   );

   /**
   * Create a synonym for a given object
   *
   * @param p_vc_object_name   Object name
   * @param p_vc_synonym_name  Synonym name
   * @param p_b_public         Crete public synonym if true
   * @param p_b_drop_flag      Drop existing synonym if true
   * @param p_b_raise_flag     Raise exception if error occurs
   */
   PROCEDURE prc_create_synonym (
      p_vc_object_name     VARCHAR2
    , p_vc_synonym_name    VARCHAR2
    , p_b_public           BOOLEAN DEFAULT FALSE
    , p_b_drop_flag        BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   );

   /**
   * Create an object
   *
   * @param p_vc_object_type   Object type
   * @param p_vc_object_name   Object name
   * @param p_vc_object_ddl    Object creation ddl
   * @param p_b_drop_flag      Drop existing synonym if true
   * @param p_b_raise_flag     Raise exception if error occurs
   */
   PROCEDURE prc_create_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_object_ddl     CLOB
    , p_b_drop_flag       BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   );

   /**
   * Create entity related objects
   *
   * @param p_vc_entity_name       Entity name
   * @param p_vc_entity_fields     Entity column definitions
   * @param p_vc_create_mode       Entity creation mode ('DROP','DEFAULT')
   * @param p_b_public_flag        Create public synonym if true
   * @param p_b_migrate_flag       Migrate content in the newly created table
   * @param p_b_cdc_flag           Create cdc table and triggers
   */
   PROCEDURE prc_create_entity (
      p_vc_entity_prefix    VARCHAR2
    , p_vc_entity_name      VARCHAR2
    , p_vc_entity_fields    VARCHAR2
    , p_vc_create_mode      VARCHAR2 DEFAULT 'DEFAULT'
    , p_b_public_flag       BOOLEAN DEFAULT FALSE
    , p_b_migrate_flag      BOOLEAN DEFAULT FALSE
    , p_b_cdc_flag          BOOLEAN DEFAULT FALSE
   );
END dwhutl_ddls;
2014-11-28 13:53:12.951 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/ddls/ddls-def.sql executed
2014-11-28 13:53:12.952 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/ddls/ddls-impl.sql delimiter 
2014-11-28 13:53:12.953 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#ddls
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_SET_TEXT_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   FUNCTION fct_get_table_migrate_stmt (
      p_vc_table_name_trg    VARCHAR2
    , p_vc_table_name_src    VARCHAR2
   )
      RETURN CLOB
   IS
      l_vc_column_list   VARCHAR2 (32000);
   BEGIN
      l_vc_column_list :=
         p#frm#dict.fct_get_column_subset (
            NULL
          , NULL
          , UPPER (p_vc_table_name_trg)
          , NULL
          , UPPER (p_vc_table_name_src)
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
         );
      RETURN    'INSERT INTO '
             || p_vc_table_name_trg
             || '('
             || l_vc_column_list
             || ') SELECT '
             || l_vc_column_list
             || ' FROM '
             || p_vc_table_name_src;
   END fct_get_table_migrate_stmt;

   PROCEDURE prc_execute (p_sql_code CLOB)
   IS
      l_vcs_code      DBMS_SQL.varchar2s;
      l_i_cursor_id   INTEGER;
   BEGIN
      l_vcs_code :=
         p#frm#type.fct_clob_to_list (
            p_sql_code
          , CHR (10)
         );
      l_i_cursor_id := DBMS_SQL.open_cursor;
      DBMS_SQL.parse (
         l_i_cursor_id
       , l_vcs_code
       , l_vcs_code.FIRST
       , l_vcs_code.LAST
       , TRUE
       , DBMS_SQL.native
      );
      DBMS_SQL.close_cursor (l_i_cursor_id);
   EXCEPTION
      WHEN OTHERS THEN
         DBMS_SQL.close_cursor (l_i_cursor_id);

         FOR i IN l_vcs_code.FIRST .. l_vcs_code.LAST LOOP
            DBMS_OUTPUT.put_line (l_vcs_code (i));
         END LOOP;

         RAISE;
   END prc_execute;

   PROCEDURE prc_migrate_table (
      p_vc_table_name_trg    VARCHAR2
    , p_vc_table_name_src    VARCHAR2
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE
         fct_get_table_migrate_stmt (
            UPPER (TRIM (p_vc_table_name_trg))
          , UPPER (TRIM (p_vc_table_name_src))
         );

      COMMIT;
   EXCEPTION
      WHEN OTHERS THEN
         NULL;
   END prc_migrate_table;

   PROCEDURE prc_backup_table (
      p_vc_table_name     VARCHAR2
    , p_vc_backup_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
   BEGIN
      prc_drop_object (
         'TABLE'
       , p_vc_backup_name
      );

      EXECUTE IMMEDIATE
            'CREATE TABLE '
         || p_vc_backup_name
         || ' AS SELECT * FROM '
         || p_vc_table_name;
   EXCEPTION
      WHEN OTHERS THEN
         NULL;
   END prc_backup_table;

   PROCEDURE prc_drop_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_DROP_OBJECT';
      l_ddl_drop      VARCHAR2 (32000);
   BEGIN
      l_ddl_drop :=
            'DROP '
         || p_vc_object_type
         || ' '
         || p_vc_object_name;

      EXECUTE IMMEDIATE l_ddl_drop;
   EXCEPTION
      WHEN OTHERS THEN
         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_drop_object;

   PROCEDURE prc_create_synonym (
      p_vc_object_name     VARCHAR2
    , p_vc_synonym_name    VARCHAR2
    , p_b_public           BOOLEAN DEFAULT FALSE
    , p_b_drop_flag        BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_object_type   t_object_name;
   BEGIN
      l_vc_object_type :=
            CASE
               WHEN p_b_public THEN
                  'PUBLIC '
            END
         || 'SYNONYM';

      IF p_b_drop_flag THEN
         prc_drop_object (
            l_vc_object_type
          , p_vc_synonym_name
          , FALSE
         );
      END IF;

      EXECUTE IMMEDIATE
            'CREATE '
         || l_vc_object_type
         || ' '
         || p_vc_synonym_name
         || ' FOR '
         || p_vc_object_name;
   EXCEPTION
      WHEN OTHERS THEN
         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_synonym;

   PROCEDURE prc_create_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_object_ddl     CLOB
    , p_b_drop_flag       BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_object_ddl   CLOB;
   BEGIN
      IF p_b_drop_flag
     AND p_vc_object_type NOT IN ('PACKAGE BODY', 'CONSTRAINT') THEN
         prc_drop_object (
            p_vc_object_type
          , p_vc_object_name
          , FALSE
         );
      END IF;

      l_vc_object_ddl := p_vc_object_ddl;

      BEGIN
         prc_execute (l_vc_object_ddl);
      EXCEPTION
         WHEN OTHERS THEN
            IF p_b_raise_flag THEN
               RAISE;
            END IF;
      END;
   END;

   PROCEDURE prc_create_entity (
      p_vc_entity_prefix    VARCHAR2
    , p_vc_entity_name      VARCHAR2
    , p_vc_entity_fields    VARCHAR2
    , p_vc_create_mode      VARCHAR2 DEFAULT 'DEFAULT'
    , p_b_public_flag       BOOLEAN DEFAULT FALSE
    , p_b_migrate_flag      BOOLEAN DEFAULT FALSE
    , p_b_cdc_flag          BOOLEAN DEFAULT FALSE
   )
   IS
      l_name_entity_tab   VARCHAR2 (100);
      l_name_entity_cdc   VARCHAR2 (100);
      l_name_entity_bkp   VARCHAR2 (100);
      l_name_entity_cbk   VARCHAR2 (100);
      l_name_entity_seq   VARCHAR2 (100);
      l_name_entity_id    VARCHAR2 (100);
      l_name_entity_pk    VARCHAR2 (100);
      l_columns_all       CLOB;
      l_columns_old       CLOB;
      l_columns_new       CLOB;
      l_sql_create        CLOB;
      l_n_cnt_tab         NUMBER;
      l_n_cnt_hst         NUMBER;
   BEGIN
      -- Set name of physical objects
      l_name_entity_tab := c_name_entity_tab;
      prc_set_text_param (
         l_name_entity_tab
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_tab
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_cdc := c_name_entity_cdc;
      prc_set_text_param (
         l_name_entity_cdc
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_cdc
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_seq := c_name_entity_seq;
      prc_set_text_param (
         l_name_entity_seq
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_seq
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_id := c_name_entity_id;
      prc_set_text_param (
         l_name_entity_id
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_id
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_pk := c_name_entity_pk;
      prc_set_text_param (
         l_name_entity_pk
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_pk
       , 'entityName'
       , p_vc_entity_name
      );

      IF p_b_migrate_flag THEN
         SELECT COUNT (0)
           INTO l_n_cnt_tab
           FROM user_tables
          WHERE table_name = TRIM (UPPER (l_name_entity_tab));

         IF l_n_cnt_tab > 0 THEN
            l_name_entity_bkp := c_name_entity_bkp;
            prc_set_text_param (
               l_name_entity_bkp
             , 'entityPrefix'
             , p_vc_entity_prefix
            );
            prc_set_text_param (
               l_name_entity_bkp
             , 'entityName'
             , p_vc_entity_name
            );
            prc_backup_table (
               l_name_entity_tab
             , l_name_entity_bkp
            );
         END IF;
      END IF;

      IF p_b_migrate_flag
     AND p_b_cdc_flag THEN
         SELECT COUNT (0)
           INTO l_n_cnt_hst
           FROM user_tables
          WHERE table_name = TRIM (UPPER (l_name_entity_cdc));

         IF l_n_cnt_hst > 0 THEN
            l_name_entity_cbk := c_name_entity_cbk;
            prc_set_text_param (
               l_name_entity_cbk
             , 'entityPrefix'
             , p_vc_entity_prefix
            );
            prc_set_text_param (
               l_name_entity_cbk
             , 'entityName'
             , p_vc_entity_name
            );
            prc_backup_table (
               l_name_entity_cdc
             , l_name_entity_cbk
            );
         END IF;
      END IF;

      -- Drop physical objects if required
      IF p_vc_create_mode = 'DROP' THEN
         -- Drop table
         prc_drop_object (
            'TABLE'
          , l_name_entity_tab
         );

         IF NOT p_b_migrate_flag THEN
            -- Drop sequence
            prc_drop_object (
               'SEQUENCE'
             , l_name_entity_seq
            );
         END IF;
      END IF;

      IF p_vc_create_mode = 'DROP'
     AND p_b_cdc_flag THEN
         -- Drop table
         prc_drop_object (
            'TABLE'
          , l_name_entity_cdc
         );
      END IF;

      -- Create table
      l_sql_create := c_template_entity_tab;
      prc_set_text_param (
         l_sql_create
       , 'entityTable'
       , l_name_entity_tab
      );
      prc_set_text_param (
         l_sql_create
       , 'entityId'
       , l_name_entity_id
      );
      prc_set_text_param (
         l_sql_create
       , 'entityPK'
       , l_name_entity_pk
      );
      prc_set_text_param (
         l_sql_create
       , 'columnDefinitionList'
       , p_vc_entity_fields
      );
      prc_execute (l_sql_create);

      IF p_b_cdc_flag THEN
         -- Create CDC table
         l_sql_create := c_template_entity_cdc;
         prc_set_text_param (
            l_sql_create
          , 'entityCDC'
          , l_name_entity_cdc
         );
         prc_set_text_param (
            l_sql_create
          , 'entityId'
          , l_name_entity_id
         );
         prc_set_text_param (
            l_sql_create
          , 'columnDefinitionList'
          , p_vc_entity_fields
         );
         prc_execute (l_sql_create);
      END IF;

      -- Create sequence
      l_sql_create := c_template_entity_seq;
      prc_set_text_param (
         l_sql_create
       , 'entitySequence'
       , l_name_entity_seq
      );

      BEGIN
         prc_execute (l_sql_create);
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      -- Create triggers
      l_sql_create := c_template_entity_trg_ins;
      prc_set_text_param (
         l_sql_create
       , 'entityTable'
       , l_name_entity_tab
      );
      prc_set_text_param (
         l_sql_create
       , 'entityId'
       , l_name_entity_id
      );
      prc_set_text_param (
         l_sql_create
       , 'entitySequence'
       , l_name_entity_seq
      );
      prc_execute (l_sql_create);
      l_sql_create := c_template_entity_trg_upd;
      prc_set_text_param (
         l_sql_create
       , 'entityTable'
       , l_name_entity_tab
      );
      prc_execute (l_sql_create);

      IF p_b_public_flag THEN
         EXECUTE IMMEDIATE
               'GRANT SELECT ON '
            || l_name_entity_tab
            || ' TO PUBLIC';
      END IF;

      IF p_b_migrate_flag
     AND l_n_cnt_tab > 0 THEN
         -- Migrate content
         prc_migrate_table (
            l_name_entity_tab
          , l_name_entity_bkp
         );
      END IF;

      IF p_b_migrate_flag
     AND p_b_cdc_flag
     AND l_n_cnt_hst > 0 THEN
         -- Migrate history content
         prc_migrate_table (
            l_name_entity_cdc
          , l_name_entity_cbk
         );
      END IF;

      IF p_b_cdc_flag THEN
         -- Create CDC trigger
         l_columns_all :=
            p#frm#dict.fct_get_column_list (
               NULL
             , NULL
             , UPPER (l_name_entity_tab)
             , 'ALL'
             , 'LIST_SIMPLE'
            );
         l_columns_old :=
            p#frm#dict.fct_get_column_list (
               NULL
             , NULL
             , UPPER (l_name_entity_tab)
             , 'ALL'
             , 'LIST_ALIAS'
             , ':OLD'
            );
         l_columns_new :=
            p#frm#dict.fct_get_column_list (
               NULL
             , NULL
             , UPPER (l_name_entity_tab)
             , 'ALL'
             , 'LIST_ALIAS'
             , ':NEW'
            );
         l_sql_create := c_template_entity_trg_cdc;
         prc_set_text_param (
            l_sql_create
          , 'entityTable'
          , l_name_entity_tab
         );
         prc_set_text_param (
            l_sql_create
          , 'entityCDC'
          , l_name_entity_cdc
         );
         prc_set_text_param (
            l_sql_create
          , 'columnList'
          , l_columns_all
         );
         prc_set_text_param (
            l_sql_create
          , 'columnListOld'
          , l_columns_old
         );
         prc_set_text_param (
            l_sql_create
          , 'columnListNew'
          , l_columns_new
         );
         prc_execute (l_sql_create);
      END IF;
   END prc_create_entity;
BEGIN
   -- Versioning constants
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#ddls;
2014-11-28 13:53:12.955 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_ddls
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_SET_TEXT_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   FUNCTION fct_get_table_migrate_stmt (
      p_vc_table_name_trg    VARCHAR2
    , p_vc_table_name_src    VARCHAR2
   )
      RETURN CLOB
   IS
      l_vc_column_list   VARCHAR2 (32000);
   BEGIN
      l_vc_column_list :=
         dwhutl_dict.fct_get_column_subset (
            NULL
          , NULL
          , UPPER (p_vc_table_name_trg)
          , NULL
          , UPPER (p_vc_table_name_src)
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
         );
      RETURN    'INSERT INTO '
             || p_vc_table_name_trg
             || '('
             || l_vc_column_list
             || ') SELECT '
             || l_vc_column_list
             || ' FROM '
             || p_vc_table_name_src;
   END fct_get_table_migrate_stmt;

   PROCEDURE prc_execute (p_sql_code CLOB)
   IS
      l_vcs_code      DBMS_SQL.varchar2s;
      l_i_cursor_id   INTEGER;
   BEGIN
      l_vcs_code :=
         dwhutl_type.fct_clob_to_list (
            p_sql_code
          , CHR (10)
         );
      l_i_cursor_id := DBMS_SQL.open_cursor;
      DBMS_SQL.parse (
         l_i_cursor_id
       , l_vcs_code
       , l_vcs_code.FIRST
       , l_vcs_code.LAST
       , TRUE
       , DBMS_SQL.native
      );
      DBMS_SQL.close_cursor (l_i_cursor_id);
   EXCEPTION
      WHEN OTHERS THEN
         DBMS_SQL.close_cursor (l_i_cursor_id);

         FOR i IN l_vcs_code.FIRST .. l_vcs_code.LAST LOOP
            DBMS_OUTPUT.put_line (l_vcs_code (i));
         END LOOP;

         RAISE;
   END prc_execute;

   PROCEDURE prc_migrate_table (
      p_vc_table_name_trg    VARCHAR2
    , p_vc_table_name_src    VARCHAR2
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE
         fct_get_table_migrate_stmt (
            UPPER (TRIM (p_vc_table_name_trg))
          , UPPER (TRIM (p_vc_table_name_src))
         );

      COMMIT;
   EXCEPTION
      WHEN OTHERS THEN
         NULL;
   END prc_migrate_table;

   PROCEDURE prc_backup_table (
      p_vc_table_name     VARCHAR2
    , p_vc_backup_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
   BEGIN
      prc_drop_object (
         'TABLE'
       , p_vc_backup_name
      );

      EXECUTE IMMEDIATE
            'CREATE TABLE '
         || p_vc_backup_name
         || ' AS SELECT * FROM '
         || p_vc_table_name;
   EXCEPTION
      WHEN OTHERS THEN
         NULL;
   END prc_backup_table;

   PROCEDURE prc_drop_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_DROP_OBJECT';
      l_ddl_drop      VARCHAR2 (32000);
   BEGIN
      l_ddl_drop :=
            'DROP '
         || p_vc_object_type
         || ' '
         || p_vc_object_name;

      EXECUTE IMMEDIATE l_ddl_drop;
   EXCEPTION
      WHEN OTHERS THEN
         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_drop_object;

   PROCEDURE prc_create_synonym (
      p_vc_object_name     VARCHAR2
    , p_vc_synonym_name    VARCHAR2
    , p_b_public           BOOLEAN DEFAULT FALSE
    , p_b_drop_flag        BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_object_type   t_object_name;
   BEGIN
      l_vc_object_type :=
            CASE
               WHEN p_b_public THEN
                  'PUBLIC '
            END
         || 'SYNONYM';

      IF p_b_drop_flag THEN
         prc_drop_object (
            l_vc_object_type
          , p_vc_synonym_name
          , FALSE
         );
      END IF;

      EXECUTE IMMEDIATE
            'CREATE '
         || l_vc_object_type
         || ' '
         || p_vc_synonym_name
         || ' FOR '
         || p_vc_object_name;
   EXCEPTION
      WHEN OTHERS THEN
         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_synonym;

   PROCEDURE prc_create_object (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_object_ddl     CLOB
    , p_b_drop_flag       BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_object_ddl   CLOB;
   BEGIN
      IF p_b_drop_flag
     AND p_vc_object_type NOT IN ('PACKAGE BODY', 'CONSTRAINT') THEN
         prc_drop_object (
            p_vc_object_type
          , p_vc_object_name
          , FALSE
         );
      END IF;

      l_vc_object_ddl := p_vc_object_ddl;

      BEGIN
         prc_execute (l_vc_object_ddl);
      EXCEPTION
         WHEN OTHERS THEN
            IF p_b_raise_flag THEN
               RAISE;
            END IF;
      END;
   END;

   PROCEDURE prc_create_entity (
      p_vc_entity_prefix    VARCHAR2
    , p_vc_entity_name      VARCHAR2
    , p_vc_entity_fields    VARCHAR2
    , p_vc_create_mode      VARCHAR2 DEFAULT 'DEFAULT'
    , p_b_public_flag       BOOLEAN DEFAULT FALSE
    , p_b_migrate_flag      BOOLEAN DEFAULT FALSE
    , p_b_cdc_flag          BOOLEAN DEFAULT FALSE
   )
   IS
      l_name_entity_tab   VARCHAR2 (100);
      l_name_entity_cdc   VARCHAR2 (100);
      l_name_entity_bkp   VARCHAR2 (100);
      l_name_entity_cbk   VARCHAR2 (100);
      l_name_entity_seq   VARCHAR2 (100);
      l_name_entity_id    VARCHAR2 (100);
      l_name_entity_pk    VARCHAR2 (100);
      l_columns_all       CLOB;
      l_columns_old       CLOB;
      l_columns_new       CLOB;
      l_sql_create        CLOB;
      l_n_cnt_tab         NUMBER;
      l_n_cnt_hst         NUMBER;
   BEGIN
      -- Set name of physical objects
      l_name_entity_tab := c_name_entity_tab;
      prc_set_text_param (
         l_name_entity_tab
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_tab
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_cdc := c_name_entity_cdc;
      prc_set_text_param (
         l_name_entity_cdc
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_cdc
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_seq := c_name_entity_seq;
      prc_set_text_param (
         l_name_entity_seq
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_seq
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_id := c_name_entity_id;
      prc_set_text_param (
         l_name_entity_id
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_id
       , 'entityName'
       , p_vc_entity_name
      );
      --
      l_name_entity_pk := c_name_entity_pk;
      prc_set_text_param (
         l_name_entity_pk
       , 'entityPrefix'
       , p_vc_entity_prefix
      );
      prc_set_text_param (
         l_name_entity_pk
       , 'entityName'
       , p_vc_entity_name
      );

      IF p_b_migrate_flag THEN
         SELECT COUNT (0)
           INTO l_n_cnt_tab
           FROM user_tables
          WHERE table_name = TRIM (UPPER (l_name_entity_tab));

         IF l_n_cnt_tab > 0 THEN
            l_name_entity_bkp := c_name_entity_bkp;
            prc_set_text_param (
               l_name_entity_bkp
             , 'entityPrefix'
             , p_vc_entity_prefix
            );
            prc_set_text_param (
               l_name_entity_bkp
             , 'entityName'
             , p_vc_entity_name
            );
            prc_backup_table (
               l_name_entity_tab
             , l_name_entity_bkp
            );
         END IF;
      END IF;

      IF p_b_migrate_flag
     AND p_b_cdc_flag THEN
         SELECT COUNT (0)
           INTO l_n_cnt_hst
           FROM user_tables
          WHERE table_name = TRIM (UPPER (l_name_entity_cdc));

         IF l_n_cnt_hst > 0 THEN
            l_name_entity_cbk := c_name_entity_cbk;
            prc_set_text_param (
               l_name_entity_cbk
             , 'entityPrefix'
             , p_vc_entity_prefix
            );
            prc_set_text_param (
               l_name_entity_cbk
             , 'entityName'
             , p_vc_entity_name
            );
            prc_backup_table (
               l_name_entity_cdc
             , l_name_entity_cbk
            );
         END IF;
      END IF;

      -- Drop physical objects if required
      IF p_vc_create_mode = 'DROP' THEN
         -- Drop table
         prc_drop_object (
            'TABLE'
          , l_name_entity_tab
         );

         IF NOT p_b_migrate_flag THEN
            -- Drop sequence
            prc_drop_object (
               'SEQUENCE'
             , l_name_entity_seq
            );
         END IF;
      END IF;

      IF p_vc_create_mode = 'DROP'
     AND p_b_cdc_flag THEN
         -- Drop table
         prc_drop_object (
            'TABLE'
          , l_name_entity_cdc
         );
      END IF;

      -- Create table
      l_sql_create := c_template_entity_tab;
      prc_set_text_param (
         l_sql_create
       , 'entityTable'
       , l_name_entity_tab
      );
      prc_set_text_param (
         l_sql_create
       , 'entityId'
       , l_name_entity_id
      );
      prc_set_text_param (
         l_sql_create
       , 'entityPK'
       , l_name_entity_pk
      );
      prc_set_text_param (
         l_sql_create
       , 'columnDefinitionList'
       , p_vc_entity_fields
      );
      prc_execute (l_sql_create);

      IF p_b_cdc_flag THEN
         -- Create CDC table
         l_sql_create := c_template_entity_cdc;
         prc_set_text_param (
            l_sql_create
          , 'entityCDC'
          , l_name_entity_cdc
         );
         prc_set_text_param (
            l_sql_create
          , 'entityId'
          , l_name_entity_id
         );
         prc_set_text_param (
            l_sql_create
          , 'columnDefinitionList'
          , p_vc_entity_fields
         );
         prc_execute (l_sql_create);
      END IF;

      -- Create sequence
      l_sql_create := c_template_entity_seq;
      prc_set_text_param (
         l_sql_create
       , 'entitySequence'
       , l_name_entity_seq
      );

      BEGIN
         prc_execute (l_sql_create);
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      -- Create triggers
      l_sql_create := c_template_entity_trg_ins;
      prc_set_text_param (
         l_sql_create
       , 'entityTable'
       , l_name_entity_tab
      );
      prc_set_text_param (
         l_sql_create
       , 'entityId'
       , l_name_entity_id
      );
      prc_set_text_param (
         l_sql_create
       , 'entitySequence'
       , l_name_entity_seq
      );
      prc_execute (l_sql_create);
      l_sql_create := c_template_entity_trg_upd;
      prc_set_text_param (
         l_sql_create
       , 'entityTable'
       , l_name_entity_tab
      );
      prc_execute (l_sql_create);

      IF p_b_public_flag THEN
         EXECUTE IMMEDIATE
               'GRANT SELECT ON '
            || l_name_entity_tab
            || ' TO PUBLIC';
      END IF;

      IF p_b_migrate_flag
     AND l_n_cnt_tab > 0 THEN
         -- Migrate content
         prc_migrate_table (
            l_name_entity_tab
          , l_name_entity_bkp
         );
      END IF;

      IF p_b_migrate_flag
     AND p_b_cdc_flag
     AND l_n_cnt_hst > 0 THEN
         -- Migrate history content
         prc_migrate_table (
            l_name_entity_cdc
          , l_name_entity_cbk
         );
      END IF;

      IF p_b_cdc_flag THEN
         -- Create CDC trigger
         l_columns_all :=
            dwhutl_dict.fct_get_column_list (
               NULL
             , NULL
             , UPPER (l_name_entity_tab)
             , 'ALL'
             , 'LIST_SIMPLE'
            );
         l_columns_old :=
            dwhutl_dict.fct_get_column_list (
               NULL
             , NULL
             , UPPER (l_name_entity_tab)
             , 'ALL'
             , 'LIST_ALIAS'
             , ':OLD'
            );
         l_columns_new :=
            dwhutl_dict.fct_get_column_list (
               NULL
             , NULL
             , UPPER (l_name_entity_tab)
             , 'ALL'
             , 'LIST_ALIAS'
             , ':NEW'
            );
         l_sql_create := c_template_entity_trg_cdc;
         prc_set_text_param (
            l_sql_create
          , 'entityTable'
          , l_name_entity_tab
         );
         prc_set_text_param (
            l_sql_create
          , 'entityCDC'
          , l_name_entity_cdc
         );
         prc_set_text_param (
            l_sql_create
          , 'columnList'
          , l_columns_all
         );
         prc_set_text_param (
            l_sql_create
          , 'columnListOld'
          , l_columns_old
         );
         prc_set_text_param (
            l_sql_create
          , 'columnListNew'
          , l_columns_new
         );
         prc_execute (l_sql_create);
      END IF;
   END prc_create_entity;
BEGIN
   -- Versioning constants
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_ddls;
2014-11-28 13:53:12.978 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/ddls/ddls-impl.sql executed
2014-11-28 13:53:12.978 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/auth/auth-def.sql delimiter 
2014-11-28 13:53:12.979 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#auth
AS
   /**
   *
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_grant_tool (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_tool (p_vc_schema VARCHAR2);

   PROCEDURE prc_grant_trac (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_trac (p_vc_schema VARCHAR2);

   PROCEDURE prc_grant_mesr (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_mesr (p_vc_schema VARCHAR2);

   PROCEDURE prc_grant_stag (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_stag (p_vc_schema VARCHAR2);
END p#frm#auth;
2014-11-28 13:53:12.979 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_auth
AS
   /**
   *
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_grant_tool (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_tool (p_vc_schema VARCHAR2);

   PROCEDURE prc_grant_trac (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_trac (p_vc_schema VARCHAR2);

   PROCEDURE prc_grant_mesr (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_mesr (p_vc_schema VARCHAR2);

   PROCEDURE prc_grant_stag (p_vc_schema VARCHAR2);

   PROCEDURE prc_revoke_stag (p_vc_schema VARCHAR2);
END dwhutl_auth;
2014-11-28 13:53:13.014 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/auth/auth-def.sql executed
2014-11-28 13:53:13.014 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/auth/auth-impl.sql delimiter 
2014-11-28 13:53:13.016 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#auth
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   TYPE t_statement IS TABLE OF VARCHAR2 (1000);

   l_grant_tool    t_statement
                      := t_statement (
                            'GRANT EXECUTE ON p#frm#type TO '
                          , 'GRANT EXECUTE ON p#frm#dict TO '
                          , 'GRANT EXECUTE ON p#frm#stmt TO '
                          , 'GRANT EXECUTE ON p#frm#ddls TO '
                          , 'GRANT EXECUTE ON p#frm#enbl TO '
                         );
   l_revoke_tool   t_statement
                      := t_statement (
                            'REVOKE EXECUTE ON p#frm#type FROM '
                          , 'REVOKE EXECUTE ON p#frm#dict FROM '
                          , 'REVOKE EXECUTE ON p#frm#stmt FROM '
                          , 'REVOKE EXECUTE ON p#frm#ddls FROM '
                          , 'REVOKE EXECUTE ON p#frm#enbl FROM '
                         );
   l_grant_trac    t_statement
                      := t_statement (
                            'GRANT INSERT,UPDATE ON p#frm#trac_t TO '
                          , 'GRANT EXECUTE ON p#frm#trac_param TO '
                          , 'GRANT EXECUTE ON p#frm#trac TO '
                         );
   l_revoke_trac   t_statement
                      := t_statement (
                            'REVOKE INSERT,UPDATE ON p#frm#trac_t FROM '
                          , 'REVOKE EXECUTE ON p#frm#trac_param FROM '
                          , 'REVOKE EXECUTE ON p#frm#trac FROM '
                         );
   l_grant_mesr    t_statement
                      := t_statement (
                            'GRANT INSERT,UPDATE,DELETE ON p#frm#user_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#taxn_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#taxn_user_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#mesr_taxn_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#mesr_query_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#mesr_keyfigure_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#mesr_threshold_t TO '
                          , 'GRANT INSERT,DELETE ON p#frm#mesr_exec_t TO '
                          , 'GRANT EXECUTE ON p#frm#mesr TO '
                         );
   l_revoke_mesr   t_statement
                      := t_statement (
                            'REVOKE INSERT,UPDATE,DELETE ON p#frm#user_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#taxn_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#taxn_user_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#mesr_taxn_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#mesr_query_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#mesr_keyfigure_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#mesr_threshold_t FROM '
                          , 'REVOKE INSERT,DELETE ON p#frm#mesr_exec_t FROM '
                          , 'REVOKE EXECUTE ON p#frm#mesr FROM '
                         );
   l_grant_stag    t_statement
                      := t_statement (
                            'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_stat_type_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_stat_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_size_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_ddl_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_source_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_source_db_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_object_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_column_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_column_check_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_queue_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON p#frm#stag_queue_object_t TO '
                          , 'GRANT EXECUTE ON p#frm#stag_param TO '
                          , 'GRANT EXECUTE ON p#frm#stag_stat TO '
                          , 'GRANT EXECUTE ON p#frm#stag_meta TO '
                          , 'GRANT EXECUTE ON p#frm#stag_ddl TO '
                          , 'GRANT EXECUTE ON p#frm#stag_build TO '
                          , 'GRANT EXECUTE ON p#frm#stag_ctl TO '
                         );
   l_revoke_stag   t_statement
                      := t_statement (
                            'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_stat_type_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_stat_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_size_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_ddl_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_source_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_source_db_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_object_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_column_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_column_check_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_queue_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON p#frm#stag_queue_object_t FROM '
                          , 'REVOKE EXECUTE ON p#frm#stag_param FROM '
                          , 'REVOKE EXECUTE ON p#frm#stag_stat FROM '
                          , 'REVOKE EXECUTE ON p#frm#stag_meta FROM '
                          , 'REVOKE EXECUTE ON p#frm#stag_ddl FROM '
                          , 'REVOKE EXECUTE ON p#frm#stag_build FROM '
                          , 'REVOKE EXECUTE ON p#frm#stag_ctl FROM '
                         );

   PROCEDURE prc_grant_tool (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_tool.FIRST .. l_grant_tool.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_tool (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_revoke_tool (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_tool.FIRST .. l_revoke_tool.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_tool (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_grant_trac (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_trac.FIRST .. l_grant_trac.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_trac (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_revoke_trac (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_trac.FIRST .. l_revoke_trac.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_trac (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_grant_mesr (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_mesr.FIRST .. l_grant_mesr.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_mesr (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_revoke_mesr (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_mesr.FIRST .. l_revoke_mesr.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_mesr (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_grant_stag (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_stag.FIRST .. l_grant_stag.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_stag (i)
            || p_vc_schema;
      END LOOP;
   END prc_grant_stag;

   PROCEDURE prc_revoke_stag (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_stag.FIRST .. l_revoke_stag.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_stag (i)
            || p_vc_schema;
      END LOOP;
   END prc_revoke_stag;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#auth;
2014-11-28 13:53:13.016 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_auth
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   TYPE t_statement IS TABLE OF VARCHAR2 (1000);

   l_grant_tool    t_statement
                      := t_statement (
                            'GRANT EXECUTE ON dwhutl_type TO '
                          , 'GRANT EXECUTE ON dwhutl_dict TO '
                          , 'GRANT EXECUTE ON dwhutl_stmt TO '
                          , 'GRANT EXECUTE ON dwhutl_ddls TO '
                          , 'GRANT EXECUTE ON dwhutl_enbl TO '
                         );
   l_revoke_tool   t_statement
                      := t_statement (
                            'REVOKE EXECUTE ON dwhutl_type FROM '
                          , 'REVOKE EXECUTE ON dwhutl_dict FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stmt FROM '
                          , 'REVOKE EXECUTE ON dwhutl_ddls FROM '
                          , 'REVOKE EXECUTE ON dwhutl_enbl FROM '
                         );
   l_grant_trac    t_statement
                      := t_statement (
                            'GRANT INSERT,UPDATE ON dwhutl_trac_t TO '
                          , 'GRANT EXECUTE ON dwhutl_trac_param TO '
                          , 'GRANT EXECUTE ON dwhutl_trac TO '
                         );
   l_revoke_trac   t_statement
                      := t_statement (
                            'REVOKE INSERT,UPDATE ON dwhutl_trac_t FROM '
                          , 'REVOKE EXECUTE ON dwhutl_trac_param FROM '
                          , 'REVOKE EXECUTE ON dwhutl_trac FROM '
                         );
   l_grant_mesr    t_statement
                      := t_statement (
                            'GRANT INSERT,UPDATE,DELETE ON dwhutl_user_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_taxn_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_taxn_user_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_mesr_taxn_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_mesr_query_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_mesr_keyfigure_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_mesr_threshold_t TO '
                          , 'GRANT INSERT,DELETE ON dwhutl_mesr_exec_t TO '
                          , 'GRANT EXECUTE ON dwhutl_mesr TO '
                         );
   l_revoke_mesr   t_statement
                      := t_statement (
                            'REVOKE INSERT,UPDATE,DELETE ON dwhutl_user_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_taxn_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_taxn_user_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_mesr_taxn_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_mesr_query_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_mesr_keyfigure_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_mesr_threshold_t FROM '
                          , 'REVOKE INSERT,DELETE ON dwhutl_mesr_exec_t FROM '
                          , 'REVOKE EXECUTE ON dwhutl_mesr FROM '
                         );
   l_grant_stag    t_statement
                      := t_statement (
                            'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_stat_type_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_stat_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_size_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_ddl_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_source_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_source_db_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_object_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_column_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_column_check_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_queue_t TO '
                          , 'GRANT INSERT,UPDATE,DELETE ON dwhutl_stag_queue_object_t TO '
                          , 'GRANT EXECUTE ON dwhutl_stag_param TO '
                          , 'GRANT EXECUTE ON dwhutl_stag_stat TO '
                          , 'GRANT EXECUTE ON dwhutl_stag_meta TO '
                          , 'GRANT EXECUTE ON dwhutl_stag_ddl TO '
                          , 'GRANT EXECUTE ON dwhutl_stag_build TO '
                          , 'GRANT EXECUTE ON dwhutl_stag_ctl TO '
                         );
   l_revoke_stag   t_statement
                      := t_statement (
                            'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_stat_type_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_stat_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_size_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_ddl_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_source_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_source_db_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_object_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_column_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_column_check_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_queue_t FROM '
                          , 'REVOKE INSERT,UPDATE,DELETE ON dwhutl_stag_queue_object_t FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stag_param FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stag_stat FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stag_meta FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stag_ddl FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stag_build FROM '
                          , 'REVOKE EXECUTE ON dwhutl_stag_ctl FROM '
                         );

   PROCEDURE prc_grant_tool (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_tool.FIRST .. l_grant_tool.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_tool (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_revoke_tool (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_tool.FIRST .. l_revoke_tool.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_tool (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_grant_trac (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_trac.FIRST .. l_grant_trac.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_trac (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_revoke_trac (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_trac.FIRST .. l_revoke_trac.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_trac (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_grant_mesr (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_mesr.FIRST .. l_grant_mesr.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_mesr (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_revoke_mesr (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_mesr.FIRST .. l_revoke_mesr.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_mesr (i)
            || p_vc_schema;
      END LOOP;
   END;

   PROCEDURE prc_grant_stag (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_grant_stag.FIRST .. l_grant_stag.LAST LOOP
         EXECUTE IMMEDIATE
               l_grant_stag (i)
            || p_vc_schema;
      END LOOP;
   END prc_grant_stag;

   PROCEDURE prc_revoke_stag (p_vc_schema VARCHAR2)
   IS
   BEGIN
      FOR i IN l_revoke_stag.FIRST .. l_revoke_stag.LAST LOOP
         EXECUTE IMMEDIATE
               l_revoke_stag (i)
            || p_vc_schema;
      END LOOP;
   END prc_revoke_stag;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_auth;
2014-11-28 13:53:13.046 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/auth/auth-impl.sql executed
2014-11-28 13:53:13.046 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/enbl/enbl-def.sql delimiter 
2014-11-28 13:53:13.047 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#enbl
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_enable_tool (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_tool;

   PROCEDURE prc_enable_trac (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_trac;

   PROCEDURE prc_enable_mesr (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_mesr;

   PROCEDURE prc_enable_stag (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_stag;
END p#frm#enbl;
2014-11-28 13:53:13.047 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_enbl
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_enable_tool (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_tool;

   PROCEDURE prc_enable_trac (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_trac;

   PROCEDURE prc_enable_mesr (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_mesr;

   PROCEDURE prc_enable_stag (p_vc_tools_owner IN VARCHAR2);

   PROCEDURE prc_disable_stag;
END dwhutl_enbl;
2014-11-28 13:53:13.070 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/enbl/enbl-def.sql executed
2014-11-28 13:53:13.070 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/enbl/enbl-impl.sql delimiter 
2014-11-28 13:53:13.071 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#enbl
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   TYPE t_statement IS TABLE OF VARCHAR2 (1000);

   l_synonym_tool   t_statement
                       := t_statement (
                             'p#frm#type'
                           , 'p#frm#dict'
                           , 'p#frm#stmt'
                           , 'p#frm#ddls'
                          );
   l_synonym_trac   t_statement
                       := t_statement (
                             'p#frm#trac_param'
                           , 'p#frm#trac_t'
                           , 'p#frm#trac'
                          );
   l_synonym_mesr   t_statement
                       := t_statement (
                             'p#frm#docu_t'
                           , 'p#frm#user_t'
                           , 'p#frm#taxn_t'
                           , 'p#frm#taxn_user_t'
                           , 'p#frm#mesr_taxn_t'
                           , 'p#frm#mesr_query_t'
                           , 'p#frm#mesr_keyfigure_t'
                           , 'p#frm#mesr_threshold_t'
                           , 'p#frm#mesr_exec_t'
                           , 'p#frm#docu'
                           , 'p#frm#mesr'
                          );
   l_synonym_stag   t_statement
                       := t_statement (
                             'p#frm#stag_stat_type_t'
                           , 'p#frm#stag_stat_t'
                           , 'p#frm#stag_size_t'
                           , 'p#frm#stag_ddl_t'
                           , 'p#frm#stag_source_t'
                           , 'p#frm#stag_source_db_t'
                           , 'p#frm#stag_object_t'
                           , 'p#frm#stag_column_t'
                           , 'p#frm#stag_column_check_t'
                           , 'p#frm#stag_queue_t'
                           , 'p#frm#stag_queue_object_t'
                           , 'p#frm#stag_param'
                           , 'p#frm#stag_stat'
                           , 'p#frm#stag_meta'
                           , 'p#frm#stag_ddl'
                           , 'p#frm#stag_build'
                           , 'p#frm#stag_ctl'
                          );

   /**
   * Common help procedures
   */
   PROCEDURE prc_create_synonym (
      p_vc_tools_owner   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
   )
   IS
   BEGIN
      BEGIN
         EXECUTE IMMEDIATE
               'DROP SYNONYM '
            || p_vc_object_name;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      EXECUTE IMMEDIATE
            'CREATE SYNONYM '
         || p_vc_object_name
         || ' FOR '
         || p_vc_tools_owner
         || '.'
         || p_vc_object_name;
   END;

   PROCEDURE prc_drop_synonym (p_vc_object_name IN VARCHAR2)
   IS
   BEGIN
      BEGIN
         EXECUTE IMMEDIATE
               'DROP SYNONYM '
            || p_vc_object_name;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;
   END;

   /**
   * Main procedures
   */
   PROCEDURE prc_enable_tool (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_tool.FIRST .. l_synonym_tool.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_tool (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_tool
   IS
   BEGIN
      FOR i IN l_synonym_tool.FIRST .. l_synonym_tool.LAST LOOP
         prc_drop_synonym (l_synonym_tool (i));
      END LOOP;
   END;

   PROCEDURE prc_enable_trac (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_trac.FIRST .. l_synonym_trac.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_trac (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_trac
   IS
   BEGIN
      FOR i IN l_synonym_trac.FIRST .. l_synonym_trac.LAST LOOP
         prc_drop_synonym (l_synonym_trac (i));
      END LOOP;
   END;

   PROCEDURE prc_enable_mesr (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_mesr.FIRST .. l_synonym_mesr.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_mesr (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_mesr
   IS
   BEGIN
      FOR i IN l_synonym_mesr.FIRST .. l_synonym_mesr.LAST LOOP
         prc_drop_synonym (l_synonym_mesr (i));
      END LOOP;
   END;

   PROCEDURE prc_enable_stag (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_stag.FIRST .. l_synonym_stag.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_stag (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_stag
   IS
   BEGIN
      FOR i IN l_synonym_stag.FIRST .. l_synonym_stag.LAST LOOP
         prc_drop_synonym (l_synonym_stag (i));
      END LOOP;
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#enbl;
2014-11-28 13:53:13.072 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_enbl
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   TYPE t_statement IS TABLE OF VARCHAR2 (1000);

   l_synonym_tool   t_statement
                       := t_statement (
                             'dwhutl_type'
                           , 'dwhutl_dict'
                           , 'dwhutl_stmt'
                           , 'dwhutl_ddls'
                          );
   l_synonym_trac   t_statement
                       := t_statement (
                             'dwhutl_trac_param'
                           , 'dwhutl_trac_t'
                           , 'dwhutl_trac'
                          );
   l_synonym_mesr   t_statement
                       := t_statement (
                             'dwhutl_docu_t'
                           , 'dwhutl_user_t'
                           , 'dwhutl_taxn_t'
                           , 'dwhutl_taxn_user_t'
                           , 'dwhutl_mesr_taxn_t'
                           , 'dwhutl_mesr_query_t'
                           , 'dwhutl_mesr_keyfigure_t'
                           , 'dwhutl_mesr_threshold_t'
                           , 'dwhutl_mesr_exec_t'
                           , 'dwhutl_docu'
                           , 'dwhutl_mesr'
                          );
   l_synonym_stag   t_statement
                       := t_statement (
                             'dwhutl_stag_stat_type_t'
                           , 'dwhutl_stag_stat_t'
                           , 'dwhutl_stag_size_t'
                           , 'dwhutl_stag_ddl_t'
                           , 'dwhutl_stag_source_t'
                           , 'dwhutl_stag_source_db_t'
                           , 'dwhutl_stag_object_t'
                           , 'dwhutl_stag_column_t'
                           , 'dwhutl_stag_column_check_t'
                           , 'dwhutl_stag_queue_t'
                           , 'dwhutl_stag_queue_object_t'
                           , 'dwhutl_stag_param'
                           , 'dwhutl_stag_stat'
                           , 'dwhutl_stag_meta'
                           , 'dwhutl_stag_ddl'
                           , 'dwhutl_stag_build'
                           , 'dwhutl_stag_ctl'
                          );

   /**
   * Common help procedures
   */
   PROCEDURE prc_create_synonym (
      p_vc_tools_owner   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
   )
   IS
   BEGIN
      BEGIN
         EXECUTE IMMEDIATE
               'DROP SYNONYM '
            || p_vc_object_name;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      EXECUTE IMMEDIATE
            'CREATE SYNONYM '
         || p_vc_object_name
         || ' FOR '
         || p_vc_tools_owner
         || '.'
         || p_vc_object_name;
   END;

   PROCEDURE prc_drop_synonym (p_vc_object_name IN VARCHAR2)
   IS
   BEGIN
      BEGIN
         EXECUTE IMMEDIATE
               'DROP SYNONYM '
            || p_vc_object_name;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;
   END;

   /**
   * Main procedures
   */
   PROCEDURE prc_enable_tool (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_tool.FIRST .. l_synonym_tool.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_tool (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_tool
   IS
   BEGIN
      FOR i IN l_synonym_tool.FIRST .. l_synonym_tool.LAST LOOP
         prc_drop_synonym (l_synonym_tool (i));
      END LOOP;
   END;

   PROCEDURE prc_enable_trac (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_trac.FIRST .. l_synonym_trac.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_trac (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_trac
   IS
   BEGIN
      FOR i IN l_synonym_trac.FIRST .. l_synonym_trac.LAST LOOP
         prc_drop_synonym (l_synonym_trac (i));
      END LOOP;
   END;

   PROCEDURE prc_enable_mesr (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_mesr.FIRST .. l_synonym_mesr.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_mesr (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_mesr
   IS
   BEGIN
      FOR i IN l_synonym_mesr.FIRST .. l_synonym_mesr.LAST LOOP
         prc_drop_synonym (l_synonym_mesr (i));
      END LOOP;
   END;

   PROCEDURE prc_enable_stag (p_vc_tools_owner IN VARCHAR2)
   IS
   BEGIN
      FOR i IN l_synonym_stag.FIRST .. l_synonym_stag.LAST LOOP
         prc_create_synonym (
            p_vc_tools_owner
          , l_synonym_stag (i)
         );
      END LOOP;
   END;

   PROCEDURE prc_disable_stag
   IS
   BEGIN
      FOR i IN l_synonym_stag.FIRST .. l_synonym_stag.LAST LOOP
         prc_drop_synonym (l_synonym_stag (i));
      END LOOP;
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_enbl;
2014-11-28 13:53:13.098 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/enbl/enbl-impl.sql executed
2014-11-28 13:53:13.098 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Module all installed
2014-11-28 13:53:13.099 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Found module "trac"
2014-11-28 13:53:13.099 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Installing all module
2014-11-28 13:53:13.099 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/trac_t.sql delimiter 
2014-11-28 13:53:13.100 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'trac'
    , 'trac_severity NUMBER,
       trac_message_short VARCHAR2(500 CHAR),
       trac_message_long VARCHAR2(4000 CHAR),
       trac_text CLOB,
       trac_object_name VARCHAR2(200 CHAR),
       trac_subprogram_name VARCHAR2(200 CHAR),
       trac_line_number NUMBER,
	   trac_audsid VARCHAR2(100 CHAR),
       trac_terminal VARCHAR2(100 CHAR),
       trac_rowcount NUMBER,
       trac_sqlcode NUMBER,
       trac_sqlerrm VARCHAR2(1000 CHAR),
       trac_call_stack VARCHAR2(4000 CHAR),
	   trac_external_job_id NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:13.100 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'trac'
    , 'trac_severity NUMBER,
       trac_message_short VARCHAR2(500 CHAR),
       trac_message_long VARCHAR2(4000 CHAR),
       trac_text CLOB,
       trac_object_name VARCHAR2(200 CHAR),
       trac_subprogram_name VARCHAR2(200 CHAR),
       trac_line_number NUMBER,
	   trac_audsid VARCHAR2(100 CHAR),
       trac_terminal VARCHAR2(100 CHAR),
       trac_rowcount NUMBER,
       trac_sqlcode NUMBER,
       trac_sqlerrm VARCHAR2(1000 CHAR),
       trac_call_stack VARCHAR2(4000 CHAR),
	   trac_external_job_id NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:16.911 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/trac_t.sql executed
2014-11-28 13:53:16.912 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/trac_v.sql delimiter ;
2014-11-28 13:53:16.913 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#trac_v
AS
     SELECT *
       FROM p#frm#trac_t
   ORDER BY trac_id DESC;

2014-11-28 13:53:16.914 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_trac_v
AS
     SELECT *
       FROM dwhutl_trac_t
   ORDER BY trac_id DESC;

2014-11-28 13:53:17.016 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/trac_v.sql executed
2014-11-28 13:53:17.016 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/trac_param/trac_param-def.sql delimiter 
2014-11-28 13:53:17.017 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#trac_param
   AUTHID CURRENT_USER
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   --
   gc_log_off     CONSTANT NUMBER := 0;
   gc_log_fatal   CONSTANT NUMBER := 1;
   gc_log_error   CONSTANT NUMBER := 2;
   gc_log_warn    CONSTANT NUMBER := 3;
   gc_log_info    CONSTANT NUMBER := 4;
   gc_log_debug   CONSTANT NUMBER := 5;
   gc_log_trace   CONSTANT NUMBER := 6;
   gc_log_all     CONSTANT NUMBER := 6;
   --
   g_b_log_console         BOOLEAN := FALSE;                                                                                                                                                                             -- If TRUE, log is sent to dbms_output
   g_b_log_table           BOOLEAN := TRUE;                                                                                                                                                                         -- If TRUE, log is written in the log table
   g_n_log_level           NUMBER := gc_log_all;                                                                                                                                                                             -- Log level for the whole session
   --
   g_n_log_message_max     NUMBER := 5000;                                                                                                                                                                        -- maximum number of messages for one session
   g_n_log_console_max     NUMBER := 40000;                                                                                                                                                                        -- maximum Buffer-Size for dbms_out messages
   --
   g_vc_db_name_actual     VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'DB_NAME'
                                 );
   g_vc_audsid             VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'SESSIONID'
                                 );
   g_vc_session_user       VARCHAR2 (100) := USER;
   g_vc_os_user            VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'OS_USER'
                                 );
   g_vc_terminal           VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'TERMINAL'
                                 );
END p#frm#trac_param;
2014-11-28 13:53:17.018 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_trac_param
   AUTHID CURRENT_USER
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   --
   gc_log_off     CONSTANT NUMBER := 0;
   gc_log_fatal   CONSTANT NUMBER := 1;
   gc_log_error   CONSTANT NUMBER := 2;
   gc_log_warn    CONSTANT NUMBER := 3;
   gc_log_info    CONSTANT NUMBER := 4;
   gc_log_debug   CONSTANT NUMBER := 5;
   gc_log_trace   CONSTANT NUMBER := 6;
   gc_log_all     CONSTANT NUMBER := 6;
   --
   g_b_log_console         BOOLEAN := FALSE;                                                                                                                                                                             -- If TRUE, log is sent to dbms_output
   g_b_log_table           BOOLEAN := TRUE;                                                                                                                                                                         -- If TRUE, log is written in the log table
   g_n_log_level           NUMBER := gc_log_all;                                                                                                                                                                             -- Log level for the whole session
   --
   g_n_log_message_max     NUMBER := 5000;                                                                                                                                                                        -- maximum number of messages for one session
   g_n_log_console_max     NUMBER := 40000;                                                                                                                                                                        -- maximum Buffer-Size for dbms_out messages
   --
   g_vc_db_name_actual     VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'DB_NAME'
                                 );
   g_vc_audsid             VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'SESSIONID'
                                 );
   g_vc_session_user       VARCHAR2 (100) := USER;
   g_vc_os_user            VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'OS_USER'
                                 );
   g_vc_terminal           VARCHAR2 (100)
                              := SYS_CONTEXT (
                                    'USERENV'
                                  , 'TERMINAL'
                                 );
END dwhutl_trac_param;
2014-11-28 13:53:17.036 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/trac_param/trac_param-def.sql executed
2014-11-28 13:53:17.037 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/trac/trac-def.sql delimiter 
2014-11-28 13:53:17.038 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#trac
AS
   /**
   * APIs for Logging and Tracing in the table log_t on through DBMS_OUTPUT.
   *
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package Spec Version String.
   */
   c_spec_version   CONSTANT VARCHAR2 (400) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package Body Version String.
   */
   c_body_version            VARCHAR2 (400);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);
   /**
   * Global log constants
   * This constants are used to measure the size of the generated logs
   */
   g_n_message_count         NUMBER;                                                                                                                                                                                    -- counter for messages of this session
   g_b_message_max_reached   BOOLEAN;                                                                                                                                                                    -- has the max number of messages already been reached
   --
   g_n_console_size          NUMBER;                                                                                                                                                                                            -- current Buffer-Size in Bytes
   g_b_console_max_reached   BOOLEAN;                                                                                                                                                                                   -- has the dbms_out limit been reached?

   /**
   * Log a message to DBMS_OUTPUT and/or in the table log_t
   *
   * @param          p_n_months    months to preserve
   */
   PROCEDURE purge (p_n_months IN NUMBER DEFAULT 12);

   /**
   * Log a message to DBMS_OUTPUT and/or in the table log_t
   *
   * @param          p_n_severity           severity (from fatal to debug)
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE LOG (
      p_n_severity          IN NUMBER DEFAULT p#frm#trac_param.gc_log_info
    , p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
    , p_vc_call_stack       IN VARCHAR2 DEFAULT NULL
   );

   /**
   * Simplified log procedures
   */
   /**
   * Log a fatal entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_fatal (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a error entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_error (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a warning entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_warn (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a informational entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          Count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_info (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a debug entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_debug (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a trace entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_trace (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Simplified log procedures for non-standalone PL/SQL subprograms (procedures and functions)
   */
   /**
   * Log a fatal entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_fatal (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a error entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_error (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a warning entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_warn (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a informational entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_info (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a debug entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_debug (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a trace entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_trace (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );
END p#frm#trac;
2014-11-28 13:53:17.039 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_trac
AS
   /**
   * APIs for Logging and Tracing in the table log_t on through DBMS_OUTPUT.
   *
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package Spec Version String.
   */
   c_spec_version   CONSTANT VARCHAR2 (400) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package Body Version String.
   */
   c_body_version            VARCHAR2 (400);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);
   /**
   * Global log constants
   * This constants are used to measure the size of the generated logs
   */
   g_n_message_count         NUMBER;                                                                                                                                                                                    -- counter for messages of this session
   g_b_message_max_reached   BOOLEAN;                                                                                                                                                                    -- has the max number of messages already been reached
   --
   g_n_console_size          NUMBER;                                                                                                                                                                                            -- current Buffer-Size in Bytes
   g_b_console_max_reached   BOOLEAN;                                                                                                                                                                                   -- has the dbms_out limit been reached?

   /**
   * Log a message to DBMS_OUTPUT and/or in the table log_t
   *
   * @param          p_n_months    months to preserve
   */
   PROCEDURE purge (p_n_months IN NUMBER DEFAULT 12);

   /**
   * Log a message to DBMS_OUTPUT and/or in the table log_t
   *
   * @param          p_n_severity           severity (from fatal to debug)
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE LOG (
      p_n_severity          IN NUMBER DEFAULT dwhutl_trac_param.gc_log_info
    , p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
    , p_vc_call_stack       IN VARCHAR2 DEFAULT NULL
   );

   /**
   * Simplified log procedures
   */
   /**
   * Log a fatal entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_fatal (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a error entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_error (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a warning entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_warn (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a informational entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          Count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_info (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a debug entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_debug (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a trace entry
   *
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_trace (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Simplified log procedures for non-standalone PL/SQL subprograms (procedures and functions)
   */
   /**
   * Log a fatal entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_fatal (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a error entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_error (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a warning entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_warn (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a informational entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_info (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a debug entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_debug (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );

   /**
   * Log a trace entry
   *
   * @param          p_vc_subprogram        subprogram (procedure name)
   * @param          p_vc_message_short     short message text
   * @param          p_vc_message_long      long message text
   * @param          p_vc_text_big          big text
   * @param          p_n_row_count          count of worked rows
   * @param          p_n_external_job_id    CLOB text (for storing big generated texts or object-ddls)
   */
   PROCEDURE log_sub_trace (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   );
END dwhutl_trac;
2014-11-28 13:53:17.063 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/trac/trac-def.sql executed
2014-11-28 13:53:17.064 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/trac/trac-impl.sql delimiter 
2014-11-28 13:53:17.065 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#trac
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   PROCEDURE purge (p_n_months IN NUMBER DEFAULT 12)
   IS
   BEGIN
      DELETE p#frm#trac_t
       WHERE create_date < ADD_MONTHS (
                              TRUNC (SYSDATE)
                            , -p_n_months
                           );

      COMMIT;
   END;

   PROCEDURE log_console (p_vc_text IN VARCHAR2)
   IS
   BEGIN
      IF g_b_message_max_reached THEN
         RETURN;
      END IF;

      g_n_console_size :=
           g_n_console_size
         + LENGTH (SUBSTR (
                      p_vc_text
                    , 1
                    , 255
                   ));

      IF g_n_console_size >= p#frm#trac_param.g_n_log_console_max * 0.88 THEN
         -- abzgl. ca. 8% wegen Overhead..
         DBMS_OUTPUT.put_line ('--!!Output buffer almost full!!--');
         DBMS_OUTPUT.put_line ('--!!No further output in this session!!--');
         DBMS_OUTPUT.put_line ('--!!Output truncated!!--');
         g_b_console_max_reached := TRUE;
      ELSE
         DBMS_OUTPUT.put_line (SUBSTR (
                                  p_vc_text
                                , 1
                                , 2000
                               ));
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         -- Never Ever Stop working Masterproc
         NULL;
   END;

   PROCEDURE LOG (
      p_n_severity          IN NUMBER DEFAULT p#frm#trac_param.gc_log_info
    , p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
    , p_vc_call_stack       IN VARCHAR2 DEFAULT NULL
   )
   IS
      l_call_stack        VARCHAR2 (2000);
      l_call_stack_line   VARCHAR2 (2000);
      l_tmp_str           VARCHAR2 (2000);
      l_line_nr           NUMBER;
      l_sqlcode           NUMBER;
      l_sqlerrm           VARCHAR2 (1000);
      l_object_name       VARCHAR2 (200);
      l_message_long      VARCHAR2 (4000);
      l_message_short     VARCHAR2 (500);
      l_trac_id           NUMBER;
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      IF g_b_message_max_reached THEN
         RETURN;
      END IF;

      -- Log Only Messages smaller or equal logLevel
      IF p_n_severity <= p#frm#trac_param.g_n_log_level THEN
         -- counter increment
         g_n_message_count :=
              g_n_message_count
            + 1;
         l_call_stack := NVL (p_vc_call_stack, DBMS_UTILITY.format_call_stack);
         l_call_stack_line :=
            SUBSTR (
               l_call_stack
             ,   INSTR (
                    l_call_stack
                  , CHR (10)
                  , 1
                  , 4
                 )
               + 1
             ,   INSTR (
                    l_call_stack
                  , CHR (10)
                  , 1
                  , 5
                 )
               - INSTR (
                    l_call_stack
                  , CHR (10)
                  , 1
                  , 4
                 )
            );
         l_tmp_str :=
            TRIM (SUBSTR (
                     l_call_stack_line
                   , INSTR (
                        l_call_stack_line
                      , ' '
                     )
                  ));
         l_line_nr :=
            TO_NUMBER (SUBSTR (
                          l_tmp_str
                        , 1
                        ,   INSTR (
                               l_tmp_str
                             , ' '
                            )
                          - 1
                       ));
         l_object_name :=
            TRIM (TRANSLATE (
                     SUBSTR (
                        l_tmp_str
                      , INSTR (
                           l_tmp_str
                         , ' '
                        )
                     )
                   , CHR (10)
                   , ' '
                  ));

         IF g_n_message_count = p#frm#trac_param.g_n_log_message_max THEN
            l_message_long :=
                  'Maximum number of messages '
               || TO_CHAR (g_n_message_count)
               || ' for this session reached. No further logging in this session.';
            l_message_short := l_message_long;
            g_b_message_max_reached := TRUE;
         ELSE
            l_message_long :=
               SUBSTR (
                  p_vc_message_long
                , 1
                , 4000
               );
            l_message_short :=
               SUBSTR (
                  p_vc_message_short
                , 1
                , 500
               );
         END IF;

         l_sqlcode := SQLCODE;
         l_sqlerrm :=
            CASE
               WHEN l_sqlcode <> 0 THEN
                  SQLERRM
            END;

         IF p#frm#trac_param.g_b_log_console THEN
            log_console (   'SEVERITY: '
                         || p_n_severity
                         || '  DATE: '
                         || TO_CHAR (
                               SYSDATE
                             , 'yyyy-mm-dd hh24:mi:ss'
                            ));
            log_console (   'MESSAGE SHORT: '
                         || p_vc_message_short);
            log_console (   'MESSAGE LONG: '
                         || p_vc_message_long);
            log_console (   'OBJECT: '
                         || l_object_name
                         || ' SUBPROGRAM: '
                         || p_vc_subprogram
                         || ' LINE: '
                         || l_line_nr);
            log_console (   'AUDSID: '
                         || p#frm#trac_param.g_vc_audsid
                         || ' SESSION_USER: '
                         || p#frm#trac_param.g_vc_session_user
                         || ' OS_USER: '
                         || p#frm#trac_param.g_vc_os_user
                         || ' TERMINAL: '
                         || p#frm#trac_param.g_vc_terminal);
            log_console (   'SQLCODE: '
                         || l_sqlcode
                         || ' SQLERRM: '
                         || l_sqlerrm);
         END IF;

         IF p#frm#trac_param.g_b_log_table THEN
            INSERT INTO p#frm#trac_t (
                           trac_severity
                         , trac_message_short
                         , trac_message_long
                         , trac_object_name
                         , trac_subprogram_name
                         , trac_line_number
                         , trac_audsid
                         , trac_terminal
                         , trac_sqlcode
                         , trac_sqlerrm
                         , trac_call_stack
                         , trac_rowcount
                         , trac_external_job_id
                         , trac_text
                        )
                 VALUES (
                           p_n_severity
                         , l_message_short
                         , l_message_long
                         , l_object_name
                         , p_vc_subprogram
                         , l_line_nr
                         , p#frm#trac_param.g_vc_audsid
                         , p#frm#trac_param.g_vc_terminal
                         , l_sqlcode
                         , l_sqlerrm
                         , CASE
                              WHEN p_n_severity < p#frm#trac_param.gc_log_warn THEN
                                 l_call_stack
                           END
                         , p_n_row_count
                         , p_n_external_job_id
                         , p_vc_text_big
                        )
              RETURNING trac_id
                   INTO l_trac_id;

            COMMIT;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         -- Rollback autonomous transaction
         -- but do not stop working master proc
         ROLLBACK;
   END LOG;

   /**
   * Simplified log procedures
   */
   PROCEDURE log_fatal (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_fatal
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_error (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_error
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_warn (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_warn
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_info (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_info
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_debug (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_debug
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_trace (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_trace
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   /**
   * Simplified log procedures for non-standalone PL/SQL subprograms (procedures and functions)
   */
   PROCEDURE log_sub_fatal (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_fatal
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_error (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_error
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_warn (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_warn
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_info (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_info
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_debug (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_debug
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_trace (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         p#frm#trac_param.gc_log_trace
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;
/**
  * Package initialization
  */
BEGIN
   -- set package variables
   g_n_message_count := 0;                                                                                                                                                                                                        -- Initialize Message Counter
   g_b_message_max_reached := FALSE;
   --
   g_n_console_size := 0;
   g_b_console_max_reached := FALSE;

   IF p#frm#trac_param.g_b_log_console THEN
      DBMS_OUTPUT.enable (p#frm#trac_param.g_n_log_console_max);
   END IF;

   --
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
EXCEPTION
   WHEN OTHERS THEN
      -- Never ever stop working master procedure
      NULL;
END p#frm#trac;
2014-11-28 13:53:17.067 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_trac
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   PROCEDURE purge (p_n_months IN NUMBER DEFAULT 12)
   IS
   BEGIN
      DELETE dwhutl_trac_t
       WHERE create_date < ADD_MONTHS (
                              TRUNC (SYSDATE)
                            , -p_n_months
                           );

      COMMIT;
   END;

   PROCEDURE log_console (p_vc_text IN VARCHAR2)
   IS
   BEGIN
      IF g_b_message_max_reached THEN
         RETURN;
      END IF;

      g_n_console_size :=
           g_n_console_size
         + LENGTH (SUBSTR (
                      p_vc_text
                    , 1
                    , 255
                   ));

      IF g_n_console_size >= dwhutl_trac_param.g_n_log_console_max * 0.88 THEN
         -- abzgl. ca. 8% wegen Overhead..
         DBMS_OUTPUT.put_line ('--!!Output buffer almost full!!--');
         DBMS_OUTPUT.put_line ('--!!No further output in this session!!--');
         DBMS_OUTPUT.put_line ('--!!Output truncated!!--');
         g_b_console_max_reached := TRUE;
      ELSE
         DBMS_OUTPUT.put_line (SUBSTR (
                                  p_vc_text
                                , 1
                                , 2000
                               ));
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         -- Never Ever Stop working Masterproc
         NULL;
   END;

   PROCEDURE LOG (
      p_n_severity          IN NUMBER DEFAULT dwhutl_trac_param.gc_log_info
    , p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
    , p_vc_call_stack       IN VARCHAR2 DEFAULT NULL
   )
   IS
      l_call_stack        VARCHAR2 (2000);
      l_call_stack_line   VARCHAR2 (2000);
      l_tmp_str           VARCHAR2 (2000);
      l_line_nr           NUMBER;
      l_sqlcode           NUMBER;
      l_sqlerrm           VARCHAR2 (1000);
      l_object_name       VARCHAR2 (200);
      l_message_long      VARCHAR2 (4000);
      l_message_short     VARCHAR2 (500);
      l_trac_id           NUMBER;
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      IF g_b_message_max_reached THEN
         RETURN;
      END IF;

      -- Log Only Messages smaller or equal logLevel
      IF p_n_severity <= dwhutl_trac_param.g_n_log_level THEN
         -- counter increment
         g_n_message_count :=
              g_n_message_count
            + 1;
         l_call_stack := NVL (p_vc_call_stack, DBMS_UTILITY.format_call_stack);
         l_call_stack_line :=
            SUBSTR (
               l_call_stack
             ,   INSTR (
                    l_call_stack
                  , CHR (10)
                  , 1
                  , 4
                 )
               + 1
             ,   INSTR (
                    l_call_stack
                  , CHR (10)
                  , 1
                  , 5
                 )
               - INSTR (
                    l_call_stack
                  , CHR (10)
                  , 1
                  , 4
                 )
            );
         l_tmp_str :=
            TRIM (SUBSTR (
                     l_call_stack_line
                   , INSTR (
                        l_call_stack_line
                      , ' '
                     )
                  ));
         l_line_nr :=
            TO_NUMBER (SUBSTR (
                          l_tmp_str
                        , 1
                        ,   INSTR (
                               l_tmp_str
                             , ' '
                            )
                          - 1
                       ));
         l_object_name :=
            TRIM (TRANSLATE (
                     SUBSTR (
                        l_tmp_str
                      , INSTR (
                           l_tmp_str
                         , ' '
                        )
                     )
                   , CHR (10)
                   , ' '
                  ));

         IF g_n_message_count = dwhutl_trac_param.g_n_log_message_max THEN
            l_message_long :=
                  'Maximum number of messages '
               || TO_CHAR (g_n_message_count)
               || ' for this session reached. No further logging in this session.';
            l_message_short := l_message_long;
            g_b_message_max_reached := TRUE;
         ELSE
            l_message_long :=
               SUBSTR (
                  p_vc_message_long
                , 1
                , 4000
               );
            l_message_short :=
               SUBSTR (
                  p_vc_message_short
                , 1
                , 500
               );
         END IF;

         l_sqlcode := SQLCODE;
         l_sqlerrm :=
            CASE
               WHEN l_sqlcode <> 0 THEN
                  SQLERRM
            END;

         IF dwhutl_trac_param.g_b_log_console THEN
            log_console (   'SEVERITY: '
                         || p_n_severity
                         || '  DATE: '
                         || TO_CHAR (
                               SYSDATE
                             , 'yyyy-mm-dd hh24:mi:ss'
                            ));
            log_console (   'MESSAGE SHORT: '
                         || p_vc_message_short);
            log_console (   'MESSAGE LONG: '
                         || p_vc_message_long);
            log_console (   'OBJECT: '
                         || l_object_name
                         || ' SUBPROGRAM: '
                         || p_vc_subprogram
                         || ' LINE: '
                         || l_line_nr);
            log_console (   'AUDSID: '
                         || dwhutl_trac_param.g_vc_audsid
                         || ' SESSION_USER: '
                         || dwhutl_trac_param.g_vc_session_user
                         || ' OS_USER: '
                         || dwhutl_trac_param.g_vc_os_user
                         || ' TERMINAL: '
                         || dwhutl_trac_param.g_vc_terminal);
            log_console (   'SQLCODE: '
                         || l_sqlcode
                         || ' SQLERRM: '
                         || l_sqlerrm);
         END IF;

         IF dwhutl_trac_param.g_b_log_table THEN
            INSERT INTO dwhutl_trac_t (
                           trac_severity
                         , trac_message_short
                         , trac_message_long
                         , trac_object_name
                         , trac_subprogram_name
                         , trac_line_number
                         , trac_audsid
                         , trac_terminal
                         , trac_sqlcode
                         , trac_sqlerrm
                         , trac_call_stack
                         , trac_rowcount
                         , trac_external_job_id
                         , trac_text
                        )
                 VALUES (
                           p_n_severity
                         , l_message_short
                         , l_message_long
                         , l_object_name
                         , p_vc_subprogram
                         , l_line_nr
                         , dwhutl_trac_param.g_vc_audsid
                         , dwhutl_trac_param.g_vc_terminal
                         , l_sqlcode
                         , l_sqlerrm
                         , CASE
                              WHEN p_n_severity < dwhutl_trac_param.gc_log_warn THEN
                                 l_call_stack
                           END
                         , p_n_row_count
                         , p_n_external_job_id
                         , p_vc_text_big
                        )
              RETURNING trac_id
                   INTO l_trac_id;

            COMMIT;
         END IF;
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         -- Rollback autonomous transaction
         -- but do not stop working master proc
         ROLLBACK;
   END LOG;

   /**
   * Simplified log procedures
   */
   PROCEDURE log_fatal (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_fatal
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_error (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_error
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_warn (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_warn
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_info (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_info
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_debug (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_debug
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_trace (
      p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_trace
       , NULL
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   /**
   * Simplified log procedures for non-standalone PL/SQL subprograms (procedures and functions)
   */
   PROCEDURE log_sub_fatal (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_fatal
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_error (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_error
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_warn (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_warn
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_info (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_info
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_debug (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_debug
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;

   PROCEDURE log_sub_trace (
      p_vc_subprogram       IN VARCHAR2 DEFAULT NULL
    , p_vc_message_short    IN VARCHAR2 DEFAULT NULL
    , p_vc_message_long     IN VARCHAR2 DEFAULT NULL
    , p_vc_text_big         IN CLOB DEFAULT NULL
    , p_n_row_count         IN NUMBER DEFAULT NULL
    , p_n_external_job_id   IN NUMBER DEFAULT NULL
   )
   IS
   BEGIN
      LOG (
         dwhutl_trac_param.gc_log_trace
       , p_vc_subprogram
       , p_vc_message_short
       , p_vc_message_long
       , p_vc_text_big
       , p_n_row_count
       , p_n_external_job_id
       , DBMS_UTILITY.format_call_stack
      );
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END;
/**
  * Package initialization
  */
BEGIN
   -- set package variables
   g_n_message_count := 0;                                                                                                                                                                                                        -- Initialize Message Counter
   g_b_message_max_reached := FALSE;
   --
   g_n_console_size := 0;
   g_b_console_max_reached := FALSE;

   IF dwhutl_trac_param.g_b_log_console THEN
      DBMS_OUTPUT.enable (dwhutl_trac_param.g_n_log_console_max);
   END IF;

   --
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
EXCEPTION
   WHEN OTHERS THEN
      -- Never ever stop working master procedure
      NULL;
END dwhutl_trac;
2014-11-28 13:53:17.336 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/trac/trac-impl.sql executed
2014-11-28 13:53:17.337 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Module all installed
2014-11-28 13:53:17.337 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Found module "taxn"
2014-11-28 13:53:17.337 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Installing all module
2014-11-28 13:53:17.337 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/user_t.sql delimiter 
2014-11-28 13:53:17.339 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'user'
    , 'user_code VARCHAR2 (10),
       user_name VARCHAR2 (100),
       user_email VARCHAR2 (1000)'
    , 'DROP'
    , TRUE
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:17.339 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'user'
    , 'user_code VARCHAR2 (10),
       user_name VARCHAR2 (100),
       user_email VARCHAR2 (1000)'
    , 'DROP'
    , TRUE
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:18.303 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/user_t.sql executed
2014-11-28 13:53:18.304 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/user_uk.sql delimiter ;
2014-11-28 13:53:18.305 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#user_t ADD (CONSTRAINT p#frm#user_uk UNIQUE (user_code));
2014-11-28 13:53:18.306 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_user_t ADD (CONSTRAINT dwhutl_user_uk UNIQUE (user_code));
2014-11-28 13:53:18.335 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/user_uk.sql executed
2014-11-28 13:53:18.336 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_t.sql delimiter 
2014-11-28 13:53:18.336 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'taxn'
    , 'taxn_parent_id NUMBER,
	   taxn_order NUMBER,
       taxn_code VARCHAR2 (100),
       taxn_name VARCHAR2 (4000)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:18.337 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'taxn'
    , 'taxn_parent_id NUMBER,
	   taxn_order NUMBER,
       taxn_code VARCHAR2 (100),
       taxn_name VARCHAR2 (4000)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:18.696 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_t.sql executed
2014-11-28 13:53:18.697 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_uk.sql delimiter ;
2014-11-28 13:53:18.697 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#taxn_t ADD (CONSTRAINT p#frm#taxn_uk UNIQUE (taxn_code));
2014-11-28 13:53:18.697 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_taxn_t ADD (CONSTRAINT dwhutl_taxn_uk UNIQUE (taxn_code));
2014-11-28 13:53:18.725 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_uk.sql executed
2014-11-28 13:53:18.726 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_data.sql delimiter ;
2014-11-28 13:53:18.727 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
MERGE INTO p#frm#taxn_t trg
     USING (SELECT 'GLOBAL' AS taxn_code FROM DUAL) src
        ON (trg.taxn_code = src.taxn_code)
WHEN NOT MATCHED THEN
   INSERT     (
                 taxn_id
               , taxn_code
               , taxn_name
              )
       VALUES (
                 -1
               , 'GLOBAL'
               , 'Global'
              );
COMMIT;
2014-11-28 13:53:18.727 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
MERGE INTO dwhutl_taxn_t trg
     USING (SELECT 'GLOBAL' AS taxn_code FROM DUAL) src
        ON (trg.taxn_code = src.taxn_code)
WHEN NOT MATCHED THEN
   INSERT     (
                 taxn_id
               , taxn_code
               , taxn_name
              )
       VALUES (
                 -1
               , 'GLOBAL'
               , 'Global'
              );
COMMIT;
2014-11-28 13:53:18.750 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_data.sql executed
2014-11-28 13:53:18.750 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_user_t.sql delimiter 
2014-11-28 13:53:18.751 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'taxn_user'
    , 'user_id NUMBER NOT NULL,
       taxn_id NUMBER NOT NULL'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:18.751 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'taxn_user'
    , 'user_id NUMBER NOT NULL,
       taxn_id NUMBER NOT NULL'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:18.988 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_user_t.sql executed
2014-11-28 13:53:18.988 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_user_uk.sql delimiter ;
2014-11-28 13:53:18.990 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#taxn_user_t ADD (CONSTRAINT p#frm#taxn_user_uk UNIQUE (user_id,taxn_id));
2014-11-28 13:53:18.991 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_taxn_user_t ADD (CONSTRAINT dwhutl_taxn_user_uk UNIQUE (user_id,taxn_id));
2014-11-28 13:53:19.022 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/taxn_user_uk.sql executed
2014-11-28 13:53:19.022 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/taxn_v.sql delimiter ;
2014-11-28 13:53:19.022 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#taxn_v
AS
       SELECT LEVEL AS taxn_level
            , taxn_id
            , taxn_code
            , taxn_name
            , SYS_CONNECT_BY_PATH (
                 taxn_code
               , '/'
              )
                 taxn_path
         FROM p#frm#taxn_t
   START WITH taxn_parent_id IS NULL
   CONNECT BY PRIOR taxn_id = taxn_parent_id;
2014-11-28 13:53:19.023 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_taxn_v
AS
       SELECT LEVEL AS taxn_level
            , taxn_id
            , taxn_code
            , taxn_name
            , SYS_CONNECT_BY_PATH (
                 taxn_code
               , '/'
              )
                 taxn_path
         FROM dwhutl_taxn_t
   START WITH taxn_parent_id IS NULL
   CONNECT BY PRIOR taxn_id = taxn_parent_id;
2014-11-28 13:53:19.055 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/taxn_v.sql executed
2014-11-28 13:53:19.055 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/taxn_user_v.sql delimiter ;
2014-11-28 13:53:19.055 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#taxn_user_v
AS
   SELECT ut.taxn_user_id
        , ut.user_id
        , ut.taxn_id
        , us.user_code
        , us.user_email
        , ta.taxn_code
     FROM p#frm#taxn_user_t ut
        , p#frm#user_t us
        , p#frm#taxn_t ta
    WHERE ut.user_id = us.user_id
      AND ut.taxn_id = ta.taxn_id;
2014-11-28 13:53:19.056 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_taxn_user_v
AS
   SELECT ut.taxn_user_id
        , ut.user_id
        , ut.taxn_id
        , us.user_code
        , us.user_email
        , ta.taxn_code
     FROM dwhutl_taxn_user_t ut
        , dwhutl_user_t us
        , dwhutl_taxn_t ta
    WHERE ut.user_id = us.user_id
      AND ut.taxn_id = ta.taxn_id;
2014-11-28 13:53:19.095 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/taxn_user_v.sql executed
2014-11-28 13:53:19.095 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/taxn/taxn-def.sql delimiter 
2014-11-28 13:53:19.096 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#taxn
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   FUNCTION fct_get_taxonomy_emails (
      p_vc_taxonomy_code   IN VARCHAR2
    , p_vc_separator       IN VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2;

   PROCEDURE prc_taxonomy_ins (
      p_vc_taxonomy_code          IN VARCHAR2
    , p_vc_taxonomy_name          IN VARCHAR2
    , p_vc_taxonomy_parent_code   IN VARCHAR2
   );

   PROCEDURE prc_user_ins (
      p_vc_user_code    IN VARCHAR2
    , p_vc_user_name    IN VARCHAR2
    , p_vc_user_email   IN VARCHAR2
   );

   PROCEDURE prc_user_taxonomy_ins (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );

   PROCEDURE prc_user_taxonomy_del (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );
END p#frm#taxn;
2014-11-28 13:53:19.096 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_taxn
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   FUNCTION fct_get_taxonomy_emails (
      p_vc_taxonomy_code   IN VARCHAR2
    , p_vc_separator       IN VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2;

   PROCEDURE prc_taxonomy_ins (
      p_vc_taxonomy_code          IN VARCHAR2
    , p_vc_taxonomy_name          IN VARCHAR2
    , p_vc_taxonomy_parent_code   IN VARCHAR2
   );

   PROCEDURE prc_user_ins (
      p_vc_user_code    IN VARCHAR2
    , p_vc_user_name    IN VARCHAR2
    , p_vc_user_email   IN VARCHAR2
   );

   PROCEDURE prc_user_taxonomy_ins (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );

   PROCEDURE prc_user_taxonomy_del (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );
END dwhutl_taxn;
2014-11-28 13:53:19.121 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/taxn/taxn-def.sql executed
2014-11-28 13:53:19.121 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/taxn/taxn-impl.sql delimiter 
2014-11-28 13:53:19.122 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#taxn
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   FUNCTION fct_get_taxonomy_emails (
      p_vc_taxonomy_code   IN VARCHAR2
    , p_vc_separator       IN VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2
   IS
      l_vc_emails   VARCHAR2 (32767);
   BEGIN
      FOR r_email IN (SELECT us.user_email
                        FROM p#frm#taxn_user_t ut
                           , p#frm#user_t us
                           , p#frm#taxn_t ta
                       WHERE ut.user_id = us.user_id
                         AND ut.taxn_id = ta.taxn_id
                         AND ta.taxn_code = p_vc_taxonomy_code) LOOP
         l_vc_emails :=
               l_vc_emails
            || r_email.user_email
            || p_vc_separator;
      END LOOP;

      RETURN RTRIM (
                l_vc_emails
              , p_vc_separator
             );
   END;

   PROCEDURE prc_taxonomy_ins (
      p_vc_taxonomy_code          IN VARCHAR2
    , p_vc_taxonomy_name          IN VARCHAR2
    , p_vc_taxonomy_parent_code   IN VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO p#frm#taxn_t trg
           USING (SELECT p_vc_taxonomy_code AS taxonomy_code
                       , p_vc_taxonomy_name AS taxonomy_name
                       , taxn_id AS taxonomy_parent_id
                    FROM p#frm#taxn_t
                   WHERE taxn_code = p_vc_taxonomy_parent_code) src
              ON (trg.taxn_code = src.taxonomy_code)
      WHEN MATCHED THEN
         UPDATE SET trg.taxn_name = src.taxonomy_name
                  , trg.taxn_parent_id = NVL (src.taxonomy_parent_id, trg.taxn_parent_id)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.taxn_code
                     , trg.taxn_name
                     , trg.taxn_parent_id
                    )
             VALUES (
                       src.taxonomy_code
                     , src.taxonomy_name
                     , src.taxonomy_parent_id
                    );

      COMMIT;
   END;

   PROCEDURE prc_user_ins (
      p_vc_user_code    IN VARCHAR2
    , p_vc_user_name    IN VARCHAR2
    , p_vc_user_email   IN VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO p#frm#user_t trg
           USING (SELECT p_vc_user_code AS user_code
                       , p_vc_user_name AS user_name
                       , p_vc_user_email AS user_email
                    FROM DUAL) src
              ON (trg.user_code = src.user_code)
      WHEN MATCHED THEN
         UPDATE SET trg.user_name = NVL (src.user_name, trg.user_name)
                  , trg.user_email = NVL (src.user_email, trg.user_email)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.user_code
                     , trg.user_name
                     , trg.user_email
                    )
             VALUES (
                       src.user_code
                     , src.user_name
                     , src.user_email
                    );

      COMMIT;
   END;

   PROCEDURE prc_user_taxonomy_ins (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_USER_TAXONOMY_INS';
   BEGIN
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Inserting in sys_user_taxonomy_t'
      );

      MERGE INTO p#frm#taxn_user_t trg
           USING (SELECT user_id
                       , taxn_id
                    FROM p#frm#user_t c
                       , p#frm#taxn_t t
                   WHERE c.user_code = p_vc_user_code
                     AND t.taxn_code = p_vc_taxonomy_code) src
              ON (trg.user_id = src.user_id
              AND trg.taxn_id = src.taxn_id)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.user_id
                     , trg.taxn_id
                    )
             VALUES (
                       src.user_id
                     , src.taxn_id
                    );

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows merged'
      );
      COMMIT;
   END prc_user_taxonomy_ins;

   PROCEDURE prc_user_taxonomy_del (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_USER_TAXONOMY_DEL';
   BEGIN
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Deleting in sys_user_taxonomy_t'
      );

      DELETE p#frm#taxn_user_t
       WHERE user_id = (SELECT user_id
                          FROM p#frm#user_t
                         WHERE user_code = p_vc_user_code)
         AND taxn_id = (SELECT taxn_id
                          FROM p#frm#taxn_t
                         WHERE taxn_code = p_vc_taxonomy_code);

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows deleted'
      );
      COMMIT;
   END prc_user_taxonomy_del;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#taxn;
2014-11-28 13:53:19.123 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_taxn
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   FUNCTION fct_get_taxonomy_emails (
      p_vc_taxonomy_code   IN VARCHAR2
    , p_vc_separator       IN VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2
   IS
      l_vc_emails   VARCHAR2 (32767);
   BEGIN
      FOR r_email IN (SELECT us.user_email
                        FROM dwhutl_taxn_user_t ut
                           , dwhutl_user_t us
                           , dwhutl_taxn_t ta
                       WHERE ut.user_id = us.user_id
                         AND ut.taxn_id = ta.taxn_id
                         AND ta.taxn_code = p_vc_taxonomy_code) LOOP
         l_vc_emails :=
               l_vc_emails
            || r_email.user_email
            || p_vc_separator;
      END LOOP;

      RETURN RTRIM (
                l_vc_emails
              , p_vc_separator
             );
   END;

   PROCEDURE prc_taxonomy_ins (
      p_vc_taxonomy_code          IN VARCHAR2
    , p_vc_taxonomy_name          IN VARCHAR2
    , p_vc_taxonomy_parent_code   IN VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO dwhutl_taxn_t trg
           USING (SELECT p_vc_taxonomy_code AS taxonomy_code
                       , p_vc_taxonomy_name AS taxonomy_name
                       , taxn_id AS taxonomy_parent_id
                    FROM dwhutl_taxn_t
                   WHERE taxn_code = p_vc_taxonomy_parent_code) src
              ON (trg.taxn_code = src.taxonomy_code)
      WHEN MATCHED THEN
         UPDATE SET trg.taxn_name = src.taxonomy_name
                  , trg.taxn_parent_id = NVL (src.taxonomy_parent_id, trg.taxn_parent_id)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.taxn_code
                     , trg.taxn_name
                     , trg.taxn_parent_id
                    )
             VALUES (
                       src.taxonomy_code
                     , src.taxonomy_name
                     , src.taxonomy_parent_id
                    );

      COMMIT;
   END;

   PROCEDURE prc_user_ins (
      p_vc_user_code    IN VARCHAR2
    , p_vc_user_name    IN VARCHAR2
    , p_vc_user_email   IN VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO dwhutl_user_t trg
           USING (SELECT p_vc_user_code AS user_code
                       , p_vc_user_name AS user_name
                       , p_vc_user_email AS user_email
                    FROM DUAL) src
              ON (trg.user_code = src.user_code)
      WHEN MATCHED THEN
         UPDATE SET trg.user_name = NVL (src.user_name, trg.user_name)
                  , trg.user_email = NVL (src.user_email, trg.user_email)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.user_code
                     , trg.user_name
                     , trg.user_email
                    )
             VALUES (
                       src.user_code
                     , src.user_name
                     , src.user_email
                    );

      COMMIT;
   END;

   PROCEDURE prc_user_taxonomy_ins (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_USER_TAXONOMY_INS';
   BEGIN
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Inserting in sys_user_taxonomy_t'
      );

      MERGE INTO dwhutl_taxn_user_t trg
           USING (SELECT user_id
                       , taxn_id
                    FROM dwhutl_user_t c
                       , dwhutl_taxn_t t
                   WHERE c.user_code = p_vc_user_code
                     AND t.taxn_code = p_vc_taxonomy_code) src
              ON (trg.user_id = src.user_id
              AND trg.taxn_id = src.taxn_id)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.user_id
                     , trg.taxn_id
                    )
             VALUES (
                       src.user_id
                     , src.taxn_id
                    );

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows merged'
      );
      COMMIT;
   END prc_user_taxonomy_ins;

   PROCEDURE prc_user_taxonomy_del (
      p_vc_user_code       IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_USER_TAXONOMY_DEL';
   BEGIN
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Deleting in sys_user_taxonomy_t'
      );

      DELETE dwhutl_taxn_user_t
       WHERE user_id = (SELECT user_id
                          FROM dwhutl_user_t
                         WHERE user_code = p_vc_user_code)
         AND taxn_id = (SELECT taxn_id
                          FROM dwhutl_taxn_t
                         WHERE taxn_code = p_vc_taxonomy_code);

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows deleted'
      );
      COMMIT;
   END prc_user_taxonomy_del;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_taxn;
2014-11-28 13:53:19.206 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/taxn/taxn-impl.sql executed
2014-11-28 13:53:19.206 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Module all installed
2014-11-28 13:53:19.206 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Found module "mesr"
2014-11-28 13:53:19.206 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Installing all module
2014-11-28 13:53:19.206 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/docu_t.sql delimiter 
2014-11-28 13:53:19.207 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'docu'
    , 'docu_type VARCHAR2 (100),
       docu_code VARCHAR2 (100),
       docu_url VARCHAR2 (4000),
       docu_desc VARCHAR2 (4000),
       docu_content CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:19.208 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'docu'
    , 'docu_type VARCHAR2 (100),
       docu_code VARCHAR2 (100),
       docu_url VARCHAR2 (4000),
       docu_desc VARCHAR2 (4000),
       docu_content CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:19.424 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/docu_t.sql executed
2014-11-28 13:53:19.424 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_query_t.sql delimiter 
2014-11-28 13:53:19.425 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'mesr_query'
    , 'mesr_query_code VARCHAR2(100) NOT NULL,
	   mesr_query_name VARCHAR2(1000),
	   mesr_query_sql CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:19.426 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'mesr_query'
    , 'mesr_query_code VARCHAR2(100) NOT NULL,
	   mesr_query_name VARCHAR2(1000),
	   mesr_query_sql CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:19.664 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_query_t.sql executed
2014-11-28 13:53:19.664 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_query_uk.sql delimiter ;
2014-11-28 13:53:19.665 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE UNIQUE INDEX p#frm#mesr_query_uk
   ON p#frm#mesr_query_t (mesr_query_code);
2014-11-28 13:53:19.665 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE UNIQUE INDEX dwhutl_mesr_query_uk
   ON dwhutl_mesr_query_t (mesr_query_code);
2014-11-28 13:53:19.691 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_query_uk.sql executed
2014-11-28 13:53:19.691 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_taxn_t.sql delimiter 
2014-11-28 13:53:19.692 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'mesr_taxn'
    , 'mesr_query_id NUMBER NOT NULL,
	   taxn_id NUMBER NOT NULL'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:19.693 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'mesr_taxn'
    , 'mesr_query_id NUMBER NOT NULL,
	   taxn_id NUMBER NOT NULL'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:19.962 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_taxn_t.sql executed
2014-11-28 13:53:19.962 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_taxn_uk.sql delimiter ;
2014-11-28 13:53:19.963 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE UNIQUE INDEX p#frm#mesr_taxn_uk
   ON p#frm#mesr_taxn_t (
      mesr_query_id
    , taxn_id
   );
2014-11-28 13:53:19.963 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE UNIQUE INDEX dwhutl_mesr_taxn_uk
   ON dwhutl_mesr_taxn_t (
      mesr_query_id
    , taxn_id
   );
2014-11-28 13:53:20.029 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_taxn_uk.sql executed
2014-11-28 13:53:20.029 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_keyfigure_t.sql delimiter 
2014-11-28 13:53:20.030 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'mesr_keyfigure'
    , 'mesr_query_id NUMBER,
       mesr_keyfigure_code VARCHAR2(100) NOT NULL,
       mesr_keyfigure_name VARCHAR2(1000)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:20.030 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'mesr_keyfigure'
    , 'mesr_query_id NUMBER,
       mesr_keyfigure_code VARCHAR2(100) NOT NULL,
       mesr_keyfigure_name VARCHAR2(1000)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:20.254 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_keyfigure_t.sql executed
2014-11-28 13:53:20.254 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_keyfigure_uk.sql delimiter ;
2014-11-28 13:53:20.255 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE UNIQUE INDEX p#frm#mesr_keyfigure_uk
   ON p#frm#mesr_keyfigure_t (
      mesr_query_id
    , mesr_keyfigure_code
   );
2014-11-28 13:53:20.255 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE UNIQUE INDEX dwhutl_mesr_keyfigure_uk
   ON dwhutl_mesr_keyfigure_t (
      mesr_query_id
    , mesr_keyfigure_code
   );
2014-11-28 13:53:20.269 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_keyfigure_uk.sql executed
2014-11-28 13:53:20.270 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_threshold_t.sql delimiter 
2014-11-28 13:53:20.271 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'mesr_threshold'
    , 'mesr_keyfigure_id NUMBER,
       mesr_threshold_type CHAR(1) DEFAULT ''A'' CHECK (mesr_threshold_type IN (''A'',''I'')),
       mesr_threshold_from DATE,
       mesr_threshold_to DATE,
       mesr_threshold_min FLOAT,
       mesr_threshold_max FLOAT'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:20.271 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'mesr_threshold'
    , 'mesr_keyfigure_id NUMBER,
       mesr_threshold_type CHAR(1) DEFAULT ''A'' CHECK (mesr_threshold_type IN (''A'',''I'')),
       mesr_threshold_from DATE,
       mesr_threshold_to DATE,
       mesr_threshold_min FLOAT,
       mesr_threshold_max FLOAT'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:20.494 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_threshold_t.sql executed
2014-11-28 13:53:20.494 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_threshold_uk.sql delimiter ;
2014-11-28 13:53:20.496 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE UNIQUE INDEX p#frm#mesr_threshold_uk
   ON p#frm#mesr_threshold_t (
      mesr_keyfigure_id
    , mesr_threshold_from
   );
2014-11-28 13:53:20.496 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE UNIQUE INDEX dwhutl_mesr_threshold_uk
   ON dwhutl_mesr_threshold_t (
      mesr_keyfigure_id
    , mesr_threshold_from
   );
2014-11-28 13:53:20.517 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_threshold_uk.sql executed
2014-11-28 13:53:20.518 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_exec_t.sql delimiter 
2014-11-28 13:53:20.519 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'mesr_exec'
    , 'mesr_keyfigure_id NUMBER,
	   mesr_exec_result_value NUMBER,
	   mesr_exec_result_report CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:20.519 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'mesr_exec'
    , 'mesr_keyfigure_id NUMBER,
	   mesr_exec_result_value NUMBER,
	   mesr_exec_result_report CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:20.723 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/mesr_exec_t.sql executed
2014-11-28 13:53:20.723 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_query_v.sql delimiter ;
2014-11-28 13:53:20.725 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_query_v
AS
   SELECT mesr_query_id
        , mesr_query_code
        , mesr_query_name
        , update_date
     FROM p#frm#mesr_query_t;
2014-11-28 13:53:20.725 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_query_v
AS
   SELECT mesr_query_id
        , mesr_query_code
        , mesr_query_name
        , update_date
     FROM dwhutl_mesr_query_t;
2014-11-28 13:53:20.766 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_query_v.sql executed
2014-11-28 13:53:20.766 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_taxn_v.sql delimiter ;
2014-11-28 13:53:20.767 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_taxn_v
AS
   SELECT mt.mesr_query_id
        , mt.taxn_id
        , qu.mesr_query_code
        , ta.taxn_code
     FROM p#frm#mesr_taxn_t mt
        , p#frm#mesr_query_t qu
        , p#frm#taxn_t ta
    WHERE mt.mesr_query_id = qu.mesr_query_id
      AND mt.taxn_id = ta.taxn_id;
2014-11-28 13:53:20.767 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_taxn_v
AS
   SELECT mt.mesr_query_id
        , mt.taxn_id
        , qu.mesr_query_code
        , ta.taxn_code
     FROM dwhutl_mesr_taxn_t mt
        , dwhutl_mesr_query_t qu
        , dwhutl_taxn_t ta
    WHERE mt.mesr_query_id = qu.mesr_query_id
      AND mt.taxn_id = ta.taxn_id;
2014-11-28 13:53:20.789 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_taxn_v.sql executed
2014-11-28 13:53:20.789 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_keyfigure_v.sql delimiter ;
2014-11-28 13:53:20.790 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_keyfigure_v
AS
   SELECT q.mesr_query_code
        , k.mesr_keyfigure_id
        , k.mesr_keyfigure_code
        , k.mesr_keyfigure_name
        , k.update_date
     FROM p#frm#mesr_query_t q
        , p#frm#mesr_keyfigure_t k
    WHERE k.mesr_query_id = q.mesr_query_id;
2014-11-28 13:53:20.790 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_keyfigure_v
AS
   SELECT q.mesr_query_code
        , k.mesr_keyfigure_id
        , k.mesr_keyfigure_code
        , k.mesr_keyfigure_name
        , k.update_date
     FROM dwhutl_mesr_query_t q
        , dwhutl_mesr_keyfigure_t k
    WHERE k.mesr_query_id = q.mesr_query_id;
2014-11-28 13:53:20.805 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_keyfigure_v.sql executed
2014-11-28 13:53:20.805 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_threshold_v.sql delimiter ;
2014-11-28 13:53:20.806 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_threshold_v
AS
     SELECT q.mesr_query_code
          , q.mesr_query_name
          , q.mesr_query_sql
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , t.mesr_threshold_type
          , t.mesr_threshold_from
          , t.mesr_threshold_to
          , t.mesr_threshold_min
          , t.mesr_threshold_max
       FROM p#frm#mesr_query_t q
          , p#frm#mesr_keyfigure_t k
          , p#frm#mesr_threshold_t t
      WHERE q.mesr_query_id = k.mesr_query_id
        AND k.mesr_keyfigure_id = t.mesr_keyfigure_id
   ORDER BY q.mesr_query_id DESC
          , k.mesr_keyfigure_id DESC
          , t.mesr_threshold_id DESC;
2014-11-28 13:53:20.806 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_threshold_v
AS
     SELECT q.mesr_query_code
          , q.mesr_query_name
          , q.mesr_query_sql
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , t.mesr_threshold_type
          , t.mesr_threshold_from
          , t.mesr_threshold_to
          , t.mesr_threshold_min
          , t.mesr_threshold_max
       FROM dwhutl_mesr_query_t q
          , dwhutl_mesr_keyfigure_t k
          , dwhutl_mesr_threshold_t t
      WHERE q.mesr_query_id = k.mesr_query_id
        AND k.mesr_keyfigure_id = t.mesr_keyfigure_id
   ORDER BY q.mesr_query_id DESC
          , k.mesr_keyfigure_id DESC
          , t.mesr_threshold_id DESC;
2014-11-28 13:53:20.852 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_threshold_v.sql executed
2014-11-28 13:53:20.852 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_meta_v.sql delimiter ;
2014-11-28 13:53:20.853 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_meta_v
AS
     SELECT s.mesr_query_code
          , s.mesr_query_name
          , s.mesr_query_sql
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , t.mesr_threshold_type
          , t.mesr_threshold_from
          , t.mesr_threshold_to
          , t.mesr_threshold_min
          , t.mesr_threshold_max
       FROM p#frm#mesr_query_t s
          , p#frm#mesr_keyfigure_t k
          , p#frm#mesr_threshold_t t
      WHERE s.mesr_query_id = k.mesr_query_id(+)
        AND k.mesr_keyfigure_id = t.mesr_keyfigure_id(+)
   ORDER BY s.mesr_query_id DESC
          , k.mesr_keyfigure_id DESC
          , t.mesr_threshold_id DESC;
2014-11-28 13:53:20.853 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_meta_v
AS
     SELECT s.mesr_query_code
          , s.mesr_query_name
          , s.mesr_query_sql
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , t.mesr_threshold_type
          , t.mesr_threshold_from
          , t.mesr_threshold_to
          , t.mesr_threshold_min
          , t.mesr_threshold_max
       FROM dwhutl_mesr_query_t s
          , dwhutl_mesr_keyfigure_t k
          , dwhutl_mesr_threshold_t t
      WHERE s.mesr_query_id = k.mesr_query_id(+)
        AND k.mesr_keyfigure_id = t.mesr_keyfigure_id(+)
   ORDER BY s.mesr_query_id DESC
          , k.mesr_keyfigure_id DESC
          , t.mesr_threshold_id DESC;
2014-11-28 13:53:20.878 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_meta_v.sql executed
2014-11-28 13:53:20.878 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_exec_v.sql delimiter ;
2014-11-28 13:53:20.879 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_exec_v
AS
     SELECT q.mesr_query_code
          , q.mesr_query_name
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , e.mesr_exec_result_value
          , t.mesr_threshold_type
          , t.mesr_threshold_min
          , t.mesr_threshold_max
          , e.update_date AS execution_date
       FROM p#frm#mesr_query_t q
          , p#frm#mesr_keyfigure_t k
          , p#frm#mesr_threshold_t t
          , p#frm#mesr_exec_t e
      WHERE q.mesr_query_id = k.mesr_query_id(+)
        AND k.mesr_keyfigure_id = e.mesr_keyfigure_id(+)
        AND e.mesr_keyfigure_id = t.mesr_keyfigure_id(+)
        AND NVL (
               t.mesr_threshold_from(+)
             , TO_DATE (
                  '10000101'
                , 'yyyymmdd'
               )
            ) <= e.update_date
        AND e.update_date <= NVL (
                                t.mesr_threshold_to(+)
                              , TO_DATE (
                                   '99991231'
                                 , 'yyyymmdd'
                                )
                             )
   ORDER BY e.update_date DESC;
2014-11-28 13:53:20.880 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_exec_v
AS
     SELECT q.mesr_query_code
          , q.mesr_query_name
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , e.mesr_exec_result_value
          , t.mesr_threshold_type
          , t.mesr_threshold_min
          , t.mesr_threshold_max
          , e.update_date AS execution_date
       FROM dwhutl_mesr_query_t q
          , dwhutl_mesr_keyfigure_t k
          , dwhutl_mesr_threshold_t t
          , dwhutl_mesr_exec_t e
      WHERE q.mesr_query_id = k.mesr_query_id(+)
        AND k.mesr_keyfigure_id = e.mesr_keyfigure_id(+)
        AND e.mesr_keyfigure_id = t.mesr_keyfigure_id(+)
        AND NVL (
               t.mesr_threshold_from(+)
             , TO_DATE (
                  '10000101'
                , 'yyyymmdd'
               )
            ) <= e.update_date
        AND e.update_date <= NVL (
                                t.mesr_threshold_to(+)
                              , TO_DATE (
                                   '99991231'
                                 , 'yyyymmdd'
                                )
                             )
   ORDER BY e.update_date DESC;
2014-11-28 13:53:20.902 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_exec_v.sql executed
2014-11-28 13:53:20.902 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_exec_verify_v.sql delimiter ;
2014-11-28 13:53:20.903 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#mesr_exec_verify_v
AS
     SELECT q.mesr_query_code
          , q.mesr_query_name
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , e.mesr_exec_result_value
          , LEAD (e.mesr_exec_result_value) OVER (PARTITION BY k.mesr_keyfigure_id ORDER BY e.update_date DESC) AS mesr_exec_result_previous
          , t.mesr_threshold_type
          , t.mesr_threshold_min
          , t.mesr_threshold_max
          , e.update_date AS execution_date
       FROM p#frm#mesr_query_t q
          , p#frm#mesr_keyfigure_t k
          , p#frm#mesr_threshold_t t
          , p#frm#mesr_exec_t e
      WHERE q.mesr_query_id = k.mesr_query_id(+)
        AND k.mesr_keyfigure_id = e.mesr_keyfigure_id(+)
        AND e.mesr_keyfigure_id = t.mesr_keyfigure_id(+)
        AND NVL (
               t.mesr_threshold_from(+)
             , TO_DATE (
                  '10000101'
                , 'yyyymmdd'
               )
            ) <= e.update_date
        AND e.update_date <= NVL (
                                t.mesr_threshold_to(+)
                              , TO_DATE (
                                   '99991231'
                                 , 'yyyymmdd'
                                )
                             )
   ORDER BY e.update_date DESC;
2014-11-28 13:53:20.903 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_mesr_exec_verify_v
AS
     SELECT q.mesr_query_code
          , q.mesr_query_name
          , k.mesr_keyfigure_code
          , k.mesr_keyfigure_name
          , e.mesr_exec_result_value
          , LEAD (e.mesr_exec_result_value) OVER (PARTITION BY k.mesr_keyfigure_id ORDER BY e.update_date DESC) AS mesr_exec_result_previous
          , t.mesr_threshold_type
          , t.mesr_threshold_min
          , t.mesr_threshold_max
          , e.update_date AS execution_date
       FROM dwhutl_mesr_query_t q
          , dwhutl_mesr_keyfigure_t k
          , dwhutl_mesr_threshold_t t
          , dwhutl_mesr_exec_t e
      WHERE q.mesr_query_id = k.mesr_query_id(+)
        AND k.mesr_keyfigure_id = e.mesr_keyfigure_id(+)
        AND e.mesr_keyfigure_id = t.mesr_keyfigure_id(+)
        AND NVL (
               t.mesr_threshold_from(+)
             , TO_DATE (
                  '10000101'
                , 'yyyymmdd'
               )
            ) <= e.update_date
        AND e.update_date <= NVL (
                                t.mesr_threshold_to(+)
                              , TO_DATE (
                                   '99991231'
                                 , 'yyyymmdd'
                                )
                             )
   ORDER BY e.update_date DESC;
2014-11-28 13:53:20.926 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/mesr_exec_verify_v.sql executed
2014-11-28 13:53:20.926 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/docu_param/docu_param-def.sql delimiter 
2014-11-28 13:53:20.927 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#docu_param
   AUTHID CURRENT_USER
AS
   /**
   * Package containing general purpose functions and procedures
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version     CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url         CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version              VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                  VARCHAR2 (1024);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   /**
   * Javascript for dynamic effects
   */
   c_js_default                t_string
                                  :=    '<script type="text/javascript">
function changeRowDisplay(nodeIdPath) {

  nLevelParent = nodeIdPath.split("_").length;
  arrRows = document.getElementsByTagName("tr");
  for ( i = 0; i < arrRows.length; i++ ) {
    nLevelNode = arrRows[i].id.split("_").length;
    if (arrRows[i].id.substring(0,nodeIdPath.length) == nodeIdPath) {
      if (arrRows[i].style.display=="none" '
                                     || CHR (38)
                                     || CHR (38)
                                     || ' nLevelNode == nLevelParent + 1){
        arrRows[i].style.display="block";
        document.getElementById(nodeIdPath+ "_control").innerHTML = "-";
      }
      else if (arrRows[i].style.display=="block" '
                                     || CHR (38)
                                     || CHR (38)
                                     || ' nLevelNode > nLevelParent){
        arrRows[i].style.display="none";
        document.getElementById(nodeIdPath+ "_control").innerHTML = "+";
        if (document.getElementById(arrRows[i].id + "_control")) {
          document.getElementById(arrRows[i].id + "_control").innerHTML = "+";
        }
      }
    }
  }
}
</script>';
   /**
    * CSS
    */
   c_css_default               t_string := '<style>
body {
  background-color: rgb(239, 239, 239);
}
table {
  border-style: solid;
  border-left-width: 1px;
  border-top-width: 1px;
  border-right-width: 0px;
  border-bottom-width: 0px;
  border-color: rgb(8, 36, 107);
}
th {
  border-style: solid;
  border-left-width: 0px;
  border-top-width: 0px;
  border-right-width: 1px;
  border-bottom-width: 1px;
  background-color: rgb(243, 184, 123);
  text-align: left;
}
td {
  border-style: solid;
  border-left-width: 0px;
  border-top-width: 0px;
  border-right-width: 1px;
  border-bottom-width: 1px;
  background-color: rgb(214, 223, 247);
  text-align: justify;
}
h1 {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
h2 {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
h3 {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
p {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
p.number {
  text-align: right;
}
a.control {
  background-color: rgb(255, 255, 255);
  border-style: solid;
  border-width: 1px;
  border-color: rgb(8, 36, 107);
  text-align: center;
  width: 10px;
}
</style>';
   /**
    * HTML Email Template
    */
   c_html_template_content     CLOB := '<html>
<head>
<title>Oracle Email</title>
<htmlScript />
<htmlStyle />
</head>
<body>
<htmlContent />
</body>
</html>';
   /**
    * Excel Attachment Template
    */
   c_excel_template_content    CLOB := '<?xml version="1.0"?>
<Workbook
	xmlns="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:o="urn:schemas-microsoft-com:office:office"
	xmlns:x="urn:schemas-microsoft-com:office:excel"
	xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:html="http://www.w3.org/TR/REC-html40"
>
<workbookContent />
</Workbook>';
   /**
    * HTML Table stylesheet
    */
   c_xsl_html_table_default    t_string := '<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:data="http://java.sun.com/xml/ns/jdbc">
<xsl:param name="sort_column" />
<xsl:param name="sort_order" />
<xsl:template match="data:webRowSet">
    <table cellspacing="0" cellpadding="2">
    <tr>
    <xsl:for-each select="data:metadata/data:column-definition">
        <th>
        <xsl:attribute name="id">column<xsl:value-of select="position()" /></xsl:attribute>
        <p><xsl:value-of select="data:column-label" /></p>
        </th>
    </xsl:for-each>
    </tr>
    <xsl:for-each select="data:data/data:currentRow">
        <tr>
        <xsl:for-each select="data:columnValue">
            <td>
            <xsl:choose>
                <xsl:when test="string-length()=0">
                    <p>-</p>
                </xsl:when>
                <xsl:otherwise>
                    <p>
    			    <xsl:variable name="cell_value"><xsl:value-of select="." /></xsl:variable>
        			<xsl:choose>
        			  <xsl:when test="number($cell_value)">
        			    <xsl:attribute name="class">number</xsl:attribute>
      				  </xsl:when>
        			</xsl:choose>
                    <xsl:value-of select="." />
                    </p>
                </xsl:otherwise>
            </xsl:choose>                    
            </td>
        </xsl:for-each>
        </tr>
    </xsl:for-each>
    </table>
</xsl:template>
</xsl:stylesheet>';
   /**
    * Excel Table stylesheet
    */
   c_xsl_excel_table_default   t_string := '<xsl:stylesheet version="1.0"
	xmlns="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
	xmlns:msxsl="urn:schemas-microsoft-com:xslt"
	xmlns:user="urn:my-scripts"
	xmlns:o="urn:schemas-microsoft-com:office:office"
	xmlns:x="urn:schemas-microsoft-com:office:excel"
	xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:data="http://java.sun.com/xml/ns/jdbc"
>
<xsl:template match="data:webRowSet">
	<Worksheet>
        <xsl:attribute name="ss:Name"><worksheetName /></xsl:attribute>
    <Table>
	<Row>
	<xsl:for-each select="data:metadata/data:column-definition">
		<Cell><Data ss:Type="String"><xsl:value-of select="data:column-label" /></Data></Cell>
	</xsl:for-each>
	</Row>
	<xsl:for-each select="data:data/data:currentRow">
		<Row>
		<xsl:for-each select="data:columnValue">
            <Cell>
			<Data>
    		<xsl:variable name="cell_value"><xsl:value-of select="." /></xsl:variable>
        		<xsl:choose>
        		    <xsl:when test="number($cell_value)">
        		        <xsl:attribute name="ss:Type">Number</xsl:attribute>
      			    </xsl:when>
                    <xsl:otherwise>
        		        <xsl:attribute name="ss:Type">String</xsl:attribute>
                    </xsl:otherwise>
        		</xsl:choose>
            <xsl:value-of select="." />
            </Data>
            </Cell>
		</xsl:for-each>
		</Row>
	</xsl:for-each>
	</Table>
	</Worksheet>
</xsl:template>
</xsl:stylesheet>';
END p#frm#docu_param;
2014-11-28 13:53:20.927 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_docu_param
   AUTHID CURRENT_USER
AS
   /**
   * Package containing general purpose functions and procedures
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version     CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url         CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version              VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                  VARCHAR2 (1024);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   /**
   * Javascript for dynamic effects
   */
   c_js_default                t_string
                                  :=    '<script type="text/javascript">
function changeRowDisplay(nodeIdPath) {

  nLevelParent = nodeIdPath.split("_").length;
  arrRows = document.getElementsByTagName("tr");
  for ( i = 0; i < arrRows.length; i++ ) {
    nLevelNode = arrRows[i].id.split("_").length;
    if (arrRows[i].id.substring(0,nodeIdPath.length) == nodeIdPath) {
      if (arrRows[i].style.display=="none" '
                                     || CHR (38)
                                     || CHR (38)
                                     || ' nLevelNode == nLevelParent + 1){
        arrRows[i].style.display="block";
        document.getElementById(nodeIdPath+ "_control").innerHTML = "-";
      }
      else if (arrRows[i].style.display=="block" '
                                     || CHR (38)
                                     || CHR (38)
                                     || ' nLevelNode > nLevelParent){
        arrRows[i].style.display="none";
        document.getElementById(nodeIdPath+ "_control").innerHTML = "+";
        if (document.getElementById(arrRows[i].id + "_control")) {
          document.getElementById(arrRows[i].id + "_control").innerHTML = "+";
        }
      }
    }
  }
}
</script>';
   /**
    * CSS
    */
   c_css_default               t_string := '<style>
body {
  background-color: rgb(239, 239, 239);
}
table {
  border-style: solid;
  border-left-width: 1px;
  border-top-width: 1px;
  border-right-width: 0px;
  border-bottom-width: 0px;
  border-color: rgb(8, 36, 107);
}
th {
  border-style: solid;
  border-left-width: 0px;
  border-top-width: 0px;
  border-right-width: 1px;
  border-bottom-width: 1px;
  background-color: rgb(243, 184, 123);
  text-align: left;
}
td {
  border-style: solid;
  border-left-width: 0px;
  border-top-width: 0px;
  border-right-width: 1px;
  border-bottom-width: 1px;
  background-color: rgb(214, 223, 247);
  text-align: justify;
}
h1 {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
h2 {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
h3 {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
p {
  font-family: arial;
  color: rgb(0, 0, 102);
  margin: 0px;
}
p.number {
  text-align: right;
}
a.control {
  background-color: rgb(255, 255, 255);
  border-style: solid;
  border-width: 1px;
  border-color: rgb(8, 36, 107);
  text-align: center;
  width: 10px;
}
</style>';
   /**
    * HTML Email Template
    */
   c_html_template_content     CLOB := '<html>
<head>
<title>Oracle Email</title>
<htmlScript />
<htmlStyle />
</head>
<body>
<htmlContent />
</body>
</html>';
   /**
    * Excel Attachment Template
    */
   c_excel_template_content    CLOB := '<?xml version="1.0"?>
<Workbook
	xmlns="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:o="urn:schemas-microsoft-com:office:office"
	xmlns:x="urn:schemas-microsoft-com:office:excel"
	xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:html="http://www.w3.org/TR/REC-html40"
>
<workbookContent />
</Workbook>';
   /**
    * HTML Table stylesheet
    */
   c_xsl_html_table_default    t_string := '<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:data="http://java.sun.com/xml/ns/jdbc">
<xsl:param name="sort_column" />
<xsl:param name="sort_order" />
<xsl:template match="data:webRowSet">
    <table cellspacing="0" cellpadding="2">
    <tr>
    <xsl:for-each select="data:metadata/data:column-definition">
        <th>
        <xsl:attribute name="id">column<xsl:value-of select="position()" /></xsl:attribute>
        <p><xsl:value-of select="data:column-label" /></p>
        </th>
    </xsl:for-each>
    </tr>
    <xsl:for-each select="data:data/data:currentRow">
        <tr>
        <xsl:for-each select="data:columnValue">
            <td>
            <xsl:choose>
                <xsl:when test="string-length()=0">
                    <p>-</p>
                </xsl:when>
                <xsl:otherwise>
                    <p>
    			    <xsl:variable name="cell_value"><xsl:value-of select="." /></xsl:variable>
        			<xsl:choose>
        			  <xsl:when test="number($cell_value)">
        			    <xsl:attribute name="class">number</xsl:attribute>
      				  </xsl:when>
        			</xsl:choose>
                    <xsl:value-of select="." />
                    </p>
                </xsl:otherwise>
            </xsl:choose>                    
            </td>
        </xsl:for-each>
        </tr>
    </xsl:for-each>
    </table>
</xsl:template>
</xsl:stylesheet>';
   /**
    * Excel Table stylesheet
    */
   c_xsl_excel_table_default   t_string := '<xsl:stylesheet version="1.0"
	xmlns="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
	xmlns:msxsl="urn:schemas-microsoft-com:xslt"
	xmlns:user="urn:my-scripts"
	xmlns:o="urn:schemas-microsoft-com:office:office"
	xmlns:x="urn:schemas-microsoft-com:office:excel"
	xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
	xmlns:data="http://java.sun.com/xml/ns/jdbc"
>
<xsl:template match="data:webRowSet">
	<Worksheet>
        <xsl:attribute name="ss:Name"><worksheetName /></xsl:attribute>
    <Table>
	<Row>
	<xsl:for-each select="data:metadata/data:column-definition">
		<Cell><Data ss:Type="String"><xsl:value-of select="data:column-label" /></Data></Cell>
	</xsl:for-each>
	</Row>
	<xsl:for-each select="data:data/data:currentRow">
		<Row>
		<xsl:for-each select="data:columnValue">
            <Cell>
			<Data>
    		<xsl:variable name="cell_value"><xsl:value-of select="." /></xsl:variable>
        		<xsl:choose>
        		    <xsl:when test="number($cell_value)">
        		        <xsl:attribute name="ss:Type">Number</xsl:attribute>
      			    </xsl:when>
                    <xsl:otherwise>
        		        <xsl:attribute name="ss:Type">String</xsl:attribute>
                    </xsl:otherwise>
        		</xsl:choose>
            <xsl:value-of select="." />
            </Data>
            </Cell>
		</xsl:for-each>
		</Row>
	</xsl:for-each>
	</Table>
	</Worksheet>
</xsl:template>
</xsl:stylesheet>';
END dwhutl_docu_param;
2014-11-28 13:53:20.965 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/docu_param/docu_param-def.sql executed
2014-11-28 13:53:20.965 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/docu/docu-def.sql delimiter 
2014-11-28 13:53:20.966 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#docu
   AUTHID CURRENT_USER
AS
   /**
   * Package containing general purpose functions and procedures
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Get stylesheet
   *
   * p_vc_stylesheet_type       Type of stylesheet
   */
   FUNCTION fct_get_stylesheet (p_vc_stylesheet_type VARCHAR2)
      RETURN CLOB;

   /**
   * Generate metadata item
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_meta_item (p_vc_content VARCHAR2)
      RETURN CLOB;

   /**
   * Generate metadata part of the data set
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_meta (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Generate a data cell
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_data_cell (p_vc_content VARCHAR2)
      RETURN CLOB;

   /**
   * Generate data record
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_data_record (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Generate data part of the data set
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_data (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Generate complete dataset
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_dataset (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Format dataset using a dataset and a style
   *
   * p_vc_content       Content to be transformed
   * p_vc_stylesheet    Stylesheet to transform the dataset in different output
   */
   FUNCTION fct_get_dataset_formatted (
      p_vc_dataset       CLOB
    , p_vc_stylesheet    CLOB
   )
      RETURN CLOB;

   /**
   * Generate report of given type from a document
   *
   * p_vc_document      Document to be put in the type template
   * p_vc_type          Type (html, excel)
   */
   FUNCTION fct_get_document (
      p_vc_content    CLOB
    , p_vc_type       CLOB
   )
      RETURN CLOB;

   /**
   * Get a report about the content of a given table in the wished format
   *
   * @param p_vc_table_name       Table name
   * @param p_vc_column_list      Column lists
   * @param p_vc_where_clause     Where clause
   * @param p_vc_report_format    Output format
   * @return                      Report object (table) in the chosen format
   */
   FUNCTION fct_get_table_dataset (
      p_vc_table_owner    IN VARCHAR2
    , p_vc_table_name     IN VARCHAR2
    , p_vc_column_list    IN VARCHAR2 DEFAULT NULL
    , p_vc_where_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_order_clause   IN VARCHAR2 DEFAULT NULL
   )
      RETURN CLOB;

   /**
   * Save a document in the aux_DOC table
   *
   * @param p_vc_docu_code      Document code
   * @param p_vc_docu_type      Document type
   * @param p_vc_docu_content   Document content
   * @param p_vc_docu_url      Document URL
   * @param p_vc_docu_desc      Document description
   */
   PROCEDURE prc_save_document (
      p_vc_docu_code      IN VARCHAR2
    , p_vc_docu_type      IN VARCHAR2
    , p_vc_docu_content   IN CLOB
    , p_vc_docu_url       IN VARCHAR2 DEFAULT NULL
    , p_vc_docu_desc      IN VARCHAR2 DEFAULT NULL
   );
END p#frm#docu;
2014-11-28 13:53:20.966 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_docu
   AUTHID CURRENT_USER
AS
   /**
   * Package containing general purpose functions and procedures
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Get stylesheet
   *
   * p_vc_stylesheet_type       Type of stylesheet
   */
   FUNCTION fct_get_stylesheet (p_vc_stylesheet_type VARCHAR2)
      RETURN CLOB;

   /**
   * Generate metadata item
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_meta_item (p_vc_content VARCHAR2)
      RETURN CLOB;

   /**
   * Generate metadata part of the data set
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_meta (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Generate a data cell
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_data_cell (p_vc_content VARCHAR2)
      RETURN CLOB;

   /**
   * Generate data record
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_data_record (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Generate data part of the data set
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_data (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Generate complete dataset
   *
   * p_vc_content       Content to be transformed
   */
   FUNCTION fct_get_dataset (p_vc_content CLOB)
      RETURN CLOB;

   /**
   * Format dataset using a dataset and a style
   *
   * p_vc_content       Content to be transformed
   * p_vc_stylesheet    Stylesheet to transform the dataset in different output
   */
   FUNCTION fct_get_dataset_formatted (
      p_vc_dataset       CLOB
    , p_vc_stylesheet    CLOB
   )
      RETURN CLOB;

   /**
   * Generate report of given type from a document
   *
   * p_vc_document      Document to be put in the type template
   * p_vc_type          Type (html, excel)
   */
   FUNCTION fct_get_document (
      p_vc_content    CLOB
    , p_vc_type       CLOB
   )
      RETURN CLOB;

   /**
   * Get a report about the content of a given table in the wished format
   *
   * @param p_vc_table_name       Table name
   * @param p_vc_column_list      Column lists
   * @param p_vc_where_clause     Where clause
   * @param p_vc_report_format    Output format
   * @return                      Report object (table) in the chosen format
   */
   FUNCTION fct_get_table_dataset (
      p_vc_table_owner    IN VARCHAR2
    , p_vc_table_name     IN VARCHAR2
    , p_vc_column_list    IN VARCHAR2 DEFAULT NULL
    , p_vc_where_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_order_clause   IN VARCHAR2 DEFAULT NULL
   )
      RETURN CLOB;

   /**
   * Save a document in the aux_DOC table
   *
   * @param p_vc_docu_code      Document code
   * @param p_vc_docu_type      Document type
   * @param p_vc_docu_content   Document content
   * @param p_vc_docu_url      Document URL
   * @param p_vc_docu_desc      Document description
   */
   PROCEDURE prc_save_document (
      p_vc_docu_code      IN VARCHAR2
    , p_vc_docu_type      IN VARCHAR2
    , p_vc_docu_content   IN CLOB
    , p_vc_docu_url       IN VARCHAR2 DEFAULT NULL
    , p_vc_docu_desc      IN VARCHAR2 DEFAULT NULL
   );
END dwhutl_docu;
2014-11-28 13:53:20.980 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/docu/docu-def.sql executed
2014-11-28 13:53:20.980 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/docu/docu-impl.sql delimiter 
2014-11-28 13:53:20.981 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#docu
IS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   TYPE l_line_array IS TABLE OF VARCHAR2 (4000)
      INDEX BY PLS_INTEGER;

   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        VARCHAR2(50) := 'PRC_SET_CODE_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   NUMBER;
      l_i_position_end     NUMBER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '<'
              || p_vc_param_name
              || ' />'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '<'
              || p_vc_param_name
              || ' />'
           )
         + LENGTH (p_vc_param_name)
         + 4;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin > 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '<'
                 || p_vc_param_name
                 || ' />'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '<'
                 || p_vc_param_name
                 || ' />'
              )
            + LENGTH (p_vc_param_name)
            + 4;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   FUNCTION fct_get_stylesheet (p_vc_stylesheet_type VARCHAR2)
      RETURN CLOB
   IS
   BEGIN
      IF p_vc_stylesheet_type = 'HTML' THEN
         RETURN p#frm#docu_param.c_xsl_html_table_default;
      ELSIF p_vc_stylesheet_type = 'HTML' THEN
         RETURN p#frm#docu_param.c_xsl_excel_table_default;
      ELSE
         RETURN NULL;
      END IF;
   END fct_get_stylesheet;

   FUNCTION fct_get_meta_item (p_vc_content VARCHAR2)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<column-definition><column-label>'
             || p_vc_content
             || '</column-label></column-definition>';
   END fct_get_meta_item;

   FUNCTION fct_get_meta (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<metadata>'
             || p_vc_content
             || '</metadata>';
   END fct_get_meta;

   FUNCTION fct_get_data_cell (p_vc_content VARCHAR2)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<columnValue>'
             || p_vc_content
             || '</columnValue>';
   END fct_get_data_cell;

   /**
   * Generate a record
   */
   FUNCTION fct_get_data_record (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<currentRow>'
             || p_vc_content
             || '</currentRow>';
   END fct_get_data_record;

   FUNCTION fct_get_data (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<data>'
             || p_vc_content
             || '</data>';
   END fct_get_data;

   FUNCTION fct_get_data (p_l_content l_line_array)
      RETURN CLOB
   IS
      l_vc_content   CLOB;
   BEGIN
      IF p_l_content.FIRST IS NOT NULL THEN
         FOR i IN p_l_content.FIRST .. p_l_content.LAST LOOP
            l_vc_content :=
                  l_vc_content
               || p_l_content (i);
         END LOOP;
      END IF;

      RETURN    '<data>'
             || l_vc_content
             || '</data>';
   END fct_get_data;

   FUNCTION fct_get_dataset (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<?xml version="1.0" ?>'
             || '<webRowSet xmlns="http://java.sun.com/xml/ns/jdbc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/jdbc http://java.sun.com/xml/ns/jdbc/webrowset.xsd">'
             || p_vc_content
             || '</webRowSet>';
   END fct_get_dataset;

   FUNCTION fct_get_dataset_formatted (
      p_vc_dataset       CLOB
    , p_vc_stylesheet    CLOB
   )
      RETURN CLOB
   IS
      l_vc_document   CLOB;
   BEGIN
      SELECT XMLTRANSFORM (
                xmltype (p_vc_dataset)
              , xmltype (p_vc_stylesheet)
             ).getclobval ()
        INTO l_vc_document
        FROM DUAL;

      l_vc_document :=
         REPLACE (
            l_vc_document
          , '><'
          ,    '>'
            || CHR (10)
            || '<'
         );
      RETURN l_vc_document;
   END fct_get_dataset_formatted;

   FUNCTION fct_get_document (
      p_vc_content    CLOB
    , p_vc_type       CLOB
   )
      RETURN CLOB
   IS
      l_clob_document   CLOB;
   BEGIN
      CASE p_vc_type
         WHEN 'html' THEN
            l_clob_document := p#frm#docu_param.c_html_template_content;
            prc_set_text_param (
               l_clob_document
             , 'htmlScript'
             , p#frm#docu_param.c_js_default
            );
            prc_set_text_param (
               l_clob_document
             , 'htmlStyle'
             , p#frm#docu_param.c_css_default
            );
            prc_set_text_param (
               l_clob_document
             , 'htmlContent'
             , p_vc_content
            );
         WHEN 'ms-excel' THEN
            l_clob_document := p#frm#docu_param.c_excel_template_content;
            prc_set_text_param (
               l_clob_document
             , 'workbookContent'
             , p_vc_content
            );
      END CASE;

      RETURN l_clob_document;
   END fct_get_document;

   FUNCTION fct_get_table_dataset (
      p_vc_table_owner    IN VARCHAR2
    , p_vc_table_name     IN VARCHAR2
    , p_vc_column_list    IN VARCHAR2 DEFAULT NULL
    , p_vc_where_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_order_clause   IN VARCHAR2 DEFAULT NULL
   )
      RETURN CLOB
   IS
      l_l_columns        DBMS_SQL.varchar2s;
      l_l_records        l_line_array;
      l_vc_column_list   VARCHAR2 (32000);
      l_vc_sql           VARCHAR2 (32000);
      l_xml_meta         CLOB;
      l_xml_data         CLOB;
      l_clob_report      CLOB;
   BEGIN
      -- Generate the metadata section of the webrowset
      IF p_vc_column_list IS NULL THEN
           SELECT fct_get_meta_item (column_name)
             BULK COLLECT INTO l_l_columns
             FROM all_tab_columns
            WHERE owner = UPPER (p_vc_table_owner)
              AND table_name = UPPER (p_vc_table_name)
         ORDER BY column_id;

         l_vc_column_list := p#frm#type.fct_list_to_string (l_l_columns);
      ELSE
         l_l_columns :=
            p#frm#type.fct_string_to_list (
               p_vc_column_list
             , ','
            );

         FOR i IN l_l_columns.FIRST .. l_l_columns.LAST LOOP
            l_vc_column_list :=
                  l_vc_column_list
               || fct_get_meta_item (l_l_columns (i));
         END LOOP;
      END IF;

      l_xml_meta := fct_get_meta (l_vc_column_list);
      -- Generate the data section of the webrowset
      l_vc_column_list := NULL;

      IF p_vc_column_list IS NULL THEN
           SELECT    '|| doc.fct_get_data_cell ("'
                  || column_name
                  || '")'
             BULK COLLECT INTO l_l_columns
             FROM all_tab_columns
            WHERE owner = UPPER (p_vc_table_owner)
              AND table_name = UPPER (p_vc_table_name)
         ORDER BY column_id;

         l_vc_column_list :=
            LTRIM (
               p#frm#type.fct_list_to_string (l_l_columns)
             , ' ||'
            );
      ELSE
         l_l_columns :=
            p#frm#type.fct_string_to_list (
               p_vc_column_list
             , ','
            );

         FOR i IN l_l_columns.FIRST .. l_l_columns.LAST LOOP
            l_vc_column_list :=
                  l_vc_column_list
               || CASE
                     WHEN i > 1 THEN
                        ' || '
                  END
               || 'doc.fct_get_data_cell ('
               || l_l_columns (i)
               || ')';
         END LOOP;
      END IF;

      l_vc_sql :=
            'SELECT doc.fct_get_data_record ('
         || l_vc_column_list
         || ') FROM '
         || p_vc_table_name
         || CASE
               WHEN p_vc_where_clause IS NULL THEN
                  NULL
               ELSE
                     ' WHERE '
                  || p_vc_where_clause
            END
         || CASE
               WHEN p_vc_order_clause IS NULL THEN
                  NULL
               ELSE
                     ' ORDER BY '
                  || p_vc_order_clause
            END;

      EXECUTE IMMEDIATE l_vc_sql BULK COLLECT INTO l_l_records;

      l_xml_data := fct_get_data (l_l_records);
      -- Return the complete dataset in from of a webrowset
      RETURN fct_get_dataset (   l_xml_meta
                              || l_xml_data);
   END fct_get_table_dataset;

   PROCEDURE prc_save_document (
      p_vc_docu_code      IN VARCHAR2
    , p_vc_docu_type      IN VARCHAR2
    , p_vc_docu_content   IN CLOB
    , p_vc_docu_url       IN VARCHAR2 DEFAULT NULL
    , p_vc_docu_desc      IN VARCHAR2 DEFAULT NULL
   )
   IS
   BEGIN
      DELETE p#frm#docu_t
       WHERE docu_code = p_vc_docu_code
         AND docu_type = p_vc_docu_type;

      INSERT INTO p#frm#docu_t (
                     docu_code
                   , docu_type
                   , docu_content
                   , docu_url
                   , docu_desc
                  )
           VALUES (
                     p_vc_docu_code
                   , p_vc_docu_type
                   , p_vc_docu_content
                   , p_vc_docu_url
                   , p_vc_docu_desc
                  );

      COMMIT;
   END prc_save_document;
/**
* Package initialization
*/
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#docu;
2014-11-28 13:53:20.982 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_docu
IS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   TYPE l_line_array IS TABLE OF VARCHAR2 (4000)
      INDEX BY PLS_INTEGER;

   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        VARCHAR2(50) := 'PRC_SET_CODE_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   NUMBER;
      l_i_position_end     NUMBER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '<'
              || p_vc_param_name
              || ' />'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '<'
              || p_vc_param_name
              || ' />'
           )
         + LENGTH (p_vc_param_name)
         + 4;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin > 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '<'
                 || p_vc_param_name
                 || ' />'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '<'
                 || p_vc_param_name
                 || ' />'
              )
            + LENGTH (p_vc_param_name)
            + 4;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   FUNCTION fct_get_stylesheet (p_vc_stylesheet_type VARCHAR2)
      RETURN CLOB
   IS
   BEGIN
      IF p_vc_stylesheet_type = 'HTML' THEN
         RETURN dwhutl_docu_param.c_xsl_html_table_default;
      ELSIF p_vc_stylesheet_type = 'HTML' THEN
         RETURN dwhutl_docu_param.c_xsl_excel_table_default;
      ELSE
         RETURN NULL;
      END IF;
   END fct_get_stylesheet;

   FUNCTION fct_get_meta_item (p_vc_content VARCHAR2)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<column-definition><column-label>'
             || p_vc_content
             || '</column-label></column-definition>';
   END fct_get_meta_item;

   FUNCTION fct_get_meta (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<metadata>'
             || p_vc_content
             || '</metadata>';
   END fct_get_meta;

   FUNCTION fct_get_data_cell (p_vc_content VARCHAR2)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<columnValue>'
             || p_vc_content
             || '</columnValue>';
   END fct_get_data_cell;

   /**
   * Generate a record
   */
   FUNCTION fct_get_data_record (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<currentRow>'
             || p_vc_content
             || '</currentRow>';
   END fct_get_data_record;

   FUNCTION fct_get_data (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<data>'
             || p_vc_content
             || '</data>';
   END fct_get_data;

   FUNCTION fct_get_data (p_l_content l_line_array)
      RETURN CLOB
   IS
      l_vc_content   CLOB;
   BEGIN
      IF p_l_content.FIRST IS NOT NULL THEN
         FOR i IN p_l_content.FIRST .. p_l_content.LAST LOOP
            l_vc_content :=
                  l_vc_content
               || p_l_content (i);
         END LOOP;
      END IF;

      RETURN    '<data>'
             || l_vc_content
             || '</data>';
   END fct_get_data;

   FUNCTION fct_get_dataset (p_vc_content CLOB)
      RETURN CLOB
   IS
   BEGIN
      RETURN    '<?xml version="1.0" ?>'
             || '<webRowSet xmlns="http://java.sun.com/xml/ns/jdbc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/jdbc http://java.sun.com/xml/ns/jdbc/webrowset.xsd">'
             || p_vc_content
             || '</webRowSet>';
   END fct_get_dataset;

   FUNCTION fct_get_dataset_formatted (
      p_vc_dataset       CLOB
    , p_vc_stylesheet    CLOB
   )
      RETURN CLOB
   IS
      l_vc_document   CLOB;
   BEGIN
      SELECT XMLTRANSFORM (
                xmltype (p_vc_dataset)
              , xmltype (p_vc_stylesheet)
             ).getclobval ()
        INTO l_vc_document
        FROM DUAL;

      l_vc_document :=
         REPLACE (
            l_vc_document
          , '><'
          ,    '>'
            || CHR (10)
            || '<'
         );
      RETURN l_vc_document;
   END fct_get_dataset_formatted;

   FUNCTION fct_get_document (
      p_vc_content    CLOB
    , p_vc_type       CLOB
   )
      RETURN CLOB
   IS
      l_clob_document   CLOB;
   BEGIN
      CASE p_vc_type
         WHEN 'html' THEN
            l_clob_document := dwhutl_docu_param.c_html_template_content;
            prc_set_text_param (
               l_clob_document
             , 'htmlScript'
             , dwhutl_docu_param.c_js_default
            );
            prc_set_text_param (
               l_clob_document
             , 'htmlStyle'
             , dwhutl_docu_param.c_css_default
            );
            prc_set_text_param (
               l_clob_document
             , 'htmlContent'
             , p_vc_content
            );
         WHEN 'ms-excel' THEN
            l_clob_document := dwhutl_docu_param.c_excel_template_content;
            prc_set_text_param (
               l_clob_document
             , 'workbookContent'
             , p_vc_content
            );
      END CASE;

      RETURN l_clob_document;
   END fct_get_document;

   FUNCTION fct_get_table_dataset (
      p_vc_table_owner    IN VARCHAR2
    , p_vc_table_name     IN VARCHAR2
    , p_vc_column_list    IN VARCHAR2 DEFAULT NULL
    , p_vc_where_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_order_clause   IN VARCHAR2 DEFAULT NULL
   )
      RETURN CLOB
   IS
      l_l_columns        DBMS_SQL.varchar2s;
      l_l_records        l_line_array;
      l_vc_column_list   VARCHAR2 (32000);
      l_vc_sql           VARCHAR2 (32000);
      l_xml_meta         CLOB;
      l_xml_data         CLOB;
      l_clob_report      CLOB;
   BEGIN
      -- Generate the metadata section of the webrowset
      IF p_vc_column_list IS NULL THEN
           SELECT fct_get_meta_item (column_name)
             BULK COLLECT INTO l_l_columns
             FROM all_tab_columns
            WHERE owner = UPPER (p_vc_table_owner)
              AND table_name = UPPER (p_vc_table_name)
         ORDER BY column_id;

         l_vc_column_list := dwhutl_type.fct_list_to_string (l_l_columns);
      ELSE
         l_l_columns :=
            dwhutl_type.fct_string_to_list (
               p_vc_column_list
             , ','
            );

         FOR i IN l_l_columns.FIRST .. l_l_columns.LAST LOOP
            l_vc_column_list :=
                  l_vc_column_list
               || fct_get_meta_item (l_l_columns (i));
         END LOOP;
      END IF;

      l_xml_meta := fct_get_meta (l_vc_column_list);
      -- Generate the data section of the webrowset
      l_vc_column_list := NULL;

      IF p_vc_column_list IS NULL THEN
           SELECT    '|| doc.fct_get_data_cell ("'
                  || column_name
                  || '")'
             BULK COLLECT INTO l_l_columns
             FROM all_tab_columns
            WHERE owner = UPPER (p_vc_table_owner)
              AND table_name = UPPER (p_vc_table_name)
         ORDER BY column_id;

         l_vc_column_list :=
            LTRIM (
               dwhutl_type.fct_list_to_string (l_l_columns)
             , ' ||'
            );
      ELSE
         l_l_columns :=
            dwhutl_type.fct_string_to_list (
               p_vc_column_list
             , ','
            );

         FOR i IN l_l_columns.FIRST .. l_l_columns.LAST LOOP
            l_vc_column_list :=
                  l_vc_column_list
               || CASE
                     WHEN i > 1 THEN
                        ' || '
                  END
               || 'doc.fct_get_data_cell ('
               || l_l_columns (i)
               || ')';
         END LOOP;
      END IF;

      l_vc_sql :=
            'SELECT doc.fct_get_data_record ('
         || l_vc_column_list
         || ') FROM '
         || p_vc_table_name
         || CASE
               WHEN p_vc_where_clause IS NULL THEN
                  NULL
               ELSE
                     ' WHERE '
                  || p_vc_where_clause
            END
         || CASE
               WHEN p_vc_order_clause IS NULL THEN
                  NULL
               ELSE
                     ' ORDER BY '
                  || p_vc_order_clause
            END;

      EXECUTE IMMEDIATE l_vc_sql BULK COLLECT INTO l_l_records;

      l_xml_data := fct_get_data (l_l_records);
      -- Return the complete dataset in from of a webrowset
      RETURN fct_get_dataset (   l_xml_meta
                              || l_xml_data);
   END fct_get_table_dataset;

   PROCEDURE prc_save_document (
      p_vc_docu_code      IN VARCHAR2
    , p_vc_docu_type      IN VARCHAR2
    , p_vc_docu_content   IN CLOB
    , p_vc_docu_url       IN VARCHAR2 DEFAULT NULL
    , p_vc_docu_desc      IN VARCHAR2 DEFAULT NULL
   )
   IS
   BEGIN
      DELETE dwhutl_docu_t
       WHERE docu_code = p_vc_docu_code
         AND docu_type = p_vc_docu_type;

      INSERT INTO dwhutl_docu_t (
                     docu_code
                   , docu_type
                   , docu_content
                   , docu_url
                   , docu_desc
                  )
           VALUES (
                     p_vc_docu_code
                   , p_vc_docu_type
                   , p_vc_docu_content
                   , p_vc_docu_url
                   , p_vc_docu_desc
                  );

      COMMIT;
   END prc_save_document;
/**
* Package initialization
*/
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_docu;
2014-11-28 13:53:21.209 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/docu/docu-impl.sql executed
2014-11-28 13:53:21.210 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/mesr/mesr-def.sql delimiter 
2014-11-28 13:53:21.211 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#mesr
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_mesr_taxn_ins (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );

   PROCEDURE prc_mesr_taxn_del (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );

   PROCEDURE prc_query_ins (
      p_vc_query_code   IN VARCHAR2
    , p_vc_query_name   IN VARCHAR2
    , p_vc_query_sql    IN CLOB
   );

   PROCEDURE prc_query_del (
      p_vc_query_code   IN VARCHAR2
    , p_b_cascade       IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_keyfigure_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_keyfigure_name   IN VARCHAR2
   );

   PROCEDURE prc_keyfigure_del (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_b_cascade           IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_threshold_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_threshold_type   IN VARCHAR2
    , p_n_threshold_min     IN NUMBER
    , p_n_threshold_max     IN NUMBER
    , p_d_threshold_from    IN DATE DEFAULT TO_DATE (
                                               '01011111'
                                             , 'ddmmyyyy'
                                            )
    , p_d_threshold_to      IN DATE DEFAULT TO_DATE (
                                               '09099999'
                                             , 'ddmmyyyy'
                                            )
   );

   PROCEDURE prc_exec_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_n_result_value      IN NUMBER
    , p_vc_result_report    IN CLOB
   );

   PROCEDURE prc_exec (
      p_vc_query_code          IN VARCHAR2 DEFAULT 'ALL'
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   );

   PROCEDURE prc_exec_taxonomy (
      p_vc_taxonomy_code       IN VARCHAR2
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   );
END p#frm#mesr;
2014-11-28 13:53:21.211 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_mesr
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_mesr_taxn_ins (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );

   PROCEDURE prc_mesr_taxn_del (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   );

   PROCEDURE prc_query_ins (
      p_vc_query_code   IN VARCHAR2
    , p_vc_query_name   IN VARCHAR2
    , p_vc_query_sql    IN CLOB
   );

   PROCEDURE prc_query_del (
      p_vc_query_code   IN VARCHAR2
    , p_b_cascade       IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_keyfigure_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_keyfigure_name   IN VARCHAR2
   );

   PROCEDURE prc_keyfigure_del (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_b_cascade           IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_threshold_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_threshold_type   IN VARCHAR2
    , p_n_threshold_min     IN NUMBER
    , p_n_threshold_max     IN NUMBER
    , p_d_threshold_from    IN DATE DEFAULT TO_DATE (
                                               '01011111'
                                             , 'ddmmyyyy'
                                            )
    , p_d_threshold_to      IN DATE DEFAULT TO_DATE (
                                               '09099999'
                                             , 'ddmmyyyy'
                                            )
   );

   PROCEDURE prc_exec_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_n_result_value      IN NUMBER
    , p_vc_result_report    IN CLOB
   );

   PROCEDURE prc_exec (
      p_vc_query_code          IN VARCHAR2 DEFAULT 'ALL'
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   );

   PROCEDURE prc_exec_taxonomy (
      p_vc_taxonomy_code       IN VARCHAR2
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   );
END dwhutl_mesr;
2014-11-28 13:53:21.223 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/mesr/mesr-def.sql executed
2014-11-28 13:53:21.223 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/mesr/mesr-impl.sql delimiter 
2014-11-28 13:53:21.224 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#mesr
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * Key value type
   */
   TYPE r_keyvalue IS RECORD (
      keyfigure     VARCHAR2 (100)
    , resultvalue   NUMBER
   );

   TYPE t_keyvalue IS TABLE OF r_keyvalue;

   FUNCTION fct_exec_verify (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_n_exec_value        IN NUMBER
   )
      RETURN BOOLEAN
   IS
      l_vc_prc_name         t_object_name := 'FCT_EXEC_VERIFY';
      l_n_keyfigure_id      NUMBER;
      l_vc_threshold_type   CHAR (1);
      l_n_threshold_min     NUMBER;
      l_n_threshold_max     NUMBER;
      l_n_result_previous   NUMBER;
      l_n_increment         NUMBER;
      l_n_cnt               NUMBER := 0;
      l_b_success           BOOLEAN := TRUE;
   BEGIN
      SELECT MIN (k.mesr_keyfigure_id)
           , MIN (t.mesr_threshold_type)
           , MIN (t.mesr_threshold_min)
           , MAX (t.mesr_threshold_max)
        INTO l_n_keyfigure_id
           , l_vc_threshold_type
           , l_n_threshold_min
           , l_n_threshold_max
        FROM p#frm#mesr_query_t s
           , p#frm#mesr_keyfigure_t k
           , p#frm#mesr_threshold_t t
       WHERE s.mesr_query_id = k.mesr_query_id
         AND t.mesr_keyfigure_id = k.mesr_keyfigure_id
         AND s.mesr_query_code = p_vc_query_code
         AND k.mesr_keyfigure_code = p_vc_keyfigure_code
         AND t.mesr_threshold_from <= SYSDATE
         AND SYSDATE < t.mesr_threshold_to;

      p#frm#trac.log_sub_info (
            'Key figure '
         || p_vc_keyfigure_code
         || ' type '
         || l_vc_threshold_type
         || ' threshold = '
         || l_n_threshold_min
         || ' - '
         || l_n_threshold_max
       , 'VERIFYING'
      );

      IF l_vc_threshold_type = 'A' THEN
         IF l_n_threshold_min IS NOT NULL
        AND l_n_threshold_max IS NOT NULL
        AND p_n_exec_value NOT BETWEEN l_n_threshold_min AND l_n_threshold_max THEN
            l_b_success := FALSE;
            p#frm#trac.log_sub_info (
                  'Result '
               || p_n_exec_value
               || ' not ok'
             , 'RESULT NOT OK'
            );
         ELSE
            p#frm#trac.log_sub_info (
                  'Result '
               || p_n_exec_value
               || ' ok'
             , 'RESULT OK'
            );
         END IF;
      ELSIF l_vc_threshold_type = 'I' THEN
         SELECT COUNT (*)
           INTO l_n_cnt
           FROM p#frm#mesr_exec_t
          WHERE mesr_keyfigure_id = l_n_keyfigure_id;

         IF l_n_cnt > 0 THEN
            SELECT MAX (NVL (mesr_exec_result_value, 0))
              INTO l_n_result_previous
              FROM (SELECT mesr_exec_id
                         , mesr_exec_result_value
                         , MAX (mesr_exec_id) OVER (PARTITION BY mesr_keyfigure_id) AS mesr_exec_last
                      FROM p#frm#mesr_exec_t
                     WHERE mesr_keyfigure_id = l_n_keyfigure_id)
             WHERE mesr_exec_id = mesr_exec_last;

            p#frm#trac.log_sub_info (
                  'Previous result = '
               || l_n_result_previous
             , 'VERIFYING INCREMENT'
            );

            IF l_n_result_previous > 0 THEN
               l_n_increment :=
                    (  p_n_exec_value
                     - l_n_result_previous)
                  / l_n_result_previous;

               IF l_n_threshold_min IS NOT NULL
              AND l_n_threshold_max IS NOT NULL
              AND l_n_increment NOT BETWEEN l_n_threshold_min AND l_n_threshold_max THEN
                  l_b_success := FALSE;
                  p#frm#trac.log_sub_info (
                        'Increment '
                     || l_n_increment
                     || ' not ok'
                   , 'RESULT NOT OK'
                  );
               ELSE
                  p#frm#trac.log_sub_info (
                        'Increment '
                     || l_n_increment
                     || ' ok'
                   , 'RESULT OK'
                  );
               END IF;
            ELSE
               p#frm#trac.log_sub_info (
                     'Previous result = '
                  || l_n_result_previous
                , 'RESULT OK'
               );
            END IF;
         ELSE
            p#frm#trac.log_sub_info (
                  'Key figure '
               || p_vc_keyfigure_code
               || ' type '
               || l_vc_threshold_type
               || ' - no previous results available'
             , 'RESULT OK'
            );
         END IF;
      END IF;

      RETURN l_b_success;
   END fct_exec_verify;

   PROCEDURE prc_mesr_taxn_ins (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_mesr_TAXONOMY_INS';
   BEGIN
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Inserting in mesr_case_taxonomy_t'
      );

      MERGE INTO p#frm#mesr_taxn_t trg
           USING (SELECT mesr_query_id
                       , taxn_id
                    FROM p#frm#mesr_query_t c
                       , p#frm#taxn_t t
                   WHERE c.mesr_query_code = p_vc_query_code
                     AND t.taxn_code = p_vc_taxonomy_code) src
              ON (trg.mesr_query_id = src.mesr_query_id
              AND trg.taxn_id = src.taxn_id)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.mesr_query_id
                     , trg.taxn_id
                    )
             VALUES (
                       src.mesr_query_id
                     , src.taxn_id
                    );

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows merged'
      );
      COMMIT;
   END prc_mesr_taxn_ins;

   PROCEDURE prc_mesr_taxn_del (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_CASE_TAXONOMY_DEL';
   BEGIN
      p#frm#trac.log_sub_info (
         'Deleting in mesr_case_taxonomy_t'
       , l_vc_prc_name
      );

      DELETE p#frm#mesr_taxn_t
       WHERE mesr_query_id = (SELECT mesr_query_id
                                FROM p#frm#mesr_query_t
                               WHERE mesr_query_code = p_vc_query_code)
         AND taxn_id = (SELECT taxn_id
                          FROM p#frm#taxn_t
                         WHERE taxn_code = p_vc_taxonomy_code);

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows deleted'
      );
      COMMIT;
   END prc_mesr_taxn_del;

   PROCEDURE prc_query_ins (
      p_vc_query_code   IN VARCHAR2
    , p_vc_query_name   IN VARCHAR2
    , p_vc_query_sql    IN CLOB
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_query_INS';
   BEGIN
      MERGE INTO p#frm#mesr_query_t trg
           USING (SELECT p_vc_query_code AS query_code
                       , p_vc_query_name AS query_name
                       , p_vc_query_sql AS query_sql
                    FROM DUAL) src
              ON (trg.mesr_query_code = src.query_code)
      WHEN MATCHED THEN
         UPDATE SET trg.mesr_query_name = NVL (src.query_name, trg.mesr_query_name)
                  , trg.mesr_query_sql = NVL (src.query_sql, trg.mesr_query_sql)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.mesr_query_code
                     , trg.mesr_query_name
                     , trg.mesr_query_sql
                    )
             VALUES (
                       src.query_code
                     , src.query_name
                     , src.query_sql
                    );

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows merged'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_query_ins;

   PROCEDURE prc_query_del (
      p_vc_query_code   IN VARCHAR2
    , p_b_cascade       IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_query_DEL';
      l_n_query_id    NUMBER;
      l_n_cnt         NUMBER;
   BEGIN
      -- Get the query id
      SELECT mesr_query_id
        INTO l_n_query_id
        FROM p#frm#mesr_query_t
       WHERE mesr_query_code = p_vc_query_code;

      IF NOT p_b_cascade THEN
         SELECT COUNT (*)
           INTO l_n_cnt
           FROM p#frm#mesr_keyfigure_t
          WHERE mesr_query_id = l_n_query_id;

         IF l_n_cnt > 0 THEN
            raise_application_error (
               -20001
             , 'Cannot delete query with key figures'
            );
         END IF;
      END IF;

      FOR r_key IN (SELECT mesr_keyfigure_code
                      FROM p#frm#mesr_keyfigure_t
                     WHERE mesr_query_id = l_n_query_id) LOOP
         prc_keyfigure_del (
            p_vc_query_code
          , r_key.mesr_keyfigure_code
          , p_b_cascade
         );
      END LOOP;

      DELETE p#frm#mesr_query_t
       WHERE mesr_query_id = l_n_query_id;

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_query_del;

   PROCEDURE prc_keyfigure_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_keyfigure_name   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_KEYFIGURE_INS';
   BEGIN
      MERGE INTO p#frm#mesr_keyfigure_t trg
           USING (SELECT s.mesr_query_id
                       , p_vc_keyfigure_code AS keyfigure_code
                       , p_vc_keyfigure_name AS keyfigure_name
                    FROM p#frm#mesr_query_t s
                   WHERE s.mesr_query_code = p_vc_query_code) src
              ON (trg.mesr_query_id = src.mesr_query_id
              AND trg.mesr_keyfigure_code = src.keyfigure_code)
      WHEN MATCHED THEN
         UPDATE SET trg.mesr_keyfigure_name = NVL (src.keyfigure_name, trg.mesr_keyfigure_name)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.mesr_query_id
                     , trg.mesr_keyfigure_code
                     , trg.mesr_keyfigure_name
                    )
             VALUES (
                       src.mesr_query_id
                     , src.keyfigure_code
                     , src.keyfigure_name
                    );

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows merged'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_keyfigure_ins;

   PROCEDURE prc_keyfigure_del (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_b_cascade           IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name      t_object_name := 'PRC_KEYFIGURE_DEL';
      l_n_keyfigure_id   NUMBER;
      l_n_cnt            NUMBER;
   BEGIN
      -- Get the key figure id
      SELECT k.mesr_keyfigure_id
        INTO l_n_keyfigure_id
        FROM p#frm#mesr_query_t s
           , p#frm#mesr_keyfigure_t k
       WHERE s.mesr_query_id = k.mesr_query_id
         AND s.mesr_query_code = p_vc_query_code
         AND k.mesr_keyfigure_code = p_vc_keyfigure_code;

      IF NOT p_b_cascade THEN
         SELECT COUNT (*)
           INTO l_n_cnt
           FROM p#frm#mesr_exec_t
          WHERE mesr_keyfigure_id = l_n_keyfigure_id;

         IF l_n_cnt > 0 THEN
            raise_application_error (
               -20001
             , 'Cannot delete key figure with execution results'
            );
         END IF;
      END IF;

      DELETE p#frm#mesr_exec_t
       WHERE mesr_keyfigure_id = l_n_keyfigure_id;

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );

      DELETE p#frm#mesr_threshold_t
       WHERE mesr_keyfigure_id = l_n_keyfigure_id;

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );

      DELETE p#frm#mesr_keyfigure_t
       WHERE mesr_keyfigure_id = l_n_keyfigure_id;

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_keyfigure_del;

   PROCEDURE prc_threshold_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_threshold_type   IN VARCHAR2
    , p_n_threshold_min     IN NUMBER
    , p_n_threshold_max     IN NUMBER
    , p_d_threshold_from    IN DATE DEFAULT TO_DATE (
                                               '01011111'
                                             , 'ddmmyyyy'
                                            )
    , p_d_threshold_to      IN DATE DEFAULT TO_DATE (
                                               '09099999'
                                             , 'ddmmyyyy'
                                            )
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_THRESHOLD_INS';
      l_d_threshold_from   DATE
                              := NVL (
                                    p_d_threshold_from
                                  , TO_DATE (
                                       '01011111'
                                     , 'ddmmyyyy'
                                    )
                                 );
      l_d_threshold_to     DATE
                              := NVL (
                                    p_d_threshold_to
                                  , TO_DATE (
                                       '09099999'
                                     , 'ddmmyyyy'
                                    )
                                 );
      l_n_keyfigure_id     NUMBER;
      l_n_threshold_id     NUMBER;
      l_n_split_flag       NUMBER;
      l_n_split_min        NUMBER;
      l_n_split_max        NUMBER;
   BEGIN
      -- Get the key figure id
      SELECT k.mesr_keyfigure_id
        INTO l_n_keyfigure_id
        FROM p#frm#mesr_query_t s
           , p#frm#mesr_keyfigure_t k
       WHERE s.mesr_query_id = k.mesr_query_id
         AND s.mesr_query_code = p_vc_query_code
         AND k.mesr_keyfigure_code = p_vc_keyfigure_code;

      IF l_n_keyfigure_id IS NOT NULL THEN
         -- Delete existing time slices if they reside between new boundary
         DELETE p#frm#mesr_threshold_t
          WHERE mesr_keyfigure_id = l_n_keyfigure_id
            AND mesr_threshold_from > l_d_threshold_from
            AND mesr_threshold_to < l_d_threshold_to;

         p#frm#trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows deleted'
          , l_vc_prc_name
         );

         -- If new slice inside existing then split
         INSERT INTO p#frm#mesr_threshold_t (
                        mesr_keyfigure_id
                      , mesr_threshold_type
                      , mesr_threshold_min
                      , mesr_threshold_max
                      , mesr_threshold_from
                      , mesr_threshold_to
                     )
            SELECT mesr_keyfigure_id
                 , mesr_threshold_type
                 , mesr_threshold_min
                 , mesr_threshold_max
                 , l_d_threshold_to
                 , mesr_threshold_to
              FROM p#frm#mesr_threshold_t
             WHERE mesr_keyfigure_id = l_n_keyfigure_id
               AND mesr_threshold_from < l_d_threshold_from
               AND mesr_threshold_to > l_d_threshold_to;

         p#frm#trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows inserted'
          , l_vc_prc_name
         );

         -- Update existing time slice where upper bound > new lower bound
         UPDATE p#frm#mesr_threshold_t
            SET mesr_threshold_to = l_d_threshold_from
          WHERE mesr_keyfigure_id = l_n_keyfigure_id
            AND mesr_threshold_from < l_d_threshold_from
            AND mesr_threshold_to > l_d_threshold_from;

         p#frm#trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows updated'
          , l_vc_prc_name
         );

         -- Update existing time slice where lower bound < new upper bound
         UPDATE p#frm#mesr_threshold_t
            SET mesr_threshold_from = l_d_threshold_to
          WHERE mesr_keyfigure_id = l_n_keyfigure_id
            AND mesr_threshold_to > l_d_threshold_to
            AND mesr_threshold_from < l_d_threshold_to;

         p#frm#trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows updated'
          , l_vc_prc_name
         );

            -- Update time slice with same boundary
            UPDATE p#frm#mesr_threshold_t
               SET mesr_threshold_type = p_vc_threshold_type
                 , mesr_threshold_min = p_n_threshold_min
                 , mesr_threshold_max = p_n_threshold_max
             WHERE mesr_keyfigure_id = l_n_keyfigure_id
               AND mesr_threshold_from = l_d_threshold_from
               AND mesr_threshold_to = l_d_threshold_to
         RETURNING mesr_threshold_id
              INTO l_n_threshold_id;

         p#frm#trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows updated'
          , l_vc_prc_name
         );

         IF l_n_threshold_id IS NULL THEN
            INSERT INTO p#frm#mesr_threshold_t (
                           mesr_keyfigure_id
                         , mesr_threshold_type
                         , mesr_threshold_min
                         , mesr_threshold_max
                         , mesr_threshold_from
                         , mesr_threshold_to
                        )
                 VALUES (
                           l_n_keyfigure_id
                         , p_vc_threshold_type
                         , p_n_threshold_min
                         , p_n_threshold_max
                         , l_d_threshold_from
                         , l_d_threshold_to
                        );

            p#frm#trac.log_sub_info (
                  SQL%ROWCOUNT
               || ' rows inserted'
             , l_vc_prc_name
            );
         END IF;

         COMMIT;
      END IF;
   END prc_threshold_ins;

   PROCEDURE prc_exec_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_n_result_value      IN NUMBER
    , p_vc_result_report    IN CLOB
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_EXEC_INS';
   BEGIN
      INSERT INTO p#frm#mesr_exec_t (
                     mesr_keyfigure_id
                   , mesr_exec_result_value
                   , mesr_exec_result_report
                  )
         SELECT k.mesr_keyfigure_id
              , p_n_result_value
              , p_vc_result_report
           FROM p#frm#mesr_query_t s
              , p#frm#mesr_keyfigure_t k
          WHERE s.mesr_query_id = k.mesr_query_id
            AND s.mesr_query_code = p_vc_query_code
            AND k.mesr_keyfigure_code = p_vc_keyfigure_code;

      p#frm#trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows inserted'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_exec_ins;

   PROCEDURE prc_exec (
      p_vc_query_code          IN VARCHAR2 DEFAULT 'ALL'
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   )
   IS
      l_vc_prc_name       t_object_name := 'PRC_EXEC';
      l_keyfigure         t_keyvalue;
      l_vc_query_table    VARCHAR2 (100);
      l_vc_stmt           VARCHAR2 (32000);
      l_vc_report         CLOB;
      l_vc_job_name       VARCHAR2 (100);
      l_n_gui             NUMBER;
      l_n_query_no        NUMBER;
      l_n_result          NUMBER;
      l_n_threshold_min   NUMBER;
      l_n_threshold_max   NUMBER;
      l_b_success         BOOLEAN := TRUE;
   BEGIN
      p#frm#trac.log_sub_info (
            'Execute case query '
         || p_vc_query_code
       , 'Query START'
      );
      p#frm#trac.log_sub_info (
            'Results will be stored as '
         || p_vc_storage_type
       ,    'STORAGE '
         || p_vc_storage_type
      );

      FOR r_query IN (  SELECT s.mesr_query_id
                             , s.mesr_query_code
                             , s.mesr_query_sql
                          FROM p#frm#mesr_query_t s
                         WHERE (p_vc_query_code IN (s.mesr_query_code, 'ALL')
                             OR p_vc_query_code IS NULL)
                      ORDER BY s.mesr_query_code) LOOP
         p#frm#trac.log_sub_info (
               'query '
            || r_query.mesr_query_code
          , 'query START'
         );

         BEGIN
            IF p_vc_storage_type = 'VALUE'
            OR p_vc_storage_type IS NULL THEN
               EXECUTE IMMEDIATE r_query.mesr_query_sql BULK COLLECT INTO l_keyfigure;

               p#frm#trac.log_sub_info (
                     'query '
                  || r_query.mesr_query_code
                  || ': SQL executed '
                , 'SQL EXECUTED'
               );

               IF l_keyfigure.FIRST IS NOT NULL THEN
                  FOR i IN l_keyfigure.FIRST .. l_keyfigure.LAST LOOP
                     prc_keyfigure_ins (
                        r_query.mesr_query_code
                      , l_keyfigure (i).keyfigure
                      , l_keyfigure (i).keyfigure
                     );

                     IF p_b_exception_if_fails THEN
                        l_b_success :=
                           fct_exec_verify (
                              r_query.mesr_query_code
                            , l_keyfigure (i).keyfigure
                            , l_keyfigure (i).resultvalue
                           );
                     END IF;

                     prc_exec_ins (
                        r_query.mesr_query_code
                      , l_keyfigure (i).keyfigure
                      , l_keyfigure (i).resultvalue
                      , NULL
                     );
                     p#frm#trac.log_sub_info (
                           'Key figure '
                        || l_keyfigure (i).keyfigure
                        || ' = '
                        || l_keyfigure (i).resultvalue
                        || ' , result stored'
                      , 'KEY FIGURE STORED'
                     );
                  END LOOP;
               ELSE
                  p#frm#trac.log_sub_info (
                        'query '
                     || r_query.mesr_query_code
                     || ': no rows returned '
                   , 'NO RESULTS'
                  );
               END IF;
            ELSIF p_vc_storage_type = 'REPORT' THEN
               l_vc_query_table :=
                     'tmp_mesr_query_'
                  || TRIM (TO_CHAR (
                              r_query.mesr_query_id
                            , '0000000000'
                           ));

               BEGIN
                  l_vc_stmt :=
                        'DROP TABLE '
                     || l_vc_query_table;

                  EXECUTE IMMEDIATE l_vc_stmt;
               EXCEPTION
                  WHEN OTHERS THEN
                     NULL;
               END;

               l_vc_stmt :=
                     'CREATE TABLE '
                  || l_vc_query_table
                  || ' AS '
                  || r_query.mesr_query_sql;

               EXECUTE IMMEDIATE l_vc_stmt;

               p#frm#trac.log_sub_info (
                     'query '
                  || r_query.mesr_query_code
                  || ': Table created '
                , 'SQL EXECUTED'
               );
               l_vc_report :=
                  p#frm#docu.fct_get_table_dataset (
                     USER
                   , l_vc_query_table
                  );
               prc_keyfigure_ins (
                  r_query.mesr_query_code
                , 'REPORT'
                , 'REPORT'
               );
               prc_exec_ins (
                  r_query.mesr_query_code
                , 'REPORT'
                , NULL
                , l_vc_report
               );
               p#frm#trac.log_sub_info (
                  'Report stored'
                , 'REPORT STORED'
               );
            END IF;
         EXCEPTION
            WHEN OTHERS THEN
               p#frm#trac.log_error (
                     'query '
                  || r_query.mesr_query_code
                  || ': '
                  || SQLERRM
                , 'ERROR'
               );
         END;

         p#frm#trac.log_sub_info (
               'query '
            || r_query.mesr_query_code
          , 'query FINISH'
         );
      END LOOP;

      p#frm#trac.log_sub_info (
            'Execute query '
         || p_vc_query_code
         || ' : success '
         || CASE
               WHEN l_b_success THEN
                  'TRUE'
               ELSE
                  'FALSE'
            END
       , 'CASE FINISH'
      );

      IF p_b_exception_if_fails
     AND NOT l_b_success THEN
         raise_application_error (
            -20001
          , 'Test failed'
         );
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_error (
               'query '
            || p_vc_query_code
            || ' : failed'
          , 'QUERY ERROR'
         );
         RAISE;
   END;

   PROCEDURE prc_exec_taxonomy (
      p_vc_taxonomy_code       IN VARCHAR2
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_EXEC_TAXONOMY';
   BEGIN
      p#frm#trac.log_sub_info (
            'Executing all cases belonging to taxonomy '
         || p_vc_taxonomy_code
         || ' and its children'
       , l_vc_prc_name
      );

      FOR r_tax IN (    SELECT taxn_id
                             , taxn_name
                             , SYS_CONNECT_BY_PATH (
                                  taxn_code
                                , '/'
                               )
                                  taxn_path
                          FROM p#frm#taxn_t
                    START WITH taxn_code = p_vc_taxonomy_code
                    CONNECT BY PRIOR taxn_id = taxn_parent_id) LOOP
         p#frm#trac.log_sub_info (
               'Executing all cases belonging to taxonomy '
            || r_tax.taxn_path
          , l_vc_prc_name
         );

         FOR r_query IN (SELECT c.mesr_query_code
                           FROM p#frm#mesr_taxn_t t
                              , p#frm#mesr_query_t c
                          WHERE t.mesr_query_id = c.mesr_query_id
                            AND t.taxn_id = r_tax.taxn_id) LOOP
            prc_exec (
               r_query.mesr_query_code
             , p_b_exception_if_fails
             , p_vc_storage_type
            );
         END LOOP;

         p#frm#trac.log_sub_info (
               'All cases belonging to taxonomy '
            || r_tax.taxn_path
            || ' have been executed'
          , l_vc_prc_name
         );
      END LOOP;

      p#frm#trac.log_sub_info (
            'All cases belonging to taxonomy '
         || p_vc_taxonomy_code
         || ' and its children have been executed'
       , l_vc_prc_name
      );
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#mesr;
2014-11-28 13:53:21.225 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_mesr
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * Key value type
   */
   TYPE r_keyvalue IS RECORD (
      keyfigure     VARCHAR2 (100)
    , resultvalue   NUMBER
   );

   TYPE t_keyvalue IS TABLE OF r_keyvalue;

   FUNCTION fct_exec_verify (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_n_exec_value        IN NUMBER
   )
      RETURN BOOLEAN
   IS
      l_vc_prc_name         t_object_name := 'FCT_EXEC_VERIFY';
      l_n_keyfigure_id      NUMBER;
      l_vc_threshold_type   CHAR (1);
      l_n_threshold_min     NUMBER;
      l_n_threshold_max     NUMBER;
      l_n_result_previous   NUMBER;
      l_n_increment         NUMBER;
      l_n_cnt               NUMBER := 0;
      l_b_success           BOOLEAN := TRUE;
   BEGIN
      SELECT MIN (k.mesr_keyfigure_id)
           , MIN (t.mesr_threshold_type)
           , MIN (t.mesr_threshold_min)
           , MAX (t.mesr_threshold_max)
        INTO l_n_keyfigure_id
           , l_vc_threshold_type
           , l_n_threshold_min
           , l_n_threshold_max
        FROM dwhutl_mesr_query_t s
           , dwhutl_mesr_keyfigure_t k
           , dwhutl_mesr_threshold_t t
       WHERE s.mesr_query_id = k.mesr_query_id
         AND t.mesr_keyfigure_id = k.mesr_keyfigure_id
         AND s.mesr_query_code = p_vc_query_code
         AND k.mesr_keyfigure_code = p_vc_keyfigure_code
         AND t.mesr_threshold_from <= SYSDATE
         AND SYSDATE < t.mesr_threshold_to;

      dwhutl_trac.log_sub_info (
            'Key figure '
         || p_vc_keyfigure_code
         || ' type '
         || l_vc_threshold_type
         || ' threshold = '
         || l_n_threshold_min
         || ' - '
         || l_n_threshold_max
       , 'VERIFYING'
      );

      IF l_vc_threshold_type = 'A' THEN
         IF l_n_threshold_min IS NOT NULL
        AND l_n_threshold_max IS NOT NULL
        AND p_n_exec_value NOT BETWEEN l_n_threshold_min AND l_n_threshold_max THEN
            l_b_success := FALSE;
            dwhutl_trac.log_sub_info (
                  'Result '
               || p_n_exec_value
               || ' not ok'
             , 'RESULT NOT OK'
            );
         ELSE
            dwhutl_trac.log_sub_info (
                  'Result '
               || p_n_exec_value
               || ' ok'
             , 'RESULT OK'
            );
         END IF;
      ELSIF l_vc_threshold_type = 'I' THEN
         SELECT COUNT (*)
           INTO l_n_cnt
           FROM dwhutl_mesr_exec_t
          WHERE mesr_keyfigure_id = l_n_keyfigure_id;

         IF l_n_cnt > 0 THEN
            SELECT MAX (NVL (mesr_exec_result_value, 0))
              INTO l_n_result_previous
              FROM (SELECT mesr_exec_id
                         , mesr_exec_result_value
                         , MAX (mesr_exec_id) OVER (PARTITION BY mesr_keyfigure_id) AS mesr_exec_last
                      FROM dwhutl_mesr_exec_t
                     WHERE mesr_keyfigure_id = l_n_keyfigure_id)
             WHERE mesr_exec_id = mesr_exec_last;

            dwhutl_trac.log_sub_info (
                  'Previous result = '
               || l_n_result_previous
             , 'VERIFYING INCREMENT'
            );

            IF l_n_result_previous > 0 THEN
               l_n_increment :=
                    (  p_n_exec_value
                     - l_n_result_previous)
                  / l_n_result_previous;

               IF l_n_threshold_min IS NOT NULL
              AND l_n_threshold_max IS NOT NULL
              AND l_n_increment NOT BETWEEN l_n_threshold_min AND l_n_threshold_max THEN
                  l_b_success := FALSE;
                  dwhutl_trac.log_sub_info (
                        'Increment '
                     || l_n_increment
                     || ' not ok'
                   , 'RESULT NOT OK'
                  );
               ELSE
                  dwhutl_trac.log_sub_info (
                        'Increment '
                     || l_n_increment
                     || ' ok'
                   , 'RESULT OK'
                  );
               END IF;
            ELSE
               dwhutl_trac.log_sub_info (
                     'Previous result = '
                  || l_n_result_previous
                , 'RESULT OK'
               );
            END IF;
         ELSE
            dwhutl_trac.log_sub_info (
                  'Key figure '
               || p_vc_keyfigure_code
               || ' type '
               || l_vc_threshold_type
               || ' - no previous results available'
             , 'RESULT OK'
            );
         END IF;
      END IF;

      RETURN l_b_success;
   END fct_exec_verify;

   PROCEDURE prc_mesr_taxn_ins (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_mesr_TAXONOMY_INS';
   BEGIN
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Inserting in mesr_case_taxonomy_t'
      );

      MERGE INTO dwhutl_mesr_taxn_t trg
           USING (SELECT mesr_query_id
                       , taxn_id
                    FROM dwhutl_mesr_query_t c
                       , dwhutl_taxn_t t
                   WHERE c.mesr_query_code = p_vc_query_code
                     AND t.taxn_code = p_vc_taxonomy_code) src
              ON (trg.mesr_query_id = src.mesr_query_id
              AND trg.taxn_id = src.taxn_id)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.mesr_query_id
                     , trg.taxn_id
                    )
             VALUES (
                       src.mesr_query_id
                     , src.taxn_id
                    );

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows merged'
      );
      COMMIT;
   END prc_mesr_taxn_ins;

   PROCEDURE prc_mesr_taxn_del (
      p_vc_query_code      IN VARCHAR2
    , p_vc_taxonomy_code   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_CASE_TAXONOMY_DEL';
   BEGIN
      dwhutl_trac.log_sub_info (
         'Deleting in mesr_case_taxonomy_t'
       , l_vc_prc_name
      );

      DELETE dwhutl_mesr_taxn_t
       WHERE mesr_query_id = (SELECT mesr_query_id
                                FROM dwhutl_mesr_query_t
                               WHERE mesr_query_code = p_vc_query_code)
         AND taxn_id = (SELECT taxn_id
                          FROM dwhutl_taxn_t
                         WHERE taxn_code = p_vc_taxonomy_code);

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       ,    SQL%ROWCOUNT
         || ' rows deleted'
      );
      COMMIT;
   END prc_mesr_taxn_del;

   PROCEDURE prc_query_ins (
      p_vc_query_code   IN VARCHAR2
    , p_vc_query_name   IN VARCHAR2
    , p_vc_query_sql    IN CLOB
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_query_INS';
   BEGIN
      MERGE INTO dwhutl_mesr_query_t trg
           USING (SELECT p_vc_query_code AS query_code
                       , p_vc_query_name AS query_name
                       , p_vc_query_sql AS query_sql
                    FROM DUAL) src
              ON (trg.mesr_query_code = src.query_code)
      WHEN MATCHED THEN
         UPDATE SET trg.mesr_query_name = NVL (src.query_name, trg.mesr_query_name)
                  , trg.mesr_query_sql = NVL (src.query_sql, trg.mesr_query_sql)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.mesr_query_code
                     , trg.mesr_query_name
                     , trg.mesr_query_sql
                    )
             VALUES (
                       src.query_code
                     , src.query_name
                     , src.query_sql
                    );

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows merged'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_query_ins;

   PROCEDURE prc_query_del (
      p_vc_query_code   IN VARCHAR2
    , p_b_cascade       IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_query_DEL';
      l_n_query_id    NUMBER;
      l_n_cnt         NUMBER;
   BEGIN
      -- Get the query id
      SELECT mesr_query_id
        INTO l_n_query_id
        FROM dwhutl_mesr_query_t
       WHERE mesr_query_code = p_vc_query_code;

      IF NOT p_b_cascade THEN
         SELECT COUNT (*)
           INTO l_n_cnt
           FROM dwhutl_mesr_keyfigure_t
          WHERE mesr_query_id = l_n_query_id;

         IF l_n_cnt > 0 THEN
            raise_application_error (
               -20001
             , 'Cannot delete query with key figures'
            );
         END IF;
      END IF;

      FOR r_key IN (SELECT mesr_keyfigure_code
                      FROM dwhutl_mesr_keyfigure_t
                     WHERE mesr_query_id = l_n_query_id) LOOP
         prc_keyfigure_del (
            p_vc_query_code
          , r_key.mesr_keyfigure_code
          , p_b_cascade
         );
      END LOOP;

      DELETE dwhutl_mesr_query_t
       WHERE mesr_query_id = l_n_query_id;

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_query_del;

   PROCEDURE prc_keyfigure_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_keyfigure_name   IN VARCHAR2
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_KEYFIGURE_INS';
   BEGIN
      MERGE INTO dwhutl_mesr_keyfigure_t trg
           USING (SELECT s.mesr_query_id
                       , p_vc_keyfigure_code AS keyfigure_code
                       , p_vc_keyfigure_name AS keyfigure_name
                    FROM dwhutl_mesr_query_t s
                   WHERE s.mesr_query_code = p_vc_query_code) src
              ON (trg.mesr_query_id = src.mesr_query_id
              AND trg.mesr_keyfigure_code = src.keyfigure_code)
      WHEN MATCHED THEN
         UPDATE SET trg.mesr_keyfigure_name = NVL (src.keyfigure_name, trg.mesr_keyfigure_name)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.mesr_query_id
                     , trg.mesr_keyfigure_code
                     , trg.mesr_keyfigure_name
                    )
             VALUES (
                       src.mesr_query_id
                     , src.keyfigure_code
                     , src.keyfigure_name
                    );

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows merged'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_keyfigure_ins;

   PROCEDURE prc_keyfigure_del (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_b_cascade           IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name      t_object_name := 'PRC_KEYFIGURE_DEL';
      l_n_keyfigure_id   NUMBER;
      l_n_cnt            NUMBER;
   BEGIN
      -- Get the key figure id
      SELECT k.mesr_keyfigure_id
        INTO l_n_keyfigure_id
        FROM dwhutl_mesr_query_t s
           , dwhutl_mesr_keyfigure_t k
       WHERE s.mesr_query_id = k.mesr_query_id
         AND s.mesr_query_code = p_vc_query_code
         AND k.mesr_keyfigure_code = p_vc_keyfigure_code;

      IF NOT p_b_cascade THEN
         SELECT COUNT (*)
           INTO l_n_cnt
           FROM dwhutl_mesr_exec_t
          WHERE mesr_keyfigure_id = l_n_keyfigure_id;

         IF l_n_cnt > 0 THEN
            raise_application_error (
               -20001
             , 'Cannot delete key figure with execution results'
            );
         END IF;
      END IF;

      DELETE dwhutl_mesr_exec_t
       WHERE mesr_keyfigure_id = l_n_keyfigure_id;

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );

      DELETE dwhutl_mesr_threshold_t
       WHERE mesr_keyfigure_id = l_n_keyfigure_id;

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );

      DELETE dwhutl_mesr_keyfigure_t
       WHERE mesr_keyfigure_id = l_n_keyfigure_id;

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows deleted'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_keyfigure_del;

   PROCEDURE prc_threshold_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_vc_threshold_type   IN VARCHAR2
    , p_n_threshold_min     IN NUMBER
    , p_n_threshold_max     IN NUMBER
    , p_d_threshold_from    IN DATE DEFAULT TO_DATE (
                                               '01011111'
                                             , 'ddmmyyyy'
                                            )
    , p_d_threshold_to      IN DATE DEFAULT TO_DATE (
                                               '09099999'
                                             , 'ddmmyyyy'
                                            )
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_THRESHOLD_INS';
      l_d_threshold_from   DATE
                              := NVL (
                                    p_d_threshold_from
                                  , TO_DATE (
                                       '01011111'
                                     , 'ddmmyyyy'
                                    )
                                 );
      l_d_threshold_to     DATE
                              := NVL (
                                    p_d_threshold_to
                                  , TO_DATE (
                                       '09099999'
                                     , 'ddmmyyyy'
                                    )
                                 );
      l_n_keyfigure_id     NUMBER;
      l_n_threshold_id     NUMBER;
      l_n_split_flag       NUMBER;
      l_n_split_min        NUMBER;
      l_n_split_max        NUMBER;
   BEGIN
      -- Get the key figure id
      SELECT k.mesr_keyfigure_id
        INTO l_n_keyfigure_id
        FROM dwhutl_mesr_query_t s
           , dwhutl_mesr_keyfigure_t k
       WHERE s.mesr_query_id = k.mesr_query_id
         AND s.mesr_query_code = p_vc_query_code
         AND k.mesr_keyfigure_code = p_vc_keyfigure_code;

      IF l_n_keyfigure_id IS NOT NULL THEN
         -- Delete existing time slices if they reside between new boundary
         DELETE dwhutl_mesr_threshold_t
          WHERE mesr_keyfigure_id = l_n_keyfigure_id
            AND mesr_threshold_from > l_d_threshold_from
            AND mesr_threshold_to < l_d_threshold_to;

         dwhutl_trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows deleted'
          , l_vc_prc_name
         );

         -- If new slice inside existing then split
         INSERT INTO dwhutl_mesr_threshold_t (
                        mesr_keyfigure_id
                      , mesr_threshold_type
                      , mesr_threshold_min
                      , mesr_threshold_max
                      , mesr_threshold_from
                      , mesr_threshold_to
                     )
            SELECT mesr_keyfigure_id
                 , mesr_threshold_type
                 , mesr_threshold_min
                 , mesr_threshold_max
                 , l_d_threshold_to
                 , mesr_threshold_to
              FROM dwhutl_mesr_threshold_t
             WHERE mesr_keyfigure_id = l_n_keyfigure_id
               AND mesr_threshold_from < l_d_threshold_from
               AND mesr_threshold_to > l_d_threshold_to;

         dwhutl_trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows inserted'
          , l_vc_prc_name
         );

         -- Update existing time slice where upper bound > new lower bound
         UPDATE dwhutl_mesr_threshold_t
            SET mesr_threshold_to = l_d_threshold_from
          WHERE mesr_keyfigure_id = l_n_keyfigure_id
            AND mesr_threshold_from < l_d_threshold_from
            AND mesr_threshold_to > l_d_threshold_from;

         dwhutl_trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows updated'
          , l_vc_prc_name
         );

         -- Update existing time slice where lower bound < new upper bound
         UPDATE dwhutl_mesr_threshold_t
            SET mesr_threshold_from = l_d_threshold_to
          WHERE mesr_keyfigure_id = l_n_keyfigure_id
            AND mesr_threshold_to > l_d_threshold_to
            AND mesr_threshold_from < l_d_threshold_to;

         dwhutl_trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows updated'
          , l_vc_prc_name
         );

            -- Update time slice with same boundary
            UPDATE dwhutl_mesr_threshold_t
               SET mesr_threshold_type = p_vc_threshold_type
                 , mesr_threshold_min = p_n_threshold_min
                 , mesr_threshold_max = p_n_threshold_max
             WHERE mesr_keyfigure_id = l_n_keyfigure_id
               AND mesr_threshold_from = l_d_threshold_from
               AND mesr_threshold_to = l_d_threshold_to
         RETURNING mesr_threshold_id
              INTO l_n_threshold_id;

         dwhutl_trac.log_sub_info (
               SQL%ROWCOUNT
            || ' rows updated'
          , l_vc_prc_name
         );

         IF l_n_threshold_id IS NULL THEN
            INSERT INTO dwhutl_mesr_threshold_t (
                           mesr_keyfigure_id
                         , mesr_threshold_type
                         , mesr_threshold_min
                         , mesr_threshold_max
                         , mesr_threshold_from
                         , mesr_threshold_to
                        )
                 VALUES (
                           l_n_keyfigure_id
                         , p_vc_threshold_type
                         , p_n_threshold_min
                         , p_n_threshold_max
                         , l_d_threshold_from
                         , l_d_threshold_to
                        );

            dwhutl_trac.log_sub_info (
                  SQL%ROWCOUNT
               || ' rows inserted'
             , l_vc_prc_name
            );
         END IF;

         COMMIT;
      END IF;
   END prc_threshold_ins;

   PROCEDURE prc_exec_ins (
      p_vc_query_code       IN VARCHAR2
    , p_vc_keyfigure_code   IN VARCHAR2
    , p_n_result_value      IN NUMBER
    , p_vc_result_report    IN CLOB
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_EXEC_INS';
   BEGIN
      INSERT INTO dwhutl_mesr_exec_t (
                     mesr_keyfigure_id
                   , mesr_exec_result_value
                   , mesr_exec_result_report
                  )
         SELECT k.mesr_keyfigure_id
              , p_n_result_value
              , p_vc_result_report
           FROM dwhutl_mesr_query_t s
              , dwhutl_mesr_keyfigure_t k
          WHERE s.mesr_query_id = k.mesr_query_id
            AND s.mesr_query_code = p_vc_query_code
            AND k.mesr_keyfigure_code = p_vc_keyfigure_code;

      dwhutl_trac.log_sub_info (
            SQL%ROWCOUNT
         || ' rows inserted'
       , l_vc_prc_name
      );
      COMMIT;
   END prc_exec_ins;

   PROCEDURE prc_exec (
      p_vc_query_code          IN VARCHAR2 DEFAULT 'ALL'
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   )
   IS
      l_vc_prc_name       t_object_name := 'PRC_EXEC';
      l_keyfigure         t_keyvalue;
      l_vc_query_table    VARCHAR2 (100);
      l_vc_stmt           VARCHAR2 (32000);
      l_vc_report         CLOB;
      l_vc_job_name       VARCHAR2 (100);
      l_n_gui             NUMBER;
      l_n_query_no        NUMBER;
      l_n_result          NUMBER;
      l_n_threshold_min   NUMBER;
      l_n_threshold_max   NUMBER;
      l_b_success         BOOLEAN := TRUE;
   BEGIN
      dwhutl_trac.log_sub_info (
            'Execute case query '
         || p_vc_query_code
       , 'Query START'
      );
      dwhutl_trac.log_sub_info (
            'Results will be stored as '
         || p_vc_storage_type
       ,    'STORAGE '
         || p_vc_storage_type
      );

      FOR r_query IN (  SELECT s.mesr_query_id
                             , s.mesr_query_code
                             , s.mesr_query_sql
                          FROM dwhutl_mesr_query_t s
                         WHERE (p_vc_query_code IN (s.mesr_query_code, 'ALL')
                             OR p_vc_query_code IS NULL)
                      ORDER BY s.mesr_query_code) LOOP
         dwhutl_trac.log_sub_info (
               'query '
            || r_query.mesr_query_code
          , 'query START'
         );

         BEGIN
            IF p_vc_storage_type = 'VALUE'
            OR p_vc_storage_type IS NULL THEN
               EXECUTE IMMEDIATE r_query.mesr_query_sql BULK COLLECT INTO l_keyfigure;

               dwhutl_trac.log_sub_info (
                     'query '
                  || r_query.mesr_query_code
                  || ': SQL executed '
                , 'SQL EXECUTED'
               );

               IF l_keyfigure.FIRST IS NOT NULL THEN
                  FOR i IN l_keyfigure.FIRST .. l_keyfigure.LAST LOOP
                     prc_keyfigure_ins (
                        r_query.mesr_query_code
                      , l_keyfigure (i).keyfigure
                      , l_keyfigure (i).keyfigure
                     );

                     IF p_b_exception_if_fails THEN
                        l_b_success :=
                           fct_exec_verify (
                              r_query.mesr_query_code
                            , l_keyfigure (i).keyfigure
                            , l_keyfigure (i).resultvalue
                           );
                     END IF;

                     prc_exec_ins (
                        r_query.mesr_query_code
                      , l_keyfigure (i).keyfigure
                      , l_keyfigure (i).resultvalue
                      , NULL
                     );
                     dwhutl_trac.log_sub_info (
                           'Key figure '
                        || l_keyfigure (i).keyfigure
                        || ' = '
                        || l_keyfigure (i).resultvalue
                        || ' , result stored'
                      , 'KEY FIGURE STORED'
                     );
                  END LOOP;
               ELSE
                  dwhutl_trac.log_sub_info (
                        'query '
                     || r_query.mesr_query_code
                     || ': no rows returned '
                   , 'NO RESULTS'
                  );
               END IF;
            ELSIF p_vc_storage_type = 'REPORT' THEN
               l_vc_query_table :=
                     'tmp_mesr_query_'
                  || TRIM (TO_CHAR (
                              r_query.mesr_query_id
                            , '0000000000'
                           ));

               BEGIN
                  l_vc_stmt :=
                        'DROP TABLE '
                     || l_vc_query_table;

                  EXECUTE IMMEDIATE l_vc_stmt;
               EXCEPTION
                  WHEN OTHERS THEN
                     NULL;
               END;

               l_vc_stmt :=
                     'CREATE TABLE '
                  || l_vc_query_table
                  || ' AS '
                  || r_query.mesr_query_sql;

               EXECUTE IMMEDIATE l_vc_stmt;

               dwhutl_trac.log_sub_info (
                     'query '
                  || r_query.mesr_query_code
                  || ': Table created '
                , 'SQL EXECUTED'
               );
               l_vc_report :=
                  dwhutl_docu.fct_get_table_dataset (
                     USER
                   , l_vc_query_table
                  );
               prc_keyfigure_ins (
                  r_query.mesr_query_code
                , 'REPORT'
                , 'REPORT'
               );
               prc_exec_ins (
                  r_query.mesr_query_code
                , 'REPORT'
                , NULL
                , l_vc_report
               );
               dwhutl_trac.log_sub_info (
                  'Report stored'
                , 'REPORT STORED'
               );
            END IF;
         EXCEPTION
            WHEN OTHERS THEN
               dwhutl_trac.log_error (
                     'query '
                  || r_query.mesr_query_code
                  || ': '
                  || SQLERRM
                , 'ERROR'
               );
         END;

         dwhutl_trac.log_sub_info (
               'query '
            || r_query.mesr_query_code
          , 'query FINISH'
         );
      END LOOP;

      dwhutl_trac.log_sub_info (
            'Execute query '
         || p_vc_query_code
         || ' : success '
         || CASE
               WHEN l_b_success THEN
                  'TRUE'
               ELSE
                  'FALSE'
            END
       , 'CASE FINISH'
      );

      IF p_b_exception_if_fails
     AND NOT l_b_success THEN
         raise_application_error (
            -20001
          , 'Test failed'
         );
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_error (
               'query '
            || p_vc_query_code
            || ' : failed'
          , 'QUERY ERROR'
         );
         RAISE;
   END;

   PROCEDURE prc_exec_taxonomy (
      p_vc_taxonomy_code       IN VARCHAR2
    , p_b_exception_if_fails   IN BOOLEAN DEFAULT FALSE
    , p_vc_storage_type        IN VARCHAR2 DEFAULT 'VALUE'
   )
   IS
      l_vc_prc_name   t_object_name := 'PRC_EXEC_TAXONOMY';
   BEGIN
      dwhutl_trac.log_sub_info (
            'Executing all cases belonging to taxonomy '
         || p_vc_taxonomy_code
         || ' and its children'
       , l_vc_prc_name
      );

      FOR r_tax IN (    SELECT taxn_id
                             , taxn_name
                             , SYS_CONNECT_BY_PATH (
                                  taxn_code
                                , '/'
                               )
                                  taxn_path
                          FROM dwhutl_taxn_t
                    START WITH taxn_code = p_vc_taxonomy_code
                    CONNECT BY PRIOR taxn_id = taxn_parent_id) LOOP
         dwhutl_trac.log_sub_info (
               'Executing all cases belonging to taxonomy '
            || r_tax.taxn_path
          , l_vc_prc_name
         );

         FOR r_query IN (SELECT c.mesr_query_code
                           FROM dwhutl_mesr_taxn_t t
                              , dwhutl_mesr_query_t c
                          WHERE t.mesr_query_id = c.mesr_query_id
                            AND t.taxn_id = r_tax.taxn_id) LOOP
            prc_exec (
               r_query.mesr_query_code
             , p_b_exception_if_fails
             , p_vc_storage_type
            );
         END LOOP;

         dwhutl_trac.log_sub_info (
               'All cases belonging to taxonomy '
            || r_tax.taxn_path
            || ' have been executed'
          , l_vc_prc_name
         );
      END LOOP;

      dwhutl_trac.log_sub_info (
            'All cases belonging to taxonomy '
         || p_vc_taxonomy_code
         || ' and its children have been executed'
       , l_vc_prc_name
      );
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_mesr;
2014-11-28 13:53:21.384 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/mesr/mesr-impl.sql executed
2014-11-28 13:53:21.385 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Module all installed
2014-11-28 13:53:21.385 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Found module "stag"
2014-11-28 13:53:21.385 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Installing all module
2014-11-28 13:53:21.385 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_column_t.sql delimiter 
2014-11-28 13:53:21.387 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_column'
    , 'stag_object_id NUMBER,
	   stag_column_pos NUMBER,
	   stag_column_name VARCHAR2 (100),
	   stag_column_name_map VARCHAR2 (100),
	   stag_column_comment VARCHAR2 (4000),
       stag_column_type VARCHAR2 (100),
       stag_column_length NUMBER,
       stag_column_precision NUMBER,
       stag_column_scale NUMBER,
	   stag_column_def VARCHAR2 (100),
	   stag_column_def_src VARCHAR2 (100),
	   stag_column_nk_pos NUMBER,
	   stag_column_incr_flag NUMBER,
	   stag_column_hist_flag NUMBER,
	   stag_column_edwh_flag NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:21.387 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_column'
    , 'stag_object_id NUMBER,
	   stag_column_pos NUMBER,
	   stag_column_name VARCHAR2 (100),
	   stag_column_name_map VARCHAR2 (100),
	   stag_column_comment VARCHAR2 (4000),
       stag_column_type VARCHAR2 (100),
       stag_column_length NUMBER,
       stag_column_precision NUMBER,
       stag_column_scale NUMBER,
	   stag_column_def VARCHAR2 (100),
	   stag_column_def_src VARCHAR2 (100),
	   stag_column_nk_pos NUMBER,
	   stag_column_incr_flag NUMBER,
	   stag_column_hist_flag NUMBER,
	   stag_column_edwh_flag NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:21.635 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_column_t.sql executed
2014-11-28 13:53:21.636 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_column_check_t.sql delimiter 
2014-11-28 13:53:21.636 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_column_check'
    , 'stag_object_id NUMBER,
	   stag_column_name VARCHAR2 (100),
	   stag_column_pos NUMBER,
       stag_column_type VARCHAR2 (100),
       stag_column_length NUMBER,
       stag_column_precision NUMBER,
       stag_column_scale NUMBER,
	   stag_column_def VARCHAR2 (100),
	   stag_column_nk_pos NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:21.636 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_column_check'
    , 'stag_object_id NUMBER,
	   stag_column_name VARCHAR2 (100),
	   stag_column_pos NUMBER,
       stag_column_type VARCHAR2 (100),
       stag_column_length NUMBER,
       stag_column_precision NUMBER,
       stag_column_scale NUMBER,
	   stag_column_def VARCHAR2 (100),
	   stag_column_nk_pos NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:21.858 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_column_check_t.sql executed
2014-11-28 13:53:21.858 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_ddl_t.sql delimiter 
2014-11-28 13:53:21.858 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_ddl'
    , 'stag_ddl_type VARCHAR2 (100),
       stag_ddl_name VARCHAR2 (100),
       stag_ddl_code CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:21.858 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_ddl'
    , 'stag_ddl_type VARCHAR2 (100),
       stag_ddl_name VARCHAR2 (100),
       stag_ddl_code CLOB'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.109 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_ddl_t.sql executed
2014-11-28 13:53:22.110 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_object_t.sql delimiter 
2014-11-28 13:53:22.112 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_object'
    , 'stag_source_id NUMBER,
	   stag_object_name VARCHAR2 (100),
       stag_object_comment VARCHAR2(4000),
	   stag_object_root VARCHAR2 (100),
	   stag_src_table_name VARCHAR2 (100),
	   stag_stage_table_name VARCHAR2 (100),
	   stag_hist_table_name VARCHAR2 (100),
	   stag_hist_nk_name VARCHAR2 (100),
	   stag_hist_view_name VARCHAR2 (100),
	   stag_hist_fbda_name VARCHAR2 (100),
       stag_diff_table_name VARCHAR2 (100),
	   stag_diff_nk_name VARCHAR2 (100),
	   stag_dupl_table_name VARCHAR2 (100),
	   stag_package_name VARCHAR2 (100),
	   stag_source_nk_flag NUMBER,
	   stag_parallel_degree NUMBER DEFAULT 1,
       stag_filter_clause VARCHAR2(4000),
       stag_increment_buffer NUMBER,
       stag_partition_clause VARCHAR2(4000),
       stag_hist_flag NUMBER DEFAULT 1,
       stag_fbda_flag NUMBER DEFAULT 0'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.112 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_object'
    , 'stag_source_id NUMBER,
	   stag_object_name VARCHAR2 (100),
       stag_object_comment VARCHAR2(4000),
	   stag_object_root VARCHAR2 (100),
	   stag_src_table_name VARCHAR2 (100),
	   stag_stage_table_name VARCHAR2 (100),
	   stag_hist_table_name VARCHAR2 (100),
	   stag_hist_nk_name VARCHAR2 (100),
	   stag_hist_view_name VARCHAR2 (100),
	   stag_hist_fbda_name VARCHAR2 (100),
       stag_diff_table_name VARCHAR2 (100),
	   stag_diff_nk_name VARCHAR2 (100),
	   stag_dupl_table_name VARCHAR2 (100),
	   stag_package_name VARCHAR2 (100),
	   stag_source_nk_flag NUMBER,
	   stag_parallel_degree NUMBER DEFAULT 1,
       stag_filter_clause VARCHAR2(4000),
       stag_increment_buffer NUMBER,
       stag_partition_clause VARCHAR2(4000),
       stag_hist_flag NUMBER DEFAULT 1,
       stag_fbda_flag NUMBER DEFAULT 0'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.330 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_object_t.sql executed
2014-11-28 13:53:22.330 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_object_uk.sql delimiter ;
2014-11-28 13:53:22.331 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#stag_object_t ADD (CONSTRAINT p#frm#stag_object_uk UNIQUE ( stag_object_root));
2014-11-28 13:53:22.331 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_stag_object_t ADD (CONSTRAINT dwhutl_stag_object_uk UNIQUE ( stag_object_root));
2014-11-28 13:53:22.370 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_object_uk.sql executed
2014-11-28 13:53:22.371 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_t.sql delimiter 
2014-11-28 13:53:22.371 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_queue'
    , 'stag_queue_code VARCHAR2(10),
       stag_queue_name VARCHAR2(100)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.372 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_queue'
    , 'stag_queue_code VARCHAR2(10),
       stag_queue_name VARCHAR2(100)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.569 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_t.sql executed
2014-11-28 13:53:22.570 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_uk.sql delimiter ;
2014-11-28 13:53:22.570 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#stag_queue_t ADD CONSTRAINT p#frm#stag_queue_uk UNIQUE (stag_queue_code);
2014-11-28 13:53:22.571 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_stag_queue_t ADD CONSTRAINT dwhutl_stag_queue_uk UNIQUE (stag_queue_code);
2014-11-28 13:53:22.599 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_uk.sql executed
2014-11-28 13:53:22.599 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_object_t.sql delimiter 
2014-11-28 13:53:22.600 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_queue_object'
    , 'stag_queue_id NUMBER
     , stag_object_id NUMBER
     , etl_step_status NUMBER
     , etl_step_session_id NUMBER
     , etl_step_begin_date DATE
     , etl_step_end_date DATE'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.600 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_queue_object'
    , 'stag_queue_id NUMBER
     , stag_object_id NUMBER
     , etl_step_status NUMBER
     , etl_step_session_id NUMBER
     , etl_step_begin_date DATE
     , etl_step_end_date DATE'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.803 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_object_t.sql executed
2014-11-28 13:53:22.803 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_object_uk.sql delimiter ;
2014-11-28 13:53:22.804 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#stag_queue_object_t ADD CONSTRAINT p#frm#stag_queue_object_uk UNIQUE (stag_queue_id,stag_object_id);
2014-11-28 13:53:22.804 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_stag_queue_object_t ADD CONSTRAINT dwhutl_stag_queue_object_uk UNIQUE (stag_queue_id,stag_object_id);
2014-11-28 13:53:22.837 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_queue_object_uk.sql executed
2014-11-28 13:53:22.837 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_source_db_t.sql delimiter 
2014-11-28 13:53:22.838 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_source_db'
    , 'stag_source_id          NUMBER,
       stag_source_db_link     VARCHAR2(100),
       stag_source_db_jdbcname VARCHAR2(100),
       stag_source_owner       VARCHAR2(100),
       stag_distribution_code  VARCHAR2(10),
       stag_source_bodi_ds     VARCHAR2(100)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:22.838 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_source_db'
    , 'stag_source_id          NUMBER,
       stag_source_db_link     VARCHAR2(100),
       stag_source_db_jdbcname VARCHAR2(100),
       stag_source_owner       VARCHAR2(100),
       stag_distribution_code  VARCHAR2(10),
       stag_source_bodi_ds     VARCHAR2(100)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.015 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_source_db_t.sql executed
2014-11-28 13:53:23.015 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_source_t.sql delimiter 
2014-11-28 13:53:23.016 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_source'
    , 'stag_source_code VARCHAR2(10),
		stag_source_prefix VARCHAR2(10),
		stag_source_name VARCHAR2(1000),
		stag_owner VARCHAR2(100),
		stag_ts_stage_data VARCHAR2(100),
		stag_ts_stage_indx VARCHAR2(100),
		stag_ts_hist_data VARCHAR2(100),
		stag_ts_hist_indx VARCHAR2(100),
		stag_fb_archive VARCHAR2(100),
		stag_bodi_ds VARCHAR2(100),
		stag_source_bodi_ds VARCHAR2(100)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.016 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_source'
    , 'stag_source_code VARCHAR2(10),
		stag_source_prefix VARCHAR2(10),
		stag_source_name VARCHAR2(1000),
		stag_owner VARCHAR2(100),
		stag_ts_stage_data VARCHAR2(100),
		stag_ts_stage_indx VARCHAR2(100),
		stag_ts_hist_data VARCHAR2(100),
		stag_ts_hist_indx VARCHAR2(100),
		stag_fb_archive VARCHAR2(100),
		stag_bodi_ds VARCHAR2(100),
		stag_source_bodi_ds VARCHAR2(100)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.264 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_source_t.sql executed
2014-11-28 13:53:23.264 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_stat_type_t.sql delimiter 
2014-11-28 13:53:23.265 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_stat_type'
    , 'stag_stat_type_code VARCHAR2(10),
       stag_stat_type_name VARCHAR2(100),
	   stag_stat_type_desc VARCHAR2(1000)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.265 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_stat_type'
    , 'stag_stat_type_code VARCHAR2(10),
       stag_stat_type_name VARCHAR2(100),
	   stag_stat_type_desc VARCHAR2(1000)'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.459 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_stat_type_t.sql executed
2014-11-28 13:53:23.459 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_stat_t.sql delimiter 
2014-11-28 13:53:23.459 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_stat'
    , 'stag_object_id NUMBER,
	   stag_partition NUMBER,
	   stag_load_id NUMBER,
	   stag_stat_type_id NUMBER,
	   stag_stat_value NUMBER,
	   stag_stat_error NUMBER,
	   stag_stat_sid NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.460 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_stat'
    , 'stag_object_id NUMBER,
	   stag_partition NUMBER,
	   stag_load_id NUMBER,
	   stag_stat_type_id NUMBER,
	   stag_stat_value NUMBER,
	   stag_stat_error NUMBER,
	   stag_stat_sid NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.648 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_stat_t.sql executed
2014-11-28 13:53:23.649 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_size_t.sql delimiter 
2014-11-28 13:53:23.650 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
   p#frm#ddls.prc_create_entity (
      'p#frm#'
    , 'stag_size'
    , 'stag_object_id NUMBER,
       stag_table_name VARCHAR2(100),
       stag_num_rows NUMBER,
       stag_bytes NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.650 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
   dwhutl_ddls.prc_create_entity (
      'dwhutl_'
    , 'stag_size'
    , 'stag_object_id NUMBER,
       stag_table_name VARCHAR2(100),
       stag_num_rows NUMBER,
       stag_bytes NUMBER'
    , 'DROP'
    , TRUE
    , TRUE
   );
END;
2014-11-28 13:53:23.861 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_size_t.sql executed
2014-11-28 13:53:23.862 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_size_uk.sql delimiter ;
2014-11-28 13:53:23.863 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
ALTER TABLE p#frm#stag_size_t ADD (CONSTRAINT p#frm#stag_size_uk UNIQUE (stag_table_name, create_date));
2014-11-28 13:53:23.863 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
ALTER TABLE dwhutl_stag_size_t ADD (CONSTRAINT dwhutl_stag_size_uk UNIQUE (stag_table_name, create_date));
2014-11-28 13:53:23.912 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_size_uk.sql executed
2014-11-28 13:53:23.913 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_column_v.sql delimiter ;
2014-11-28 13:53:23.914 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_column_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_source_nk_flag
          , co.stag_column_id
          , co.stag_column_pos
          , co.stag_column_name
          , co.stag_column_name_map
          , co.stag_column_comment
          , co.stag_column_def
          , co.stag_column_def_src
          , co.stag_column_nk_pos
          , co.stag_column_hist_flag
          , co.stag_column_edwh_flag
          , co.update_date
       FROM p#frm#stag_column_t co
          , p#frm#stag_object_t ob
          , p#frm#stag_source_t sc
      WHERE ob.stag_object_id = co.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY sc.stag_source_code
          , ob.stag_object_name
          , co.stag_column_pos;
2014-11-28 13:53:23.914 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_column_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_source_nk_flag
          , co.stag_column_id
          , co.stag_column_pos
          , co.stag_column_name
          , co.stag_column_name_map
          , co.stag_column_comment
          , co.stag_column_def
          , co.stag_column_def_src
          , co.stag_column_nk_pos
          , co.stag_column_hist_flag
          , co.stag_column_edwh_flag
          , co.update_date
       FROM dwhutl_stag_column_t co
          , dwhutl_stag_object_t ob
          , dwhutl_stag_source_t sc
      WHERE ob.stag_object_id = co.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY sc.stag_source_code
          , ob.stag_object_name
          , co.stag_column_pos;
2014-11-28 13:53:24.003 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_column_v.sql executed
2014-11-28 13:53:24.003 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_column_check_v.sql delimiter ;
2014-11-28 13:53:24.005 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_column_check_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_source_nk_flag
          , co.stag_column_id
          , co.stag_column_name
          , co.stag_column_name_map
          , co.stag_column_comment
          , co.stag_column_edwh_flag
          , co.stag_column_stag_pos
          , co.stag_column_stag_def
          , co.stag_column_stag_nk_pos
          , co.stag_column_src_pos
          , co.stag_column_src_def
          , co.stag_column_src_nk_pos
          , co.update_date
       FROM (SELECT NVL (c.stag_object_id, k.stag_object_id) AS stag_object_id
                  , c.stag_column_id
                  , NVL (c.stag_column_name, k.stag_column_name) AS stag_column_name
                  , c.stag_column_name_map
                  , c.stag_column_comment
                  , c.stag_column_edwh_flag
                  , c.stag_column_pos AS stag_column_stag_pos
                  , c.stag_column_def AS stag_column_stag_def
                  , c.stag_column_nk_pos AS stag_column_stag_nk_pos
                  , k.stag_column_pos AS stag_column_src_pos
                  , k.stag_column_def AS stag_column_src_def
                  , k.stag_column_nk_pos AS stag_column_src_nk_pos
                  , c.update_date
               FROM p#frm#stag_column_check_t k
                    FULL OUTER JOIN p#frm#stag_column_t c
                       ON c.stag_object_id = k.stag_object_id
                      AND c.stag_column_name = k.stag_column_name) co
          , p#frm#stag_object_t ob
          , p#frm#stag_source_t sc
      WHERE ob.stag_object_id = co.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY sc.stag_source_code
          , ob.stag_object_name
          , NVL (co.stag_column_stag_pos, co.stag_column_src_pos);
2014-11-28 13:53:24.006 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_column_check_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_source_nk_flag
          , co.stag_column_id
          , co.stag_column_name
          , co.stag_column_name_map
          , co.stag_column_comment
          , co.stag_column_edwh_flag
          , co.stag_column_stag_pos
          , co.stag_column_stag_def
          , co.stag_column_stag_nk_pos
          , co.stag_column_src_pos
          , co.stag_column_src_def
          , co.stag_column_src_nk_pos
          , co.update_date
       FROM (SELECT NVL (c.stag_object_id, k.stag_object_id) AS stag_object_id
                  , c.stag_column_id
                  , NVL (c.stag_column_name, k.stag_column_name) AS stag_column_name
                  , c.stag_column_name_map
                  , c.stag_column_comment
                  , c.stag_column_edwh_flag
                  , c.stag_column_pos AS stag_column_stag_pos
                  , c.stag_column_def AS stag_column_stag_def
                  , c.stag_column_nk_pos AS stag_column_stag_nk_pos
                  , k.stag_column_pos AS stag_column_src_pos
                  , k.stag_column_def AS stag_column_src_def
                  , k.stag_column_nk_pos AS stag_column_src_nk_pos
                  , c.update_date
               FROM dwhutl_stag_column_check_t k
                    FULL OUTER JOIN dwhutl_stag_column_t c
                       ON c.stag_object_id = k.stag_object_id
                      AND c.stag_column_name = k.stag_column_name) co
          , dwhutl_stag_object_t ob
          , dwhutl_stag_source_t sc
      WHERE ob.stag_object_id = co.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY sc.stag_source_code
          , ob.stag_object_name
          , NVL (co.stag_column_stag_pos, co.stag_column_src_pos);
2014-11-28 13:53:24.092 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_column_check_v.sql executed
2014-11-28 13:53:24.092 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_object_v.sql delimiter ;
2014-11-28 13:53:24.093 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_object_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_object_comment
          , ob.stag_object_root
          , ob.stag_src_table_name
          , ob.stag_stage_table_name
          , ob.stag_hist_table_name
          , ob.stag_hist_nk_name
          , ob.stag_dupl_table_name
          , ob.stag_diff_table_name
          , ob.stag_diff_nk_name
          , ob.stag_hist_view_name
          , ob.stag_hist_fbda_name
          , ob.stag_package_name
          , ob.stag_source_nk_flag
          , ob.stag_parallel_degree
          , ob.stag_partition_clause
          , ob.stag_filter_clause
          , ob.stag_fbda_flag
          , ob.update_date
       FROM p#frm#stag_object_t ob
          , p#frm#stag_source_t sc
      WHERE ob.stag_source_id = sc.stag_source_id
   ORDER BY sc.stag_source_code
          , ob.stag_object_name;
2014-11-28 13:53:24.093 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_object_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_object_comment
          , ob.stag_object_root
          , ob.stag_src_table_name
          , ob.stag_stage_table_name
          , ob.stag_hist_table_name
          , ob.stag_hist_nk_name
          , ob.stag_dupl_table_name
          , ob.stag_diff_table_name
          , ob.stag_diff_nk_name
          , ob.stag_hist_view_name
          , ob.stag_hist_fbda_name
          , ob.stag_package_name
          , ob.stag_source_nk_flag
          , ob.stag_parallel_degree
          , ob.stag_partition_clause
          , ob.stag_filter_clause
          , ob.stag_fbda_flag
          , ob.update_date
       FROM dwhutl_stag_object_t ob
          , dwhutl_stag_source_t sc
      WHERE ob.stag_source_id = sc.stag_source_id
   ORDER BY sc.stag_source_code
          , ob.stag_object_name;
2014-11-28 13:53:24.182 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_object_v.sql executed
2014-11-28 13:53:24.183 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_queue_object_v.sql delimiter ;
2014-11-28 13:53:24.184 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_queue_object_v
AS
     SELECT q.stag_queue_code
          , qo.stag_object_id
          , s.stag_source_code
          , o.stag_object_name
          , qo.etl_step_status
          , qo.etl_step_session_id
          , qo.etl_step_begin_date AS step_begin
          , qo.etl_step_end_date AS step_finish
          , NUMTODSINTERVAL (
                 qo.etl_step_end_date
               - qo.etl_step_begin_date
             , 'day'
            )
               step_duration
       FROM p#frm#stag_queue_object_t qo
          , p#frm#stag_queue_t q
          , p#frm#stag_object_t o
          , p#frm#stag_source_t s
      WHERE qo.stag_queue_id = q.stag_queue_id
        AND qo.stag_object_id = o.stag_object_id
        AND o.stag_source_id = s.stag_source_id
   ORDER BY qo.etl_step_begin_date DESC NULLS FIRST
          , qo.etl_step_end_date DESC NULLS FIRST
          , qo.stag_queue_id DESC
          , qo.stag_queue_object_id;
2014-11-28 13:53:24.184 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_queue_object_v
AS
     SELECT q.stag_queue_code
          , qo.stag_object_id
          , s.stag_source_code
          , o.stag_object_name
          , qo.etl_step_status
          , qo.etl_step_session_id
          , qo.etl_step_begin_date AS step_begin
          , qo.etl_step_end_date AS step_finish
          , NUMTODSINTERVAL (
                 qo.etl_step_end_date
               - qo.etl_step_begin_date
             , 'day'
            )
               step_duration
       FROM dwhutl_stag_queue_object_t qo
          , dwhutl_stag_queue_t q
          , dwhutl_stag_object_t o
          , dwhutl_stag_source_t s
      WHERE qo.stag_queue_id = q.stag_queue_id
        AND qo.stag_object_id = o.stag_object_id
        AND o.stag_source_id = s.stag_source_id
   ORDER BY qo.etl_step_begin_date DESC NULLS FIRST
          , qo.etl_step_end_date DESC NULLS FIRST
          , qo.stag_queue_id DESC
          , qo.stag_queue_object_id;
2014-11-28 13:53:24.230 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_queue_object_v.sql executed
2014-11-28 13:53:24.230 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_queue_v.sql delimiter ;
2014-11-28 13:53:24.232 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_queue_v
AS
   SELECT stag_queue_id
        , stag_queue_code
        , stag_queue_name
     FROM p#frm#stag_queue_t q;
2014-11-28 13:53:24.232 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_queue_v
AS
   SELECT stag_queue_id
        , stag_queue_code
        , stag_queue_name
     FROM dwhutl_stag_queue_t q;
2014-11-28 13:53:24.263 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_queue_v.sql executed
2014-11-28 13:53:24.263 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_source_db_v.sql delimiter ;
2014-11-28 13:53:24.264 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_source_db_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , db.stag_source_db_link
          , db.stag_source_db_jdbcname
          , db.stag_source_owner
          , db.stag_distribution_code
          , db.stag_source_bodi_ds
          , db.update_date
       FROM p#frm#stag_source_db_t db
          , p#frm#stag_source_t sc
      WHERE sc.stag_source_id = db.stag_source_id
   ORDER BY sc.stag_source_code;
2014-11-28 13:53:24.264 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_source_db_v
AS
     SELECT sc.stag_source_id
          , sc.stag_source_code
          , db.stag_source_db_link
          , db.stag_source_db_jdbcname
          , db.stag_source_owner
          , db.stag_distribution_code
          , db.stag_source_bodi_ds
          , db.update_date
       FROM dwhutl_stag_source_db_t db
          , dwhutl_stag_source_t sc
      WHERE sc.stag_source_id = db.stag_source_id
   ORDER BY sc.stag_source_code;
2014-11-28 13:53:24.308 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_source_db_v.sql executed
2014-11-28 13:53:24.308 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_source_v.sql delimiter ;
2014-11-28 13:53:24.309 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_source_v
AS
   SELECT stag_source_id
        , stag_source_code
        , stag_source_name
        , stag_source_prefix
        , stag_owner
        , stag_ts_stage_data
        , stag_ts_stage_indx
        , stag_ts_hist_data
        , stag_ts_hist_indx
        , stag_fb_archive
        , stag_bodi_ds
        , stag_source_bodi_ds
        , update_date
     FROM p#frm#stag_source_t;
2014-11-28 13:53:24.309 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_source_v
AS
   SELECT stag_source_id
        , stag_source_code
        , stag_source_name
        , stag_source_prefix
        , stag_owner
        , stag_ts_stage_data
        , stag_ts_stage_indx
        , stag_ts_hist_data
        , stag_ts_hist_indx
        , stag_fb_archive
        , stag_bodi_ds
        , stag_source_bodi_ds
        , update_date
     FROM dwhutl_stag_source_t;
2014-11-28 13:53:24.353 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_source_v.sql executed
2014-11-28 13:53:24.354 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_stat_last_v.sql delimiter ;
2014-11-28 13:53:24.356 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_stat_last_v
AS
     SELECT stage_source
          , stage_object
          , MIN (first_date) AS first_begin_date
          , MAX (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'ANL' THEN
                       last_date
                 END)
               AS last_complete_date
          , SUM (CASE
                    WHEN stage_id = 1
                     AND stage_action = 'INS' THEN
                       stat_value
                    ELSE
                       0
                 END)
               AS stg1_insert_cnt
          , SUM (CASE
                    WHEN stage_id = 1
                     AND stage_action = 'INS' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg1_insert_duration
          , SUM (CASE
                    WHEN stage_id = 1
                     AND stage_action = 'ANL' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg1_analyze_duration
          , SUM (CASE
                    WHEN stage_id = 1 THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg1_duration
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'IDT' THEN
                       stat_value
                    ELSE
                       0
                 END)
               AS stg2_insert_cnt
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'IDT' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_insert_duration
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action IN ('MDT', 'MDE', 'FDI', 'FUP', 'FIN') THEN
                       stat_value
                    ELSE
                       0
                 END)
               AS stg2_delta_cnt
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action IN ('MDT', 'MDE', 'FDI', 'FUP', 'FIN') THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_delta_duration
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'ANL' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_analyze_duration
          , SUM (CASE
                    WHEN stage_id = 2 THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_duration
       FROM (  SELECT sc.stag_source_code AS stage_source
                    , ob.stag_object_name AS stage_object
                    , ty.stag_stat_type_code AS stage_action
                    , st.stag_id AS stage_id
                    , SUM (st.stag_stat_value) AS stat_value
                    , ROUND (  (  MAX (st.update_date)
                                - MIN (st.create_date))
                             * 86400)
                         AS stat_duration
                    , MAX (st.update_date) AS last_date
                    , MIN (st.create_date) AS first_date
                 FROM (SELECT s.*
                            , ROW_NUMBER () OVER (PARTITION BY stag_object_id, stag_partition, stag_stat_type_id, stag_id ORDER BY create_date DESC) AS stat_rank
                         FROM p#frm#stag_stat_t s) st
                    , p#frm#stag_stat_type_t ty
                    , p#frm#stag_object_t ob
                    , p#frm#stag_source_t sc
                WHERE st.stag_stat_type_id = ty.stag_stat_type_id
                  AND st.stag_object_id = ob.stag_object_id
                  AND ob.stag_source_id = sc.stag_source_id
                  AND st.stag_stat_value IS NOT NULL
                  AND st.stat_rank = 1
             GROUP BY sc.stag_source_code
                    , ob.stag_object_name
                    , ty.stag_stat_type_code
                    , st.stag_id)
   GROUP BY stage_source
          , stage_object;
2014-11-28 13:53:24.356 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_stat_last_v
AS
     SELECT stage_source
          , stage_object
          , MIN (first_date) AS first_begin_date
          , MAX (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'ANL' THEN
                       last_date
                 END)
               AS last_complete_date
          , SUM (CASE
                    WHEN stage_id = 1
                     AND stage_action = 'INS' THEN
                       stat_value
                    ELSE
                       0
                 END)
               AS stg1_insert_cnt
          , SUM (CASE
                    WHEN stage_id = 1
                     AND stage_action = 'INS' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg1_insert_duration
          , SUM (CASE
                    WHEN stage_id = 1
                     AND stage_action = 'ANL' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg1_analyze_duration
          , SUM (CASE
                    WHEN stage_id = 1 THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg1_duration
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'IDT' THEN
                       stat_value
                    ELSE
                       0
                 END)
               AS stg2_insert_cnt
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'IDT' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_insert_duration
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action IN ('MDT', 'MDE', 'FDI', 'FUP', 'FIN') THEN
                       stat_value
                    ELSE
                       0
                 END)
               AS stg2_delta_cnt
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action IN ('MDT', 'MDE', 'FDI', 'FUP', 'FIN') THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_delta_duration
          , SUM (CASE
                    WHEN stage_id = 2
                     AND stage_action = 'ANL' THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_analyze_duration
          , SUM (CASE
                    WHEN stage_id = 2 THEN
                       stat_duration
                    ELSE
                       0
                 END)
               AS stg2_duration
       FROM (  SELECT sc.stag_source_code AS stage_source
                    , ob.stag_object_name AS stage_object
                    , ty.stag_stat_type_code AS stage_action
                    , st.stag_id AS stage_id
                    , SUM (st.stag_stat_value) AS stat_value
                    , ROUND (  (  MAX (st.update_date)
                                - MIN (st.create_date))
                             * 86400)
                         AS stat_duration
                    , MAX (st.update_date) AS last_date
                    , MIN (st.create_date) AS first_date
                 FROM (SELECT s.*
                            , ROW_NUMBER () OVER (PARTITION BY stag_object_id, stag_partition, stag_stat_type_id, stag_id ORDER BY create_date DESC) AS stat_rank
                         FROM dwhutl_stag_stat_t s) st
                    , dwhutl_stag_stat_type_t ty
                    , dwhutl_stag_object_t ob
                    , dwhutl_stag_source_t sc
                WHERE st.stag_stat_type_id = ty.stag_stat_type_id
                  AND st.stag_object_id = ob.stag_object_id
                  AND ob.stag_source_id = sc.stag_source_id
                  AND st.stag_stat_value IS NOT NULL
                  AND st.stat_rank = 1
             GROUP BY sc.stag_source_code
                    , ob.stag_object_name
                    , ty.stag_stat_type_code
                    , st.stag_id)
   GROUP BY stage_source
          , stage_object;
2014-11-28 13:53:24.391 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_stat_last_v.sql executed
2014-11-28 13:53:24.391 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_stat_v.sql delimiter ;
2014-11-28 13:53:24.392 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_stat_v
AS
     SELECT st.stag_stat_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_package_name
          , st.stag_partition
          , st.stag_load_id
          , ty.stag_stat_type_name
          , st.stag_stat_value
          , st.stag_stat_error
          , st.create_date AS stat_start
          , st.update_date AS stat_finish
          , NUMTODSINTERVAL (
               ROUND (  (  st.update_date
                         - st.create_date)
                      * 86400)
             , 'second'
            )
               AS stat_duration
          , st.stag_stat_sid
       FROM p#frm#stag_stat_t st
          , p#frm#stag_stat_type_t ty
          , p#frm#stag_object_t ob
          , p#frm#stag_source_t sc
      WHERE st.stag_stat_type_id = ty.stag_stat_type_id
        AND st.stag_object_id = ob.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY st.update_date DESC
          , st.create_date DESC
          , st.stag_stat_id;
2014-11-28 13:53:24.392 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_stat_v
AS
     SELECT st.stag_stat_id
          , sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , ob.stag_package_name
          , st.stag_partition
          , st.stag_load_id
          , ty.stag_stat_type_name
          , st.stag_stat_value
          , st.stag_stat_error
          , st.create_date AS stat_start
          , st.update_date AS stat_finish
          , NUMTODSINTERVAL (
               ROUND (  (  st.update_date
                         - st.create_date)
                      * 86400)
             , 'second'
            )
               AS stat_duration
          , st.stag_stat_sid
       FROM dwhutl_stag_stat_t st
          , dwhutl_stag_stat_type_t ty
          , dwhutl_stag_object_t ob
          , dwhutl_stag_source_t sc
      WHERE st.stag_stat_type_id = ty.stag_stat_type_id
        AND st.stag_object_id = ob.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY st.update_date DESC
          , st.create_date DESC
          , st.stag_stat_id;
2014-11-28 13:53:24.421 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_stat_v.sql executed
2014-11-28 13:53:24.421 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_size_v.sql delimiter ;
2014-11-28 13:53:24.422 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE VIEW p#frm#stag_size_v
AS
     SELECT sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , si.stag_table_name
          , si.stag_num_rows
          , si.stag_bytes
          , si.create_date
       FROM p#frm#stag_size_t si
          , p#frm#stag_object_t ob
          , p#frm#stag_source_t sc
      WHERE si.stag_object_id = ob.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY si.create_date DESC;
2014-11-28 13:53:24.422 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE VIEW dwhutl_stag_size_v
AS
     SELECT sc.stag_source_code
          , ob.stag_object_id
          , ob.stag_object_name
          , si.stag_table_name
          , si.stag_num_rows
          , si.stag_bytes
          , si.create_date
       FROM dwhutl_stag_size_t si
          , dwhutl_stag_object_t ob
          , dwhutl_stag_source_t sc
      WHERE si.stag_object_id = ob.stag_object_id
        AND ob.stag_source_id = sc.stag_source_id
   ORDER BY si.create_date DESC;
2014-11-28 13:53:24.438 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script views/stag_size_v.sql executed
2014-11-28 13:53:24.439 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_param/stag_param-def.sql delimiter 
2014-11-28 13:53:24.440 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stag_param
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version         CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url             CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version                  VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                      VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   /**
    * Default namesand prefixes
    */
   c_vc_suffix_tab_source          t_object_name := 'SRC';
   c_vc_suffix_tab_stag            t_object_name := 'STG';
   c_vc_suffix_tab_hist            t_object_name := 'HST';
   c_vc_suffix_tab_diff            t_object_name := 'DIF';
   c_vc_suffix_tab_dupl            t_object_name := 'DUP';
   c_vc_suffix_nk_diff             t_object_name := 'DNK';
   c_vc_suffix_nk_hist             t_object_name := 'HNK';
   c_vc_suffix_view_fbda           t_object_name := 'H';
   c_vc_suffix_package             t_object_name := 'PKG';
   c_vc_prefix_partition           t_object_name := 'P';
   --
   c_vc_procedure_trunc_stage      t_object_name := 'prc_trunc_stage';
   c_vc_procedure_trunc_diff       t_object_name := 'prc_trunc_diff';
   c_vc_procedure_load_init        t_object_name := 'prc_load_init';
   c_vc_procedure_load_stage       t_object_name := 'prc_load_stage';
   c_vc_procedure_load_stage_p     t_object_name := 'prc_load_stage_p';
   c_vc_procedure_load_diff        t_object_name := 'prc_load_diff';
   c_vc_procedure_load_diff_incr   t_object_name := 'prc_load_diff_incr';
   c_vc_procedure_load_hist        t_object_name := 'prc_load_hist';
   c_vc_procedure_wrapper          t_object_name := 'prc_load';
   c_vc_procedure_wrapper_incr     t_object_name := 'prc_load_incr';
   --
   c_vc_column_stage_sk            t_object_name := 'DWH_SK';
   c_vc_column_valid_from          t_object_name := 'DWH_VALID_FROM';
   c_vc_column_valid_to            t_object_name := 'DWH_VALID_TO';
   c_vc_column_dml_op              t_object_name := 'DWH_OPERATION';
   c_vc_column_source_db           t_object_name := 'DWH_SOURCE_ID';
   c_vc_column_partition           t_object_name := 'DWH_PARTITION_ID';
   c_vc_column_system_src          t_object_name := 'DWH_SYSTEM';
   c_vc_column_active_version      t_object_name := 'DWH_ACTIVE';
   /**
    * Grantees
    */
   c_vc_list_grantee               t_string := 'DWHCORE';
END p#frm#stag_param;
2014-11-28 13:53:24.440 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stag_param
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version         CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url             CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version                  VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                      VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   /**
    * Default namesand prefixes
    */
   c_vc_suffix_tab_source          t_object_name := 'SRC';
   c_vc_suffix_tab_stag            t_object_name := 'STG';
   c_vc_suffix_tab_hist            t_object_name := 'HST';
   c_vc_suffix_tab_diff            t_object_name := 'DIF';
   c_vc_suffix_tab_dupl            t_object_name := 'DUP';
   c_vc_suffix_nk_diff             t_object_name := 'DNK';
   c_vc_suffix_nk_hist             t_object_name := 'HNK';
   c_vc_suffix_view_fbda           t_object_name := 'H';
   c_vc_suffix_package             t_object_name := 'PKG';
   c_vc_prefix_partition           t_object_name := 'P';
   --
   c_vc_procedure_trunc_stage      t_object_name := 'prc_trunc_stage';
   c_vc_procedure_trunc_diff       t_object_name := 'prc_trunc_diff';
   c_vc_procedure_load_init        t_object_name := 'prc_load_init';
   c_vc_procedure_load_stage       t_object_name := 'prc_load_stage';
   c_vc_procedure_load_stage_p     t_object_name := 'prc_load_stage_p';
   c_vc_procedure_load_diff        t_object_name := 'prc_load_diff';
   c_vc_procedure_load_diff_incr   t_object_name := 'prc_load_diff_incr';
   c_vc_procedure_load_hist        t_object_name := 'prc_load_hist';
   c_vc_procedure_wrapper          t_object_name := 'prc_load';
   c_vc_procedure_wrapper_incr     t_object_name := 'prc_load_incr';
   --
   c_vc_column_stage_sk            t_object_name := 'DWH_SK';
   c_vc_column_valid_from          t_object_name := 'DWH_VALID_FROM';
   c_vc_column_valid_to            t_object_name := 'DWH_VALID_TO';
   c_vc_column_dml_op              t_object_name := 'DWH_OPERATION';
   c_vc_column_source_db           t_object_name := 'DWH_SOURCE_ID';
   c_vc_column_partition           t_object_name := 'DWH_PARTITION_ID';
   c_vc_column_system_src          t_object_name := 'DWH_SYSTEM';
   c_vc_column_active_version      t_object_name := 'DWH_ACTIVE';
   /**
    * Grantees
    */
   c_vc_list_grantee               t_string := 'DWHCORE';
END dwhutl_stag_param;
2014-11-28 13:53:24.457 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_param/stag_param-def.sql executed
2014-11-28 13:53:24.457 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_stat/stag_stat-def.sql delimiter 
2014-11-28 13:53:24.458 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stag_stat
   AUTHID CURRENT_USER
AS
   /**
   * Package containing tools to collect statistics and size of STAGE tables
   *
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
    * Set global load id
    */
   --PROCEDURE prc_set_load_id;
   /**
    * Create a synonym for a given object
    *
    * @param p_vc_source_code       Source name
    * @param p_vc_object_name       Object name
    * @param p_n_partition          Table partition
    * @param p_vc_stat_type_code    Statistics type
    */
   FUNCTION prc_stat_begin (
      p_vc_source_code       VARCHAR2
    , p_vc_object_name       VARCHAR2
    , p_n_partition          NUMBER DEFAULT NULL
    , p_vc_stat_type_code    VARCHAR2 DEFAULT NULL
   )
      RETURN NUMBER;

   PROCEDURE prc_stat_end (
      p_n_stat_id       NUMBER
    , p_n_stat_value    NUMBER DEFAULT 0
    , p_n_stat_error    NUMBER DEFAULT 0
   );

   PROCEDURE prc_stat_purge;

   PROCEDURE prc_size_store (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_table_name     VARCHAR2
   );
END p#frm#stag_stat;
2014-11-28 13:53:24.458 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stag_stat
   AUTHID CURRENT_USER
AS
   /**
   * Package containing tools to collect statistics and size of STAGE tables
   *
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
    * Set global load id
    */
   --PROCEDURE prc_set_load_id;
   /**
    * Create a synonym for a given object
    *
    * @param p_vc_source_code       Source name
    * @param p_vc_object_name       Object name
    * @param p_n_partition          Table partition
    * @param p_vc_stat_type_code    Statistics type
    */
   FUNCTION prc_stat_begin (
      p_vc_source_code       VARCHAR2
    , p_vc_object_name       VARCHAR2
    , p_n_partition          NUMBER DEFAULT NULL
    , p_vc_stat_type_code    VARCHAR2 DEFAULT NULL
   )
      RETURN NUMBER;

   PROCEDURE prc_stat_end (
      p_n_stat_id       NUMBER
    , p_n_stat_value    NUMBER DEFAULT 0
    , p_n_stat_error    NUMBER DEFAULT 0
   );

   PROCEDURE prc_stat_purge;

   PROCEDURE prc_size_store (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_table_name     VARCHAR2
   );
END dwhutl_stag_stat;
2014-11-28 13:53:24.472 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_stat/stag_stat-def.sql executed
2014-11-28 13:53:24.473 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_stat/stag_stat-impl.sql delimiter 
2014-11-28 13:53:24.474 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#stag_stat
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   FUNCTION prc_stat_begin (
      p_vc_source_code       VARCHAR2
    , p_vc_object_name       VARCHAR2
    , p_n_partition          NUMBER DEFAULT NULL
    , p_vc_stat_type_code    VARCHAR2 DEFAULT NULL
   )
      RETURN NUMBER
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
      l_n_stat_type_id   NUMBER;
      l_n_object_id      NUMBER;
      l_n_result         NUMBER;
      l_n_load_id        NUMBER;
   BEGIN
      BEGIN
         /*l_n_load_id    := TO_NUMBER (pkg_utl_parameter.get_parameter ('STAGE_LOAD_ID'
                                                                     , 'STAGE'
                                                                     , 'STAGE'
                                                                      ));*/
         NULL;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      DBMS_APPLICATION_INFO.set_module (
            'OBJECT '
         || p_vc_object_name
       ,    'STAGE PART'
         || p_n_partition
         || ' '
         || p_vc_stat_type_code
      );

      SELECT MIN (stag_object_id)
        INTO l_n_object_id
        FROM p#frm#stag_source_t s
           , p#frm#stag_object_t o
       WHERE s.stag_source_id = o.stag_source_id
         AND s.stag_source_code = p_vc_source_code
         AND o.stag_object_name = p_vc_object_name;

      SELECT MIN (stag_stat_type_id)
        INTO l_n_stat_type_id
        FROM p#frm#stag_stat_type_t
       WHERE stag_stat_type_code = p_vc_stat_type_code;

      INSERT INTO p#frm#stag_stat_t (
                     stag_object_id
                   , stag_partition
                   , stag_load_id
                   , stag_stat_type_id
                   , stag_stat_sid
                  )
           VALUES (
                     l_n_object_id
                   , p_n_partition
                   , l_n_load_id
                   , l_n_stat_type_id
                   , TO_NUMBER (SYS_CONTEXT (
                                   'USERENV'
                                 , 'SESSIONID'
                                ))
                  )
        RETURNING stag_stat_id
             INTO l_n_result;

      COMMIT;
      RETURN l_n_result;
   END prc_stat_begin;

   PROCEDURE prc_stat_end (
      p_n_stat_id       NUMBER
    , p_n_stat_value    NUMBER DEFAULT 0
    , p_n_stat_error    NUMBER DEFAULT 0
   )
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      UPDATE p#frm#stag_stat_t
         SET stag_stat_value = p_n_stat_value
           , stag_stat_error = p_n_stat_error
       WHERE stag_stat_id = p_n_stat_id;

      COMMIT;
   END prc_stat_end;

   PROCEDURE prc_stat_purge
   IS
   BEGIN
      DELETE p#frm#stag_stat_t
       WHERE stag_stat_value IS NULL;

      COMMIT;
   END prc_stat_purge;

   PROCEDURE prc_size_store (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_table_name     VARCHAR2
   )
   IS
   BEGIN
      INSERT INTO p#frm#stag_size_t (
                     stag_object_id
                   , stag_table_name
                   , stag_num_rows
                   , stag_bytes
                  )
           SELECT ob.stag_object_id
                , p_vc_table_name
                , tb.num_rows
                , SUM (sg.bytes)
             FROM p#frm#stag_object_t ob
                , p#frm#stag_source_t sr
                , user_tables tb
                , user_segments sg
            WHERE ob.stag_source_id = sr.stag_source_id
              AND sr.stag_source_code = p_vc_source_code
              AND ob.stag_object_name = p_vc_object_name
              AND tb.table_name = p_vc_table_name
              AND sg.segment_name = p_vc_table_name
         GROUP BY ob.stag_object_id
                , p_vc_table_name
                , tb.num_rows;

      COMMIT;
   END prc_size_store;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#stag_stat;
2014-11-28 13:53:24.483 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_stag_stat
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   FUNCTION prc_stat_begin (
      p_vc_source_code       VARCHAR2
    , p_vc_object_name       VARCHAR2
    , p_n_partition          NUMBER DEFAULT NULL
    , p_vc_stat_type_code    VARCHAR2 DEFAULT NULL
   )
      RETURN NUMBER
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
      l_n_stat_type_id   NUMBER;
      l_n_object_id      NUMBER;
      l_n_result         NUMBER;
      l_n_load_id        NUMBER;
   BEGIN
      BEGIN
         /*l_n_load_id    := TO_NUMBER (pkg_utl_parameter.get_parameter ('STAGE_LOAD_ID'
                                                                     , 'STAGE'
                                                                     , 'STAGE'
                                                                      ));*/
         NULL;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;

      DBMS_APPLICATION_INFO.set_module (
            'OBJECT '
         || p_vc_object_name
       ,    'STAGE PART'
         || p_n_partition
         || ' '
         || p_vc_stat_type_code
      );

      SELECT MIN (stag_object_id)
        INTO l_n_object_id
        FROM dwhutl_stag_source_t s
           , dwhutl_stag_object_t o
       WHERE s.stag_source_id = o.stag_source_id
         AND s.stag_source_code = p_vc_source_code
         AND o.stag_object_name = p_vc_object_name;

      SELECT MIN (stag_stat_type_id)
        INTO l_n_stat_type_id
        FROM dwhutl_stag_stat_type_t
       WHERE stag_stat_type_code = p_vc_stat_type_code;

      INSERT INTO dwhutl_stag_stat_t (
                     stag_object_id
                   , stag_partition
                   , stag_load_id
                   , stag_stat_type_id
                   , stag_stat_sid
                  )
           VALUES (
                     l_n_object_id
                   , p_n_partition
                   , l_n_load_id
                   , l_n_stat_type_id
                   , TO_NUMBER (SYS_CONTEXT (
                                   'USERENV'
                                 , 'SESSIONID'
                                ))
                  )
        RETURNING stag_stat_id
             INTO l_n_result;

      COMMIT;
      RETURN l_n_result;
   END prc_stat_begin;

   PROCEDURE prc_stat_end (
      p_n_stat_id       NUMBER
    , p_n_stat_value    NUMBER DEFAULT 0
    , p_n_stat_error    NUMBER DEFAULT 0
   )
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      UPDATE dwhutl_stag_stat_t
         SET stag_stat_value = p_n_stat_value
           , stag_stat_error = p_n_stat_error
       WHERE stag_stat_id = p_n_stat_id;

      COMMIT;
   END prc_stat_end;

   PROCEDURE prc_stat_purge
   IS
   BEGIN
      DELETE dwhutl_stag_stat_t
       WHERE stag_stat_value IS NULL;

      COMMIT;
   END prc_stat_purge;

   PROCEDURE prc_size_store (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_table_name     VARCHAR2
   )
   IS
   BEGIN
      INSERT INTO dwhutl_stag_size_t (
                     stag_object_id
                   , stag_table_name
                   , stag_num_rows
                   , stag_bytes
                  )
           SELECT ob.stag_object_id
                , p_vc_table_name
                , tb.num_rows
                , SUM (sg.bytes)
             FROM dwhutl_stag_object_t ob
                , dwhutl_stag_source_t sr
                , user_tables tb
                , user_segments sg
            WHERE ob.stag_source_id = sr.stag_source_id
              AND sr.stag_source_code = p_vc_source_code
              AND ob.stag_object_name = p_vc_object_name
              AND tb.table_name = p_vc_table_name
              AND sg.segment_name = p_vc_table_name
         GROUP BY ob.stag_object_id
                , p_vc_table_name
                , tb.num_rows;

      COMMIT;
   END prc_size_store;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_stag_stat;
2014-11-28 13:53:24.624 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_stat/stag_stat-impl.sql executed
2014-11-28 13:53:24.624 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_meta/stag_meta-def.sql delimiter 
2014-11-28 13:53:24.627 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stag_meta
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   FUNCTION fct_get_column_list (
      p_vc_object_id     IN NUMBER
    , p_vc_column_type   IN VARCHAR2
    , p_vc_list_type     IN VARCHAR2
    , p_vc_alias1        IN VARCHAR2 DEFAULT NULL
    , p_vc_alias2        IN VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   PROCEDURE prc_stat_type_ins (
      p_vc_type_code   IN VARCHAR2
    , p_vc_type_name   IN VARCHAR2
    , p_vc_type_desc   IN VARCHAR2
   );

   PROCEDURE prc_source_ins (
      p_vc_source_code      IN VARCHAR2
    , p_vc_source_prefix    IN VARCHAR2
    , p_vc_source_name      IN VARCHAR2
    , p_vc_stage_owner      IN VARCHAR2
    , p_vc_ts_stg1_data     IN VARCHAR2
    , p_vc_ts_stg1_indx     IN VARCHAR2
    , p_vc_ts_stg2_data     IN VARCHAR2
    , p_vc_ts_stg2_indx     IN VARCHAR2
    , p_vc_fb_archive       IN VARCHAR2 DEFAULT NULL
    , p_vc_bodi_ds          IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds   IN VARCHAR2 DEFAULT NULL
   );

   PROCEDURE prc_source_del (
      p_vc_source_code   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_source_db_ins (
      p_vc_source_code          IN VARCHAR2
    , p_vc_distribution_code    IN VARCHAR2
    , p_vc_source_db_link       IN VARCHAR2
    , p_vc_source_owner         IN VARCHAR2
    , p_vc_source_db_jdbcname   IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds       IN VARCHAR2 DEFAULT NULL
   );

   PROCEDURE prc_object_ins (
      p_vc_source_code        IN VARCHAR2
    , p_vc_object_name        IN VARCHAR2
    , p_n_parallel_degree     IN NUMBER DEFAULT NULL
    , p_vc_filter_clause      IN VARCHAR2 DEFAULT NULL
    , p_vc_partition_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_hist_flag          IN NUMBER DEFAULT 1
    , p_vc_fbda_flag          IN NUMBER DEFAULT 0
    , p_vc_increment_buffer   IN NUMBER DEFAULT NULL
   );

   PROCEDURE prc_object_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_column_ins (
      p_vc_source_code       IN VARCHAR2
    , p_vc_object_name       IN VARCHAR2
    , p_vc_column_name       IN VARCHAR2
    , p_vc_column_name_map   IN VARCHAR2 DEFAULT NULL
    , p_vc_column_def        IN VARCHAR2 DEFAULT NULL
    , p_n_column_pos         IN NUMBER DEFAULT NULL
    , p_n_column_nk_pos      IN NUMBER DEFAULT NULL
    , p_n_column_incr_flag   IN NUMBER DEFAULT 0
    , p_n_column_hist_flag   IN NUMBER DEFAULT 1
    , p_n_column_edwh_flag   IN NUMBER DEFAULT 1
   );

   PROCEDURE prc_column_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_vc_column_name   IN VARCHAR2
   );

   PROCEDURE prc_column_import_from_source (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   );

   PROCEDURE prc_column_import_from_stage (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   );

   PROCEDURE prc_check_column_changes (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   );

   PROCEDURE prc_set_object_properties;
END p#frm#stag_meta;
2014-11-28 13:53:24.627 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stag_meta
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   FUNCTION fct_get_column_list (
      p_vc_object_id     IN NUMBER
    , p_vc_column_type   IN VARCHAR2
    , p_vc_list_type     IN VARCHAR2
    , p_vc_alias1        IN VARCHAR2 DEFAULT NULL
    , p_vc_alias2        IN VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   PROCEDURE prc_stat_type_ins (
      p_vc_type_code   IN VARCHAR2
    , p_vc_type_name   IN VARCHAR2
    , p_vc_type_desc   IN VARCHAR2
   );

   PROCEDURE prc_source_ins (
      p_vc_source_code      IN VARCHAR2
    , p_vc_source_prefix    IN VARCHAR2
    , p_vc_source_name      IN VARCHAR2
    , p_vc_stage_owner      IN VARCHAR2
    , p_vc_ts_stg1_data     IN VARCHAR2
    , p_vc_ts_stg1_indx     IN VARCHAR2
    , p_vc_ts_stg2_data     IN VARCHAR2
    , p_vc_ts_stg2_indx     IN VARCHAR2
    , p_vc_fb_archive       IN VARCHAR2 DEFAULT NULL
    , p_vc_bodi_ds          IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds   IN VARCHAR2 DEFAULT NULL
   );

   PROCEDURE prc_source_del (
      p_vc_source_code   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_source_db_ins (
      p_vc_source_code          IN VARCHAR2
    , p_vc_distribution_code    IN VARCHAR2
    , p_vc_source_db_link       IN VARCHAR2
    , p_vc_source_owner         IN VARCHAR2
    , p_vc_source_db_jdbcname   IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds       IN VARCHAR2 DEFAULT NULL
   );

   PROCEDURE prc_object_ins (
      p_vc_source_code        IN VARCHAR2
    , p_vc_object_name        IN VARCHAR2
    , p_n_parallel_degree     IN NUMBER DEFAULT NULL
    , p_vc_filter_clause      IN VARCHAR2 DEFAULT NULL
    , p_vc_partition_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_hist_flag          IN NUMBER DEFAULT 1
    , p_vc_fbda_flag          IN NUMBER DEFAULT 0
    , p_vc_increment_buffer   IN NUMBER DEFAULT NULL
   );

   PROCEDURE prc_object_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_column_ins (
      p_vc_source_code       IN VARCHAR2
    , p_vc_object_name       IN VARCHAR2
    , p_vc_column_name       IN VARCHAR2
    , p_vc_column_name_map   IN VARCHAR2 DEFAULT NULL
    , p_vc_column_def        IN VARCHAR2 DEFAULT NULL
    , p_n_column_pos         IN NUMBER DEFAULT NULL
    , p_n_column_nk_pos      IN NUMBER DEFAULT NULL
    , p_n_column_incr_flag   IN NUMBER DEFAULT 0
    , p_n_column_hist_flag   IN NUMBER DEFAULT 1
    , p_n_column_edwh_flag   IN NUMBER DEFAULT 1
   );

   PROCEDURE prc_column_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_vc_column_name   IN VARCHAR2
   );

   PROCEDURE prc_column_import_from_source (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   );

   PROCEDURE prc_column_import_from_stage (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   );

   PROCEDURE prc_check_column_changes (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   );

   PROCEDURE prc_set_object_properties;
END dwhutl_stag_meta;
2014-11-28 13:53:24.655 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_meta/stag_meta-def.sql executed
2014-11-28 13:53:24.655 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_meta/stag_meta-impl.sql delimiter 
2014-11-28 13:53:24.657 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#stag_meta
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   /**
   * Table containing dictionary values
   */
   TYPE r_column IS RECORD (
      stag_column_pos         NUMBER
    , stag_column_name        VARCHAR2 (4000)
    , stag_column_comment     VARCHAR2 (4000)
    , stag_column_type        VARCHAR2 (4000)
    , stag_column_length      VARCHAR2 (4000)
    , stag_column_precision   VARCHAR2 (4000)
    , stag_column_scale       VARCHAR2 (4000)
    , stag_column_def         VARCHAR2 (4000)
    , stag_column_nk_pos      NUMBER
   );

   TYPE t_t_columns IS TABLE OF r_column;

   l_t_columns      t_t_columns := NULL;
   /**
   * Other types
   */
   l_sql_col_def    CLOB := p#frm#dict.c_sql_col_def;
   l_n_pk_pos_max   NUMBER;

   FUNCTION fct_get_column_list (
      p_vc_object_id     IN NUMBER
    , p_vc_column_type   IN VARCHAR2
    , p_vc_list_type     IN VARCHAR2
    , p_vc_alias1        IN VARCHAR2 DEFAULT NULL
    , p_vc_alias2        IN VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      l_vc_list   t_string;
   BEGIN
      -- Build list of columns
      FOR r_col IN (  SELECT stag_column_name
                        FROM p#frm#stag_column_t
                       WHERE stag_object_id = p_vc_object_id
                         AND stag_column_edwh_flag = 1
                         AND (p_vc_column_type = 'ALL'
                           OR (p_vc_column_type = 'PK'
                           AND stag_column_nk_pos IS NOT NULL)
                           OR (p_vc_column_type = 'NPK'
                           AND stag_column_nk_pos IS NULL))
                    ORDER BY stag_column_nk_pos
                           , stag_column_pos) LOOP
         l_vc_list :=
               l_vc_list
            || CHR (10)
            || CASE p_vc_list_type
                  WHEN 'LIST_SIMPLE' THEN
                        r_col.stag_column_name
                     || ', '
                  WHEN 'LIST_ALIAS' THEN
                        p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                  WHEN 'SET_ALIAS' THEN
                        p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ' = '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                  WHEN 'LIST_NVL2' THEN
                        'NVL2 ('
                     || p_vc_alias1
                     || '.rowid, '
                     || p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ') AS '
                     || r_col.stag_column_name
                     || ', '
                  WHEN 'AND_NOTNULL' THEN
                        r_col.stag_column_name
                     || ' IS NOT NULL AND '
                  WHEN 'AND_ALIAS' THEN
                        p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ' = '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ' AND '
                  WHEN 'OR_DECODE' THEN
                        'DECODE ('
                     || p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ', 0, 1) = 1 OR '
               END;
      END LOOP;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type IN ('AND_NOTNULL', 'AND_ALIAS') THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      RETURN l_vc_list;
   END fct_get_column_list;

   PROCEDURE prc_stat_type_ins (
      p_vc_type_code   IN VARCHAR2
    , p_vc_type_name   IN VARCHAR2
    , p_vc_type_desc   IN VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO p#frm#stag_stat_type_t trg
           USING (SELECT p_vc_type_code AS type_code
                       , p_vc_type_name AS type_name
                       , p_vc_type_desc AS type_desc
                    FROM DUAL) src
              ON (trg.stag_stat_type_code = src.type_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_stat_type_name = src.type_name
                  , trg.stag_stat_type_desc = src.type_desc
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_stat_type_code
                     , trg.stag_stat_type_name
                     , trg.stag_stat_type_desc
                    )
             VALUES (
                       src.type_code
                     , src.type_name
                     , src.type_desc
                    );

      COMMIT;
   END prc_stat_type_ins;

   PROCEDURE prc_source_ins (
      p_vc_source_code      IN VARCHAR2
    , p_vc_source_prefix    IN VARCHAR2
    , p_vc_source_name      IN VARCHAR2
    , p_vc_stage_owner      IN VARCHAR2
    , p_vc_ts_stg1_data     IN VARCHAR2
    , p_vc_ts_stg1_indx     IN VARCHAR2
    , p_vc_ts_stg2_data     IN VARCHAR2
    , p_vc_ts_stg2_indx     IN VARCHAR2
    , p_vc_fb_archive       IN VARCHAR2 DEFAULT NULL
    , p_vc_bodi_ds          IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds   IN VARCHAR2 DEFAULT NULL
   )
   IS
   BEGIN
      MERGE INTO p#frm#stag_source_t trg
           USING (SELECT p_vc_source_code AS source_code
                       , p_vc_source_prefix AS source_prefix
                       , p_vc_source_name AS source_name
                       , p_vc_stage_owner AS stage_owner
                       , p_vc_ts_stg1_data AS ts_stg1_data
                       , p_vc_ts_stg1_indx AS ts_stg1_indx
                       , p_vc_ts_stg2_data AS ts_stg2_data
                       , p_vc_ts_stg2_indx AS ts_stg2_indx
                       , p_vc_fb_archive AS fb_archive
                       , p_vc_bodi_ds AS bodi_ds
                       , p_vc_source_bodi_ds AS source_bodi_ds
                    FROM DUAL) src
              ON (trg.stag_source_code = src.source_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_source_prefix = src.source_prefix
                  , trg.stag_source_name = src.source_name
                  , trg.stag_owner = src.stage_owner
                  , trg.stag_ts_stage_data = src.ts_stg1_data
                  , trg.stag_ts_stage_indx = src.ts_stg1_indx
                  , trg.stag_ts_hist_data = src.ts_stg2_data
                  , trg.stag_ts_hist_indx = src.ts_stg2_indx
                  , trg.stag_fb_archive = src.fb_archive
                  , trg.stag_bodi_ds = src.bodi_ds
                  , trg.stag_source_bodi_ds = src.source_bodi_ds
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_source_code
                     , trg.stag_source_prefix
                     , trg.stag_source_name
                     , trg.stag_owner
                     , trg.stag_ts_stage_data
                     , trg.stag_ts_stage_indx
                     , trg.stag_ts_hist_data
                     , trg.stag_ts_hist_indx
                     , trg.stag_fb_archive
                     , trg.stag_bodi_ds
                     , trg.stag_source_bodi_ds
                    )
             VALUES (
                       src.source_code
                     , src.source_prefix
                     , src.source_name
                     , src.stage_owner
                     , src.ts_stg1_data
                     , src.ts_stg1_indx
                     , src.ts_stg2_data
                     , src.ts_stg2_indx
                     , src.source_bodi_ds
                     , src.bodi_ds
                     , src.source_bodi_ds
                    );

      COMMIT;
   END prc_source_ins;

   PROCEDURE prc_source_del (
      p_vc_source_code   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_n_source_id   NUMBER;
      l_n_cnt         NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_n_cnt
        FROM p#frm#stag_source_t
       WHERE stag_source_code = p_vc_source_code;

      IF l_n_cnt > 0 THEN
         -- Get the key object id
         SELECT stag_source_id
           INTO l_n_source_id
           FROM p#frm#stag_source_t
          WHERE stag_source_code = p_vc_source_code;

         IF NOT p_b_cascade THEN
            SELECT COUNT (*)
              INTO l_n_cnt
              FROM p#frm#stag_object_t
             WHERE stag_source_id = l_n_source_id;

            IF l_n_cnt > 0 THEN
               raise_application_error (
                  -20001
                , 'Cannot delete source with objects'
               );
            END IF;
         END IF;

         -- Delete children objects
         FOR r_obj IN (SELECT stag_object_name
                         FROM p#frm#stag_object_t
                        WHERE stag_source_id = l_n_source_id) LOOP
            prc_object_del (
               p_vc_source_code
             , r_obj.stag_object_name
             , p_b_cascade
            );
         END LOOP;

         DELETE p#frm#stag_source_db_t
          WHERE stag_source_id = l_n_source_id;

         DELETE p#frm#stag_source_t
          WHERE stag_source_code = p_vc_source_code;

         COMMIT;
      END IF;
   END prc_source_del;

   PROCEDURE prc_source_db_ins (
      p_vc_source_code          IN VARCHAR2
    , p_vc_distribution_code    IN VARCHAR2
    , p_vc_source_db_link       IN VARCHAR2
    , p_vc_source_owner         IN VARCHAR2
    , p_vc_source_db_jdbcname   IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds       IN VARCHAR2 DEFAULT NULL
   )
   IS
   BEGIN
      MERGE INTO p#frm#stag_source_db_t trg
           USING (SELECT stag_source_id
                       , p_vc_distribution_code AS distribution_code
                       , p_vc_source_db_link AS source_db_link
                       , p_vc_source_db_jdbcname AS source_db_jdbcname
                       , p_vc_source_owner AS source_owner
                       , p_vc_source_bodi_ds AS source_bodi_ds
                    FROM p#frm#stag_source_t
                   WHERE stag_source_code = p_vc_source_code) src
              ON (trg.stag_source_id = src.stag_source_id
              AND trg.stag_distribution_code = src.distribution_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_source_db_link = src.source_db_link
                  , trg.stag_source_db_jdbcname = src.source_db_jdbcname
                  , trg.stag_source_owner = src.source_owner
                  , trg.stag_source_bodi_ds = src.source_bodi_ds
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_source_id
                     , trg.stag_distribution_code
                     , trg.stag_source_db_link
                     , trg.stag_source_db_jdbcname
                     , trg.stag_source_owner
                     , trg.stag_source_bodi_ds
                    )
             VALUES (
                       src.stag_source_id
                     , src.distribution_code
                     , src.source_db_link
                     , src.source_db_jdbcname
                     , src.source_owner
                     , src.source_bodi_ds
                    );

      COMMIT;
   END prc_source_db_ins;

   PROCEDURE prc_object_ins (
      p_vc_source_code        IN VARCHAR2
    , p_vc_object_name        IN VARCHAR2
    , p_n_parallel_degree     IN NUMBER DEFAULT NULL
    , p_vc_filter_clause      IN VARCHAR2 DEFAULT NULL
    , p_vc_partition_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_hist_flag          IN NUMBER DEFAULT 1
    , p_vc_fbda_flag          IN NUMBER DEFAULT 0
    , p_vc_increment_buffer   IN NUMBER DEFAULT NULL
   )
   IS
      l_vc_table_comment   t_string;
   BEGIN
      -- Set object
      MERGE INTO p#frm#stag_object_t trg
           USING (SELECT stag_source_id
                       , p_vc_object_name AS object_name
                       , p_n_parallel_degree AS parallel_degree
                       , p_vc_filter_clause AS filter_clause
                       , p_vc_partition_clause AS partition_clause
                       , p_vc_hist_flag AS hist_flag
                       , p_vc_fbda_flag AS fbda_flag
                       , p_vc_increment_buffer AS increment_buffer
                    FROM p#frm#stag_source_t
                   WHERE stag_source_code = p_vc_source_code) src
              ON (trg.stag_source_id = src.stag_source_id
              AND trg.stag_object_name = src.object_name)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_parallel_degree = parallel_degree
                  , trg.stag_filter_clause = filter_clause
                  , trg.stag_partition_clause = partition_clause
                  , trg.stag_hist_flag = src.hist_flag
                  , trg.stag_fbda_flag = src.fbda_flag
                  , trg.stag_increment_buffer = src.increment_buffer
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_source_id
                     , trg.stag_object_name
                     , trg.stag_parallel_degree
                     , trg.stag_filter_clause
                     , trg.stag_partition_clause
                     , trg.stag_hist_flag
                     , trg.stag_fbda_flag
                     , trg.stag_increment_buffer
                    )
             VALUES (
                       src.stag_source_id
                     , src.object_name
                     , src.parallel_degree
                     , src.filter_clause
                     , src.partition_clause
                     , src.hist_flag
                     , src.fbda_flag
                     , src.increment_buffer
                    );

      COMMIT;

      -- Get object comment from source
      FOR r_obj IN (  SELECT stag_source_db_link
                           , stag_source_owner
                           , stag_object_id
                           , stag_object_name
                        FROM (SELECT d.stag_source_db_link
                                   , d.stag_source_owner
                                   , o.stag_object_id
                                   , o.stag_object_name
                                   , ROW_NUMBER () OVER (PARTITION BY o.stag_object_id ORDER BY d.stag_source_db_id) AS source_db_order
                                FROM p#frm#stag_source_t s
                                   , p#frm#stag_source_db_t d
                                   , p#frm#stag_object_t o
                               WHERE s.stag_source_id = d.stag_source_id
                                 AND s.stag_source_id = o.stag_source_id
                                 AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                                 AND p_vc_object_name IN (o.stag_object_name, 'ALL'))
                       WHERE source_db_order = 1
                    ORDER BY stag_object_id) LOOP
         l_vc_table_comment :=
            p#frm#dict.fct_get_table_comment (
               r_obj.stag_source_db_link
             , r_obj.stag_source_owner
             , r_obj.stag_object_name
            );

         UPDATE p#frm#stag_object_t
            SET stag_object_comment = l_vc_table_comment
          WHERE stag_object_id = r_obj.stag_object_id;
      END LOOP;

      COMMIT;
   END prc_object_ins;

   PROCEDURE prc_object_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_n_object_id   NUMBER;
      l_n_cnt         NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_n_cnt
        FROM p#frm#stag_source_t s
           , p#frm#stag_object_t o
       WHERE s.stag_source_id = o.stag_source_id
         AND s.stag_source_code = p_vc_source_code
         AND o.stag_object_name = p_vc_object_name;

      IF l_n_cnt > 0 THEN
         -- Get the key object id
         SELECT o.stag_object_id
           INTO l_n_object_id
           FROM p#frm#stag_source_t s
              , p#frm#stag_object_t o
          WHERE s.stag_source_id = o.stag_source_id
            AND s.stag_source_code = p_vc_source_code
            AND o.stag_object_name = p_vc_object_name;

         IF NOT p_b_cascade THEN
            SELECT COUNT (*)
              INTO l_n_cnt
              FROM p#frm#stag_column_t
             WHERE stag_object_id = l_n_object_id;

            IF l_n_cnt > 0 THEN
               raise_application_error (
                  -20001
                , 'Cannot delete object with columns'
               );
            END IF;
         END IF;

         DELETE p#frm#stag_column_t
          WHERE stag_object_id = l_n_object_id;

         DELETE p#frm#stag_object_t
          WHERE stag_object_id = l_n_object_id;

         COMMIT;
      END IF;
   END prc_object_del;

   PROCEDURE prc_column_ins (
      p_vc_source_code       IN VARCHAR2
    , p_vc_object_name       IN VARCHAR2
    , p_vc_column_name       IN VARCHAR2
    , p_vc_column_name_map   IN VARCHAR2 DEFAULT NULL
    , p_vc_column_def        IN VARCHAR2 DEFAULT NULL
    , p_n_column_pos         IN NUMBER DEFAULT NULL
    , p_n_column_nk_pos      IN NUMBER DEFAULT NULL
    , p_n_column_incr_flag   IN NUMBER DEFAULT 0
    , p_n_column_hist_flag   IN NUMBER DEFAULT 1
    , p_n_column_edwh_flag   IN NUMBER DEFAULT 1
   )
   IS
   BEGIN
      MERGE INTO p#frm#stag_column_t trg
           USING (SELECT o.stag_object_id
                       , p_vc_object_name AS object_name
                       , p_vc_column_name AS column_name
                       , p_vc_column_name_map AS column_name_map
                       , p_vc_column_def AS column_def
                       , p_n_column_pos AS column_pos
                       , p_n_column_nk_pos AS column_nk_pos
                       , p_n_column_incr_flag AS column_incr_flag
                       , p_n_column_hist_flag AS column_hist_flag
                       , p_n_column_edwh_flag AS column_edwh_flag
                    FROM p#frm#stag_source_t s
                       , p#frm#stag_object_t o
                   WHERE s.stag_source_id = o.stag_source_id
                     AND s.stag_source_code = p_vc_source_code
                     AND o.stag_object_name = p_vc_object_name) src
              ON (trg.stag_object_id = src.stag_object_id
              AND trg.stag_column_name = src.column_name)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_column_name_map = NVL (src.column_name_map, trg.stag_column_name_map)
                  , trg.stag_column_def = NVL (src.column_def, trg.stag_column_def)
                  , trg.stag_column_pos = NVL (src.column_pos, trg.stag_column_pos)
                  , trg.stag_column_nk_pos = NVL (src.column_nk_pos, trg.stag_column_nk_pos)
                  , trg.stag_column_incr_flag = NVL (src.column_incr_flag, trg.stag_column_incr_flag)
                  , trg.stag_column_hist_flag = NVL (src.column_hist_flag, trg.stag_column_hist_flag)
                  , trg.stag_column_edwh_flag = NVL (src.column_edwh_flag, trg.stag_column_edwh_flag)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_object_id
                     , trg.stag_column_name
                     , trg.stag_column_name_map
                     , trg.stag_column_def
                     , trg.stag_column_pos
                     , trg.stag_column_nk_pos
                     , trg.stag_column_incr_flag
                     , trg.stag_column_hist_flag
                     , trg.stag_column_edwh_flag
                    )
             VALUES (
                       src.stag_object_id
                     , src.column_name
                     , src.column_name_map
                     , src.column_def
                     , src.column_pos
                     , src.column_nk_pos
                     , src.column_incr_flag
                     , src.column_hist_flag
                     , src.column_edwh_flag
                    );

      COMMIT;
   END prc_column_ins;

   PROCEDURE prc_column_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_vc_column_name   IN VARCHAR2
   )
   IS
   BEGIN
      DELETE p#frm#stag_column_t
       WHERE stag_object_id = (SELECT o.stag_object_id
                                 FROM p#frm#stag_source_t s
                                    , p#frm#stag_object_t o
                                WHERE s.stag_source_id = o.stag_source_id
                                  AND s.stag_source_code = p_vc_source_code
                                  AND o.stag_object_name = p_vc_object_name)
         AND stag_column_name = p_vc_column_name;

      COMMIT;
   END prc_column_del;

   PROCEDURE prc_column_import_from_source (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   )
   IS
      l_vc_prc_name   t_string := 'prc_column_import_from_source';
   BEGIN
      l_sql_col_def := p#frm#dict.c_sql_col_def;
      l_t_columns := NULL;
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Start'
      );

      FOR r_obj IN (SELECT stag_object_id
                         , stag_object_name
                         , stag_hist_flag
                         , stag_owner
                         , stag_source_owner
                         , stag_source_db_link
                      FROM (SELECT o.stag_object_id
                                 , o.stag_object_name
                                 , o.stag_hist_flag
                                 , s.stag_owner
                                 , d.stag_source_owner
                                 , d.stag_source_db_link
                                 , ROW_NUMBER () OVER (PARTITION BY o.stag_object_id ORDER BY d.stag_source_db_id) AS db_rank
                              FROM p#frm#stag_object_t o
                                 , p#frm#stag_source_t s
                                 , p#frm#stag_source_db_t d
                             WHERE o.stag_source_id = s.stag_source_id
                               AND s.stag_source_id = d.stag_source_id
                               AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                               AND p_vc_object_name IN (o.stag_object_name, 'ALL'))
                     WHERE db_rank = 1) LOOP
         l_n_pk_pos_max := NULL;
         p#frm#dict.g_vc_src_obj_dblink := r_obj.stag_source_db_link;
         p#frm#dict.prc_set_text_param (
            l_sql_col_def
          , 'sql_obj_pk'
          , CASE
               WHEN p_b_check_dependencies THEN
                  p#frm#dict.c_sql_obj_col_pk
               ELSE
                  p#frm#dict.c_sql_obj_col_pk_nodep
            END
         );
         p#frm#dict.prc_set_src_param (l_sql_col_def);

         EXECUTE IMMEDIATE l_sql_col_def
            BULK COLLECT INTO l_t_columns
            USING r_obj.stag_source_owner
                , r_obj.stag_object_name;

         FOR i IN l_t_columns.FIRST .. l_t_columns.LAST LOOP
            MERGE INTO p#frm#stag_column_t trg
                 USING (SELECT l_t_columns (i).stag_column_name AS stag_column_name
                             , l_t_columns (i).stag_column_comment AS stag_column_comment
                             , l_t_columns (i).stag_column_pos AS stag_column_pos
                             , l_t_columns (i).stag_column_type AS stag_column_type
                             , l_t_columns (i).stag_column_length AS stag_column_length
                             , l_t_columns (i).stag_column_precision AS stag_column_precision
                             , l_t_columns (i).stag_column_scale AS stag_column_scale
                             , l_t_columns (i).stag_column_def AS stag_column_def
                             , l_t_columns (i).stag_column_nk_pos AS stag_column_nk_pos
                          FROM DUAL) src
                    ON (trg.stag_column_name = src.stag_column_name
                    AND trg.stag_object_id = r_obj.stag_object_id)
            WHEN MATCHED THEN
               UPDATE SET trg.stag_column_pos = src.stag_column_pos
                        , trg.stag_column_type = src.stag_column_type
                        , trg.stag_column_length = src.stag_column_length
                        , trg.stag_column_precision = src.stag_column_precision
                        , trg.stag_column_scale = src.stag_column_scale
                        , trg.stag_column_def = src.stag_column_def
                        , trg.stag_column_comment = src.stag_column_comment
                        , trg.stag_column_nk_pos = src.stag_column_nk_pos
            WHEN NOT MATCHED THEN
               INSERT     (
                             trg.stag_object_id
                           , trg.stag_column_pos
                           , trg.stag_column_name
                           , trg.stag_column_comment
                           , trg.stag_column_type
                           , trg.stag_column_length
                           , trg.stag_column_precision
                           , trg.stag_column_scale
                           , trg.stag_column_def
                           , trg.stag_column_nk_pos
                           , trg.stag_column_edwh_flag
                           , trg.stag_column_hist_flag
                          )
                   VALUES (
                             r_obj.stag_object_id
                           , src.stag_column_pos
                           , src.stag_column_name
                           , src.stag_column_comment
                           , src.stag_column_type
                           , src.stag_column_length
                           , src.stag_column_precision
                           , src.stag_column_scale
                           , src.stag_column_def
                           , src.stag_column_nk_pos
                           , 1
                           , 1
                          );

            l_n_pk_pos_max :=
               GREATEST (
                  NVL (l_t_columns (i).stag_column_nk_pos, 0)
                , NVL (l_n_pk_pos_max, 0)
               );
         END LOOP;

         UPDATE p#frm#stag_object_t
            SET stag_source_nk_flag =
                   CASE
                      WHEN l_n_pk_pos_max > 0 THEN
                         1
                      ELSE
                         0
                   END
          WHERE stag_object_id = r_obj.stag_object_id;

         COMMIT;
      END LOOP;

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Finish'
      );
   END prc_column_import_from_source;

   PROCEDURE prc_column_import_from_stage (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   )
   IS
      l_vc_prc_name   t_string := 'prc_column_import_from_stage';
   BEGIN
      l_sql_col_def := p#frm#dict.c_sql_col_def;
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Start'
      );
      prc_set_object_properties;

      FOR r_obj IN (SELECT stag_owner
                         , stag_object_id
                         , stag_object_name
                         , stag_stage_table_name
                         , stag_hist_flag
                      FROM p#frm#stag_object_t o
                         , p#frm#stag_source_t s
                     WHERE o.stag_source_id = s.stag_source_id
                       AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                       AND p_vc_object_name IN (o.stag_object_name, 'ALL')) LOOP
         p#frm#dict.prc_set_text_param (
            l_sql_col_def
          , 'sql_obj_pk'
          , CASE
               WHEN p_b_check_dependencies THEN
                  p#frm#dict.c_sql_obj_col_pk
               ELSE
                  p#frm#dict.c_sql_obj_col_pk_nodep
            END
         );
         p#frm#dict.prc_set_src_param (l_sql_col_def);

         EXECUTE IMMEDIATE l_sql_col_def
            BULK COLLECT INTO l_t_columns
            USING r_obj.stag_owner
                , r_obj.stag_object_name;

         FOR i IN l_t_columns.FIRST .. l_t_columns.LAST LOOP
            MERGE INTO p#frm#stag_column_t trg
                 USING (SELECT l_t_columns (i).stag_column_name AS stag_column_name
                             , l_t_columns (i).stag_column_comment AS stag_column_comment
                             , l_t_columns (i).stag_column_pos AS stag_column_pos
                             , l_t_columns (i).stag_column_def AS stag_column_def
                             , l_t_columns (i).stag_column_nk_pos AS stag_column_nk_pos
                          FROM DUAL) src
                    ON (trg.stag_column_name = src.stag_column_name
                    AND trg.stag_object_id = r_obj.stag_object_id)
            WHEN MATCHED THEN
               UPDATE SET trg.stag_column_pos = src.stag_column_pos
                        , trg.stag_column_def = src.stag_column_def
                        , trg.stag_column_comment = src.stag_column_comment
                        , trg.stag_column_nk_pos = src.stag_column_nk_pos
            WHEN NOT MATCHED THEN
               INSERT     (
                             trg.stag_object_id
                           , trg.stag_column_pos
                           , trg.stag_column_name
                           , trg.stag_column_comment
                           , trg.stag_column_def
                           , trg.stag_column_nk_pos
                           , trg.stag_column_edwh_flag
                           , trg.stag_column_hist_flag
                          )
                   VALUES (
                             r_obj.stag_object_id
                           , src.stag_column_pos
                           , src.stag_column_name
                           , src.stag_column_comment
                           , src.stag_column_def
                           , src.stag_column_nk_pos
                           , 1
                           , 1
                          );

            l_n_pk_pos_max :=
               GREATEST (
                  NVL (l_t_columns (i).stag_column_nk_pos, 0)
                , l_n_pk_pos_max
               );
         END LOOP;

         UPDATE p#frm#stag_object_t
            SET stag_source_nk_flag =
                   CASE
                      WHEN l_n_pk_pos_max = 0 THEN
                         0
                      ELSE
                         1
                   END
          WHERE stag_object_id = r_obj.stag_object_id;

         COMMIT;
      END LOOP;

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Finish'
      );
   END prc_column_import_from_stage;

   PROCEDURE prc_check_column_changes (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   )
   IS
      l_vc_prc_name   t_string := 'prc_check_column_changes';
   BEGIN
      l_sql_col_def := p#frm#dict.c_sql_col_def;
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Check column changes'
       , 'Start'
      );

      FOR r_obj IN (  SELECT stag_source_id
                           , stag_source_code
                           , stag_source_db_link
                           , stag_source_owner
                           , stag_owner
                           , stag_object_id
                           , stag_object_name
                           , stag_stage_table_name
                        FROM (SELECT s.stag_source_id
                                   , s.stag_source_code
                                   , d.stag_source_db_link
                                   , d.stag_source_owner
                                   , s.stag_owner
                                   , o.stag_object_id
                                   , o.stag_object_name
                                   , o.stag_stage_table_name
                                   , ROW_NUMBER () OVER (PARTITION BY o.stag_object_id ORDER BY d.stag_source_db_id) AS source_db_order
                                FROM p#frm#stag_source_t s
                                   , p#frm#stag_source_db_t d
                                   , p#frm#stag_object_t o
                               WHERE s.stag_source_id = d.stag_source_id
                                 AND s.stag_source_id = o.stag_source_id
                                 AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                                 AND p_vc_object_name IN (o.stag_object_name, 'ALL'))
                       WHERE source_db_order = 1
                    ORDER BY stag_object_id) LOOP
         p#frm#dict.g_vc_src_obj_dblink := r_obj.stag_source_db_link;
         p#frm#dict.prc_set_text_param (
            l_sql_col_def
          , 'sql_obj_pk'
          , CASE
               WHEN p_b_check_dependencies THEN
                  p#frm#dict.c_sql_obj_col_pk
               ELSE
                  p#frm#dict.c_sql_obj_col_pk_nodep
            END
         );
         p#frm#dict.prc_set_src_param (l_sql_col_def);

         EXECUTE IMMEDIATE l_sql_col_def
            BULK COLLECT INTO l_t_columns
            USING r_obj.stag_source_owner
                , r_obj.stag_object_name;

         DELETE p#frm#stag_column_check_t
          WHERE stag_object_id = r_obj.stag_object_id;

         FOR i IN l_t_columns.FIRST .. l_t_columns.LAST LOOP
            MERGE INTO p#frm#stag_column_check_t trg
                 USING (SELECT l_t_columns (i).stag_column_name AS stag_column_name
                             , l_t_columns (i).stag_column_comment AS stag_column_comment
                             , l_t_columns (i).stag_column_pos AS stag_column_pos
                             , l_t_columns (i).stag_column_def AS stag_column_def
                             , l_t_columns (i).stag_column_nk_pos AS stag_column_nk_pos
                          FROM DUAL) src
                    ON (trg.stag_column_name = src.stag_column_name
                    AND trg.stag_object_id = r_obj.stag_object_id)
            WHEN MATCHED THEN
               UPDATE SET trg.stag_column_pos = src.stag_column_pos
                        , trg.stag_column_def = src.stag_column_def
                        , trg.stag_column_nk_pos = src.stag_column_nk_pos
            WHEN NOT MATCHED THEN
               INSERT     (
                             trg.stag_object_id
                           , trg.stag_column_pos
                           , trg.stag_column_name
                           , trg.stag_column_def
                           , trg.stag_column_nk_pos
                          )
                   VALUES (
                             r_obj.stag_object_id
                           , src.stag_column_pos
                           , src.stag_column_name
                           , src.stag_column_def
                           , src.stag_column_nk_pos
                          );
         END LOOP;

         COMMIT;
      END LOOP;

      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Check column changes'
       , 'Finish'
      );
   END;

   PROCEDURE prc_set_object_properties
   IS
   BEGIN
      -- Select all objects
      FOR r_obj IN (  SELECT stag_object_id
                           , stag_object_name
                           , stag_view_stage2_name
                           , CASE
                                WHEN root_cnt > 1 THEN
                                      SUBSTR (
                                         stag_object_root
                                       , 1
                                       , 25
                                      )
                                   || root_rank
                                ELSE
                                   stag_object_root
                             END
                                AS stag_object_root
                        FROM (SELECT t.*
                                   , COUNT (0) OVER (PARTITION BY stag_object_root) AS root_cnt
                                   , ROW_NUMBER () OVER (PARTITION BY stag_object_root ORDER BY stag_object_name) AS root_rank
                                FROM (SELECT o.stag_object_id
                                           , o.stag_object_name
                                           , SUBSTR (
                                                   CASE
                                                      WHEN s.stag_source_prefix IS NOT NULL THEN
                                                            s.stag_source_prefix
                                                         || '_'
                                                   END
                                                || o.stag_object_name
                                              , 1
                                              , 30
                                             )
                                                AS stag_view_stage2_name
                                           , SUBSTR (
                                                   CASE
                                                      WHEN s.stag_source_prefix IS NOT NULL THEN
                                                            s.stag_source_prefix
                                                         || '_'
                                                   END
                                                || o.stag_object_name
                                              , 1
                                              , 26
                                             )
                                                AS stag_object_root
                                        FROM p#frm#stag_source_t s
                                           , p#frm#stag_object_t o
                                       WHERE s.stag_source_id = o.stag_source_id) t)
                    ORDER BY stag_object_id) LOOP
         UPDATE p#frm#stag_object_t
            SET stag_object_root = r_obj.stag_object_root
              , stag_src_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_tab_source
              , stag_dupl_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_tab_dupl
              , stag_diff_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_tab_diff
              , stag_diff_nk_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_nk_diff
              , stag_stage_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_tab_stag
              , stag_hist_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_tab_hist
              , stag_hist_nk_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_nk_hist
              , stag_hist_view_name = r_obj.stag_view_stage2_name
              , stag_hist_fbda_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_view_fbda
              , stag_package_name =
                      r_obj.stag_object_root
                   || '_'
                   || p#frm#stag_param.c_vc_suffix_package
          WHERE stag_object_id = r_obj.stag_object_id;

         COMMIT;
      END LOOP;
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#stag_meta;
2014-11-28 13:53:24.659 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_stag_meta
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   /**
   * Table containing dictionary values
   */
   TYPE r_column IS RECORD (
      stag_column_pos         NUMBER
    , stag_column_name        VARCHAR2 (4000)
    , stag_column_comment     VARCHAR2 (4000)
    , stag_column_type        VARCHAR2 (4000)
    , stag_column_length      VARCHAR2 (4000)
    , stag_column_precision   VARCHAR2 (4000)
    , stag_column_scale       VARCHAR2 (4000)
    , stag_column_def         VARCHAR2 (4000)
    , stag_column_nk_pos      NUMBER
   );

   TYPE t_t_columns IS TABLE OF r_column;

   l_t_columns      t_t_columns := NULL;
   /**
   * Other types
   */
   l_sql_col_def    CLOB := dwhutl_dict.c_sql_col_def;
   l_n_pk_pos_max   NUMBER;

   FUNCTION fct_get_column_list (
      p_vc_object_id     IN NUMBER
    , p_vc_column_type   IN VARCHAR2
    , p_vc_list_type     IN VARCHAR2
    , p_vc_alias1        IN VARCHAR2 DEFAULT NULL
    , p_vc_alias2        IN VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      l_vc_list   t_string;
   BEGIN
      -- Build list of columns
      FOR r_col IN (  SELECT stag_column_name
                        FROM dwhutl_stag_column_t
                       WHERE stag_object_id = p_vc_object_id
                         AND stag_column_edwh_flag = 1
                         AND (p_vc_column_type = 'ALL'
                           OR (p_vc_column_type = 'PK'
                           AND stag_column_nk_pos IS NOT NULL)
                           OR (p_vc_column_type = 'NPK'
                           AND stag_column_nk_pos IS NULL))
                    ORDER BY stag_column_nk_pos
                           , stag_column_pos) LOOP
         l_vc_list :=
               l_vc_list
            || CHR (10)
            || CASE p_vc_list_type
                  WHEN 'LIST_SIMPLE' THEN
                        r_col.stag_column_name
                     || ', '
                  WHEN 'LIST_ALIAS' THEN
                        p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                  WHEN 'SET_ALIAS' THEN
                        p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ' = '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                  WHEN 'LIST_NVL2' THEN
                        'NVL2 ('
                     || p_vc_alias1
                     || '.rowid, '
                     || p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ') AS '
                     || r_col.stag_column_name
                     || ', '
                  WHEN 'AND_NOTNULL' THEN
                        r_col.stag_column_name
                     || ' IS NOT NULL AND '
                  WHEN 'AND_ALIAS' THEN
                        p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ' = '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ' AND '
                  WHEN 'OR_DECODE' THEN
                        'DECODE ('
                     || p_vc_alias1
                     || '.'
                     || r_col.stag_column_name
                     || ', '
                     || p_vc_alias2
                     || '.'
                     || r_col.stag_column_name
                     || ', 0, 1) = 1 OR '
               END;
      END LOOP;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type IN ('AND_NOTNULL', 'AND_ALIAS') THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      RETURN l_vc_list;
   END fct_get_column_list;

   PROCEDURE prc_stat_type_ins (
      p_vc_type_code   IN VARCHAR2
    , p_vc_type_name   IN VARCHAR2
    , p_vc_type_desc   IN VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO dwhutl_stag_stat_type_t trg
           USING (SELECT p_vc_type_code AS type_code
                       , p_vc_type_name AS type_name
                       , p_vc_type_desc AS type_desc
                    FROM DUAL) src
              ON (trg.stag_stat_type_code = src.type_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_stat_type_name = src.type_name
                  , trg.stag_stat_type_desc = src.type_desc
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_stat_type_code
                     , trg.stag_stat_type_name
                     , trg.stag_stat_type_desc
                    )
             VALUES (
                       src.type_code
                     , src.type_name
                     , src.type_desc
                    );

      COMMIT;
   END prc_stat_type_ins;

   PROCEDURE prc_source_ins (
      p_vc_source_code      IN VARCHAR2
    , p_vc_source_prefix    IN VARCHAR2
    , p_vc_source_name      IN VARCHAR2
    , p_vc_stage_owner      IN VARCHAR2
    , p_vc_ts_stg1_data     IN VARCHAR2
    , p_vc_ts_stg1_indx     IN VARCHAR2
    , p_vc_ts_stg2_data     IN VARCHAR2
    , p_vc_ts_stg2_indx     IN VARCHAR2
    , p_vc_fb_archive       IN VARCHAR2 DEFAULT NULL
    , p_vc_bodi_ds          IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds   IN VARCHAR2 DEFAULT NULL
   )
   IS
   BEGIN
      MERGE INTO dwhutl_stag_source_t trg
           USING (SELECT p_vc_source_code AS source_code
                       , p_vc_source_prefix AS source_prefix
                       , p_vc_source_name AS source_name
                       , p_vc_stage_owner AS stage_owner
                       , p_vc_ts_stg1_data AS ts_stg1_data
                       , p_vc_ts_stg1_indx AS ts_stg1_indx
                       , p_vc_ts_stg2_data AS ts_stg2_data
                       , p_vc_ts_stg2_indx AS ts_stg2_indx
                       , p_vc_fb_archive AS fb_archive
                       , p_vc_bodi_ds AS bodi_ds
                       , p_vc_source_bodi_ds AS source_bodi_ds
                    FROM DUAL) src
              ON (trg.stag_source_code = src.source_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_source_prefix = src.source_prefix
                  , trg.stag_source_name = src.source_name
                  , trg.stag_owner = src.stage_owner
                  , trg.stag_ts_stage_data = src.ts_stg1_data
                  , trg.stag_ts_stage_indx = src.ts_stg1_indx
                  , trg.stag_ts_hist_data = src.ts_stg2_data
                  , trg.stag_ts_hist_indx = src.ts_stg2_indx
                  , trg.stag_fb_archive = src.fb_archive
                  , trg.stag_bodi_ds = src.bodi_ds
                  , trg.stag_source_bodi_ds = src.source_bodi_ds
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_source_code
                     , trg.stag_source_prefix
                     , trg.stag_source_name
                     , trg.stag_owner
                     , trg.stag_ts_stage_data
                     , trg.stag_ts_stage_indx
                     , trg.stag_ts_hist_data
                     , trg.stag_ts_hist_indx
                     , trg.stag_fb_archive
                     , trg.stag_bodi_ds
                     , trg.stag_source_bodi_ds
                    )
             VALUES (
                       src.source_code
                     , src.source_prefix
                     , src.source_name
                     , src.stage_owner
                     , src.ts_stg1_data
                     , src.ts_stg1_indx
                     , src.ts_stg2_data
                     , src.ts_stg2_indx
                     , src.source_bodi_ds
                     , src.bodi_ds
                     , src.source_bodi_ds
                    );

      COMMIT;
   END prc_source_ins;

   PROCEDURE prc_source_del (
      p_vc_source_code   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_n_source_id   NUMBER;
      l_n_cnt         NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_n_cnt
        FROM dwhutl_stag_source_t
       WHERE stag_source_code = p_vc_source_code;

      IF l_n_cnt > 0 THEN
         -- Get the key object id
         SELECT stag_source_id
           INTO l_n_source_id
           FROM dwhutl_stag_source_t
          WHERE stag_source_code = p_vc_source_code;

         IF NOT p_b_cascade THEN
            SELECT COUNT (*)
              INTO l_n_cnt
              FROM dwhutl_stag_object_t
             WHERE stag_source_id = l_n_source_id;

            IF l_n_cnt > 0 THEN
               raise_application_error (
                  -20001
                , 'Cannot delete source with objects'
               );
            END IF;
         END IF;

         -- Delete children objects
         FOR r_obj IN (SELECT stag_object_name
                         FROM dwhutl_stag_object_t
                        WHERE stag_source_id = l_n_source_id) LOOP
            prc_object_del (
               p_vc_source_code
             , r_obj.stag_object_name
             , p_b_cascade
            );
         END LOOP;

         DELETE dwhutl_stag_source_db_t
          WHERE stag_source_id = l_n_source_id;

         DELETE dwhutl_stag_source_t
          WHERE stag_source_code = p_vc_source_code;

         COMMIT;
      END IF;
   END prc_source_del;

   PROCEDURE prc_source_db_ins (
      p_vc_source_code          IN VARCHAR2
    , p_vc_distribution_code    IN VARCHAR2
    , p_vc_source_db_link       IN VARCHAR2
    , p_vc_source_owner         IN VARCHAR2
    , p_vc_source_db_jdbcname   IN VARCHAR2 DEFAULT NULL
    , p_vc_source_bodi_ds       IN VARCHAR2 DEFAULT NULL
   )
   IS
   BEGIN
      MERGE INTO dwhutl_stag_source_db_t trg
           USING (SELECT stag_source_id
                       , p_vc_distribution_code AS distribution_code
                       , p_vc_source_db_link AS source_db_link
                       , p_vc_source_db_jdbcname AS source_db_jdbcname
                       , p_vc_source_owner AS source_owner
                       , p_vc_source_bodi_ds AS source_bodi_ds
                    FROM dwhutl_stag_source_t
                   WHERE stag_source_code = p_vc_source_code) src
              ON (trg.stag_source_id = src.stag_source_id
              AND trg.stag_distribution_code = src.distribution_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_source_db_link = src.source_db_link
                  , trg.stag_source_db_jdbcname = src.source_db_jdbcname
                  , trg.stag_source_owner = src.source_owner
                  , trg.stag_source_bodi_ds = src.source_bodi_ds
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_source_id
                     , trg.stag_distribution_code
                     , trg.stag_source_db_link
                     , trg.stag_source_db_jdbcname
                     , trg.stag_source_owner
                     , trg.stag_source_bodi_ds
                    )
             VALUES (
                       src.stag_source_id
                     , src.distribution_code
                     , src.source_db_link
                     , src.source_db_jdbcname
                     , src.source_owner
                     , src.source_bodi_ds
                    );

      COMMIT;
   END prc_source_db_ins;

   PROCEDURE prc_object_ins (
      p_vc_source_code        IN VARCHAR2
    , p_vc_object_name        IN VARCHAR2
    , p_n_parallel_degree     IN NUMBER DEFAULT NULL
    , p_vc_filter_clause      IN VARCHAR2 DEFAULT NULL
    , p_vc_partition_clause   IN VARCHAR2 DEFAULT NULL
    , p_vc_hist_flag          IN NUMBER DEFAULT 1
    , p_vc_fbda_flag          IN NUMBER DEFAULT 0
    , p_vc_increment_buffer   IN NUMBER DEFAULT NULL
   )
   IS
      l_vc_table_comment   t_string;
   BEGIN
      -- Set object
      MERGE INTO dwhutl_stag_object_t trg
           USING (SELECT stag_source_id
                       , p_vc_object_name AS object_name
                       , p_n_parallel_degree AS parallel_degree
                       , p_vc_filter_clause AS filter_clause
                       , p_vc_partition_clause AS partition_clause
                       , p_vc_hist_flag AS hist_flag
                       , p_vc_fbda_flag AS fbda_flag
                       , p_vc_increment_buffer AS increment_buffer
                    FROM dwhutl_stag_source_t
                   WHERE stag_source_code = p_vc_source_code) src
              ON (trg.stag_source_id = src.stag_source_id
              AND trg.stag_object_name = src.object_name)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_parallel_degree = parallel_degree
                  , trg.stag_filter_clause = filter_clause
                  , trg.stag_partition_clause = partition_clause
                  , trg.stag_hist_flag = src.hist_flag
                  , trg.stag_fbda_flag = src.fbda_flag
                  , trg.stag_increment_buffer = src.increment_buffer
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_source_id
                     , trg.stag_object_name
                     , trg.stag_parallel_degree
                     , trg.stag_filter_clause
                     , trg.stag_partition_clause
                     , trg.stag_hist_flag
                     , trg.stag_fbda_flag
                     , trg.stag_increment_buffer
                    )
             VALUES (
                       src.stag_source_id
                     , src.object_name
                     , src.parallel_degree
                     , src.filter_clause
                     , src.partition_clause
                     , src.hist_flag
                     , src.fbda_flag
                     , src.increment_buffer
                    );

      COMMIT;

      -- Get object comment from source
      FOR r_obj IN (  SELECT stag_source_db_link
                           , stag_source_owner
                           , stag_object_id
                           , stag_object_name
                        FROM (SELECT d.stag_source_db_link
                                   , d.stag_source_owner
                                   , o.stag_object_id
                                   , o.stag_object_name
                                   , ROW_NUMBER () OVER (PARTITION BY o.stag_object_id ORDER BY d.stag_source_db_id) AS source_db_order
                                FROM dwhutl_stag_source_t s
                                   , dwhutl_stag_source_db_t d
                                   , dwhutl_stag_object_t o
                               WHERE s.stag_source_id = d.stag_source_id
                                 AND s.stag_source_id = o.stag_source_id
                                 AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                                 AND p_vc_object_name IN (o.stag_object_name, 'ALL'))
                       WHERE source_db_order = 1
                    ORDER BY stag_object_id) LOOP
         l_vc_table_comment :=
            dwhutl_dict.fct_get_table_comment (
               r_obj.stag_source_db_link
             , r_obj.stag_source_owner
             , r_obj.stag_object_name
            );

         UPDATE dwhutl_stag_object_t
            SET stag_object_comment = l_vc_table_comment
          WHERE stag_object_id = r_obj.stag_object_id;
      END LOOP;

      COMMIT;
   END prc_object_ins;

   PROCEDURE prc_object_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_b_cascade        IN BOOLEAN DEFAULT FALSE
   )
   IS
      l_n_object_id   NUMBER;
      l_n_cnt         NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_n_cnt
        FROM dwhutl_stag_source_t s
           , dwhutl_stag_object_t o
       WHERE s.stag_source_id = o.stag_source_id
         AND s.stag_source_code = p_vc_source_code
         AND o.stag_object_name = p_vc_object_name;

      IF l_n_cnt > 0 THEN
         -- Get the key object id
         SELECT o.stag_object_id
           INTO l_n_object_id
           FROM dwhutl_stag_source_t s
              , dwhutl_stag_object_t o
          WHERE s.stag_source_id = o.stag_source_id
            AND s.stag_source_code = p_vc_source_code
            AND o.stag_object_name = p_vc_object_name;

         IF NOT p_b_cascade THEN
            SELECT COUNT (*)
              INTO l_n_cnt
              FROM dwhutl_stag_column_t
             WHERE stag_object_id = l_n_object_id;

            IF l_n_cnt > 0 THEN
               raise_application_error (
                  -20001
                , 'Cannot delete object with columns'
               );
            END IF;
         END IF;

         DELETE dwhutl_stag_column_t
          WHERE stag_object_id = l_n_object_id;

         DELETE dwhutl_stag_object_t
          WHERE stag_object_id = l_n_object_id;

         COMMIT;
      END IF;
   END prc_object_del;

   PROCEDURE prc_column_ins (
      p_vc_source_code       IN VARCHAR2
    , p_vc_object_name       IN VARCHAR2
    , p_vc_column_name       IN VARCHAR2
    , p_vc_column_name_map   IN VARCHAR2 DEFAULT NULL
    , p_vc_column_def        IN VARCHAR2 DEFAULT NULL
    , p_n_column_pos         IN NUMBER DEFAULT NULL
    , p_n_column_nk_pos      IN NUMBER DEFAULT NULL
    , p_n_column_incr_flag   IN NUMBER DEFAULT 0
    , p_n_column_hist_flag   IN NUMBER DEFAULT 1
    , p_n_column_edwh_flag   IN NUMBER DEFAULT 1
   )
   IS
   BEGIN
      MERGE INTO dwhutl_stag_column_t trg
           USING (SELECT o.stag_object_id
                       , p_vc_object_name AS object_name
                       , p_vc_column_name AS column_name
                       , p_vc_column_name_map AS column_name_map
                       , p_vc_column_def AS column_def
                       , p_n_column_pos AS column_pos
                       , p_n_column_nk_pos AS column_nk_pos
                       , p_n_column_incr_flag AS column_incr_flag
                       , p_n_column_hist_flag AS column_hist_flag
                       , p_n_column_edwh_flag AS column_edwh_flag
                    FROM dwhutl_stag_source_t s
                       , dwhutl_stag_object_t o
                   WHERE s.stag_source_id = o.stag_source_id
                     AND s.stag_source_code = p_vc_source_code
                     AND o.stag_object_name = p_vc_object_name) src
              ON (trg.stag_object_id = src.stag_object_id
              AND trg.stag_column_name = src.column_name)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_column_name_map = NVL (src.column_name_map, trg.stag_column_name_map)
                  , trg.stag_column_def = NVL (src.column_def, trg.stag_column_def)
                  , trg.stag_column_pos = NVL (src.column_pos, trg.stag_column_pos)
                  , trg.stag_column_nk_pos = NVL (src.column_nk_pos, trg.stag_column_nk_pos)
                  , trg.stag_column_incr_flag = NVL (src.column_incr_flag, trg.stag_column_incr_flag)
                  , trg.stag_column_hist_flag = NVL (src.column_hist_flag, trg.stag_column_hist_flag)
                  , trg.stag_column_edwh_flag = NVL (src.column_edwh_flag, trg.stag_column_edwh_flag)
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_object_id
                     , trg.stag_column_name
                     , trg.stag_column_name_map
                     , trg.stag_column_def
                     , trg.stag_column_pos
                     , trg.stag_column_nk_pos
                     , trg.stag_column_incr_flag
                     , trg.stag_column_hist_flag
                     , trg.stag_column_edwh_flag
                    )
             VALUES (
                       src.stag_object_id
                     , src.column_name
                     , src.column_name_map
                     , src.column_def
                     , src.column_pos
                     , src.column_nk_pos
                     , src.column_incr_flag
                     , src.column_hist_flag
                     , src.column_edwh_flag
                    );

      COMMIT;
   END prc_column_ins;

   PROCEDURE prc_column_del (
      p_vc_source_code   IN VARCHAR2
    , p_vc_object_name   IN VARCHAR2
    , p_vc_column_name   IN VARCHAR2
   )
   IS
   BEGIN
      DELETE dwhutl_stag_column_t
       WHERE stag_object_id = (SELECT o.stag_object_id
                                 FROM dwhutl_stag_source_t s
                                    , dwhutl_stag_object_t o
                                WHERE s.stag_source_id = o.stag_source_id
                                  AND s.stag_source_code = p_vc_source_code
                                  AND o.stag_object_name = p_vc_object_name)
         AND stag_column_name = p_vc_column_name;

      COMMIT;
   END prc_column_del;

   PROCEDURE prc_column_import_from_source (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   )
   IS
      l_vc_prc_name   t_string := 'prc_column_import_from_source';
   BEGIN
      l_sql_col_def := dwhutl_dict.c_sql_col_def;
      l_t_columns := NULL;
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Start'
      );

      FOR r_obj IN (SELECT stag_object_id
                         , stag_object_name
                         , stag_hist_flag
                         , stag_owner
                         , stag_source_owner
                         , stag_source_db_link
                      FROM (SELECT o.stag_object_id
                                 , o.stag_object_name
                                 , o.stag_hist_flag
                                 , s.stag_owner
                                 , d.stag_source_owner
                                 , d.stag_source_db_link
                                 , ROW_NUMBER () OVER (PARTITION BY o.stag_object_id ORDER BY d.stag_source_db_id) AS db_rank
                              FROM dwhutl_stag_object_t o
                                 , dwhutl_stag_source_t s
                                 , dwhutl_stag_source_db_t d
                             WHERE o.stag_source_id = s.stag_source_id
                               AND s.stag_source_id = d.stag_source_id
                               AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                               AND p_vc_object_name IN (o.stag_object_name, 'ALL'))
                     WHERE db_rank = 1) LOOP
         l_n_pk_pos_max := NULL;
         dwhutl_dict.g_vc_src_obj_dblink := r_obj.stag_source_db_link;
         dwhutl_dict.prc_set_text_param (
            l_sql_col_def
          , 'sql_obj_pk'
          , CASE
               WHEN p_b_check_dependencies THEN
                  dwhutl_dict.c_sql_obj_col_pk
               ELSE
                  dwhutl_dict.c_sql_obj_col_pk_nodep
            END
         );
         dwhutl_dict.prc_set_src_param (l_sql_col_def);

         EXECUTE IMMEDIATE l_sql_col_def
            BULK COLLECT INTO l_t_columns
            USING r_obj.stag_source_owner
                , r_obj.stag_object_name;

         FOR i IN l_t_columns.FIRST .. l_t_columns.LAST LOOP
            MERGE INTO dwhutl_stag_column_t trg
                 USING (SELECT l_t_columns (i).stag_column_name AS stag_column_name
                             , l_t_columns (i).stag_column_comment AS stag_column_comment
                             , l_t_columns (i).stag_column_pos AS stag_column_pos
                             , l_t_columns (i).stag_column_type AS stag_column_type
                             , l_t_columns (i).stag_column_length AS stag_column_length
                             , l_t_columns (i).stag_column_precision AS stag_column_precision
                             , l_t_columns (i).stag_column_scale AS stag_column_scale
                             , l_t_columns (i).stag_column_def AS stag_column_def
                             , l_t_columns (i).stag_column_nk_pos AS stag_column_nk_pos
                          FROM DUAL) src
                    ON (trg.stag_column_name = src.stag_column_name
                    AND trg.stag_object_id = r_obj.stag_object_id)
            WHEN MATCHED THEN
               UPDATE SET trg.stag_column_pos = src.stag_column_pos
                        , trg.stag_column_type = src.stag_column_type
                        , trg.stag_column_length = src.stag_column_length
                        , trg.stag_column_precision = src.stag_column_precision
                        , trg.stag_column_scale = src.stag_column_scale
                        , trg.stag_column_def = src.stag_column_def
                        , trg.stag_column_comment = src.stag_column_comment
                        , trg.stag_column_nk_pos = src.stag_column_nk_pos
            WHEN NOT MATCHED THEN
               INSERT     (
                             trg.stag_object_id
                           , trg.stag_column_pos
                           , trg.stag_column_name
                           , trg.stag_column_comment
                           , trg.stag_column_type
                           , trg.stag_column_length
                           , trg.stag_column_precision
                           , trg.stag_column_scale
                           , trg.stag_column_def
                           , trg.stag_column_nk_pos
                           , trg.stag_column_edwh_flag
                           , trg.stag_column_hist_flag
                          )
                   VALUES (
                             r_obj.stag_object_id
                           , src.stag_column_pos
                           , src.stag_column_name
                           , src.stag_column_comment
                           , src.stag_column_type
                           , src.stag_column_length
                           , src.stag_column_precision
                           , src.stag_column_scale
                           , src.stag_column_def
                           , src.stag_column_nk_pos
                           , 1
                           , 1
                          );

            l_n_pk_pos_max :=
               GREATEST (
                  NVL (l_t_columns (i).stag_column_nk_pos, 0)
                , NVL (l_n_pk_pos_max, 0)
               );
         END LOOP;

         UPDATE dwhutl_stag_object_t
            SET stag_source_nk_flag =
                   CASE
                      WHEN l_n_pk_pos_max > 0 THEN
                         1
                      ELSE
                         0
                   END
          WHERE stag_object_id = r_obj.stag_object_id;

         COMMIT;
      END LOOP;

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Finish'
      );
   END prc_column_import_from_source;

   PROCEDURE prc_column_import_from_stage (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   )
   IS
      l_vc_prc_name   t_string := 'prc_column_import_from_stage';
   BEGIN
      l_sql_col_def := dwhutl_dict.c_sql_col_def;
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Start'
      );
      prc_set_object_properties;

      FOR r_obj IN (SELECT stag_owner
                         , stag_object_id
                         , stag_object_name
                         , stag_stage_table_name
                         , stag_hist_flag
                      FROM dwhutl_stag_object_t o
                         , dwhutl_stag_source_t s
                     WHERE o.stag_source_id = s.stag_source_id
                       AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                       AND p_vc_object_name IN (o.stag_object_name, 'ALL')) LOOP
         dwhutl_dict.prc_set_text_param (
            l_sql_col_def
          , 'sql_obj_pk'
          , CASE
               WHEN p_b_check_dependencies THEN
                  dwhutl_dict.c_sql_obj_col_pk
               ELSE
                  dwhutl_dict.c_sql_obj_col_pk_nodep
            END
         );
         dwhutl_dict.prc_set_src_param (l_sql_col_def);

         EXECUTE IMMEDIATE l_sql_col_def
            BULK COLLECT INTO l_t_columns
            USING r_obj.stag_owner
                , r_obj.stag_object_name;

         FOR i IN l_t_columns.FIRST .. l_t_columns.LAST LOOP
            MERGE INTO dwhutl_stag_column_t trg
                 USING (SELECT l_t_columns (i).stag_column_name AS stag_column_name
                             , l_t_columns (i).stag_column_comment AS stag_column_comment
                             , l_t_columns (i).stag_column_pos AS stag_column_pos
                             , l_t_columns (i).stag_column_def AS stag_column_def
                             , l_t_columns (i).stag_column_nk_pos AS stag_column_nk_pos
                          FROM DUAL) src
                    ON (trg.stag_column_name = src.stag_column_name
                    AND trg.stag_object_id = r_obj.stag_object_id)
            WHEN MATCHED THEN
               UPDATE SET trg.stag_column_pos = src.stag_column_pos
                        , trg.stag_column_def = src.stag_column_def
                        , trg.stag_column_comment = src.stag_column_comment
                        , trg.stag_column_nk_pos = src.stag_column_nk_pos
            WHEN NOT MATCHED THEN
               INSERT     (
                             trg.stag_object_id
                           , trg.stag_column_pos
                           , trg.stag_column_name
                           , trg.stag_column_comment
                           , trg.stag_column_def
                           , trg.stag_column_nk_pos
                           , trg.stag_column_edwh_flag
                           , trg.stag_column_hist_flag
                          )
                   VALUES (
                             r_obj.stag_object_id
                           , src.stag_column_pos
                           , src.stag_column_name
                           , src.stag_column_comment
                           , src.stag_column_def
                           , src.stag_column_nk_pos
                           , 1
                           , 1
                          );

            l_n_pk_pos_max :=
               GREATEST (
                  NVL (l_t_columns (i).stag_column_nk_pos, 0)
                , l_n_pk_pos_max
               );
         END LOOP;

         UPDATE dwhutl_stag_object_t
            SET stag_source_nk_flag =
                   CASE
                      WHEN l_n_pk_pos_max = 0 THEN
                         0
                      ELSE
                         1
                   END
          WHERE stag_object_id = r_obj.stag_object_id;

         COMMIT;
      END LOOP;

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Prepare metadata'
       , 'Finish'
      );
   END prc_column_import_from_stage;

   PROCEDURE prc_check_column_changes (
      p_vc_source_code         IN VARCHAR2
    , p_vc_object_name         IN VARCHAR2 DEFAULT 'ALL'
    , p_b_check_dependencies   IN BOOLEAN DEFAULT TRUE
   )
   IS
      l_vc_prc_name   t_string := 'prc_check_column_changes';
   BEGIN
      l_sql_col_def := dwhutl_dict.c_sql_col_def;
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Check column changes'
       , 'Start'
      );

      FOR r_obj IN (  SELECT stag_source_id
                           , stag_source_code
                           , stag_source_db_link
                           , stag_source_owner
                           , stag_owner
                           , stag_object_id
                           , stag_object_name
                           , stag_stage_table_name
                        FROM (SELECT s.stag_source_id
                                   , s.stag_source_code
                                   , d.stag_source_db_link
                                   , d.stag_source_owner
                                   , s.stag_owner
                                   , o.stag_object_id
                                   , o.stag_object_name
                                   , o.stag_stage_table_name
                                   , ROW_NUMBER () OVER (PARTITION BY o.stag_object_id ORDER BY d.stag_source_db_id) AS source_db_order
                                FROM dwhutl_stag_source_t s
                                   , dwhutl_stag_source_db_t d
                                   , dwhutl_stag_object_t o
                               WHERE s.stag_source_id = d.stag_source_id
                                 AND s.stag_source_id = o.stag_source_id
                                 AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                                 AND p_vc_object_name IN (o.stag_object_name, 'ALL'))
                       WHERE source_db_order = 1
                    ORDER BY stag_object_id) LOOP
         dwhutl_dict.g_vc_src_obj_dblink := r_obj.stag_source_db_link;
         dwhutl_dict.prc_set_text_param (
            l_sql_col_def
          , 'sql_obj_pk'
          , CASE
               WHEN p_b_check_dependencies THEN
                  dwhutl_dict.c_sql_obj_col_pk
               ELSE
                  dwhutl_dict.c_sql_obj_col_pk_nodep
            END
         );
         dwhutl_dict.prc_set_src_param (l_sql_col_def);

         EXECUTE IMMEDIATE l_sql_col_def
            BULK COLLECT INTO l_t_columns
            USING r_obj.stag_source_owner
                , r_obj.stag_object_name;

         DELETE dwhutl_stag_column_check_t
          WHERE stag_object_id = r_obj.stag_object_id;

         FOR i IN l_t_columns.FIRST .. l_t_columns.LAST LOOP
            MERGE INTO dwhutl_stag_column_check_t trg
                 USING (SELECT l_t_columns (i).stag_column_name AS stag_column_name
                             , l_t_columns (i).stag_column_comment AS stag_column_comment
                             , l_t_columns (i).stag_column_pos AS stag_column_pos
                             , l_t_columns (i).stag_column_def AS stag_column_def
                             , l_t_columns (i).stag_column_nk_pos AS stag_column_nk_pos
                          FROM DUAL) src
                    ON (trg.stag_column_name = src.stag_column_name
                    AND trg.stag_object_id = r_obj.stag_object_id)
            WHEN MATCHED THEN
               UPDATE SET trg.stag_column_pos = src.stag_column_pos
                        , trg.stag_column_def = src.stag_column_def
                        , trg.stag_column_nk_pos = src.stag_column_nk_pos
            WHEN NOT MATCHED THEN
               INSERT     (
                             trg.stag_object_id
                           , trg.stag_column_pos
                           , trg.stag_column_name
                           , trg.stag_column_def
                           , trg.stag_column_nk_pos
                          )
                   VALUES (
                             r_obj.stag_object_id
                           , src.stag_column_pos
                           , src.stag_column_name
                           , src.stag_column_def
                           , src.stag_column_nk_pos
                          );
         END LOOP;

         COMMIT;
      END LOOP;

      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Check column changes'
       , 'Finish'
      );
   END;

   PROCEDURE prc_set_object_properties
   IS
   BEGIN
      -- Select all objects
      FOR r_obj IN (  SELECT stag_object_id
                           , stag_object_name
                           , stag_view_stage2_name
                           , CASE
                                WHEN root_cnt > 1 THEN
                                      SUBSTR (
                                         stag_object_root
                                       , 1
                                       , 25
                                      )
                                   || root_rank
                                ELSE
                                   stag_object_root
                             END
                                AS stag_object_root
                        FROM (SELECT t.*
                                   , COUNT (0) OVER (PARTITION BY stag_object_root) AS root_cnt
                                   , ROW_NUMBER () OVER (PARTITION BY stag_object_root ORDER BY stag_object_name) AS root_rank
                                FROM (SELECT o.stag_object_id
                                           , o.stag_object_name
                                           , SUBSTR (
                                                   CASE
                                                      WHEN s.stag_source_prefix IS NOT NULL THEN
                                                            s.stag_source_prefix
                                                         || '_'
                                                   END
                                                || o.stag_object_name
                                              , 1
                                              , 30
                                             )
                                                AS stag_view_stage2_name
                                           , SUBSTR (
                                                   CASE
                                                      WHEN s.stag_source_prefix IS NOT NULL THEN
                                                            s.stag_source_prefix
                                                         || '_'
                                                   END
                                                || o.stag_object_name
                                              , 1
                                              , 26
                                             )
                                                AS stag_object_root
                                        FROM dwhutl_stag_source_t s
                                           , dwhutl_stag_object_t o
                                       WHERE s.stag_source_id = o.stag_source_id) t)
                    ORDER BY stag_object_id) LOOP
         UPDATE dwhutl_stag_object_t
            SET stag_object_root = r_obj.stag_object_root
              , stag_src_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_tab_source
              , stag_dupl_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_tab_dupl
              , stag_diff_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_tab_diff
              , stag_diff_nk_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_nk_diff
              , stag_stage_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_tab_stag
              , stag_hist_table_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_tab_hist
              , stag_hist_nk_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_nk_hist
              , stag_hist_view_name = r_obj.stag_view_stage2_name
              , stag_hist_fbda_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_view_fbda
              , stag_package_name =
                      r_obj.stag_object_root
                   || '_'
                   || dwhutl_stag_param.c_vc_suffix_package
          WHERE stag_object_id = r_obj.stag_object_id;

         COMMIT;
      END LOOP;
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_stag_meta;
2014-11-28 13:53:24.973 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_meta/stag_meta-impl.sql executed
2014-11-28 13:53:24.973 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ddl/stag_ddl-def.sql delimiter 
2014-11-28 13:53:24.975 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stag_ddl
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version      CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url          CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version               VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                   VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   -- Object related identifiers
   g_n_object_id                NUMBER;
   g_n_source_nk_flag           NUMBER;
   g_n_fbda_flag                NUMBER;
   g_n_parallel_degree          NUMBER;
   g_vc_source_code             t_object_name;
   g_vc_object_name             t_object_name;
   g_vc_prefix_src              t_object_name;
   --
   g_vc_dblink                  t_object_name;
   g_vc_owner_src               t_object_name;
   g_vc_table_name_source       t_object_name;
   g_vc_source_identifier       t_object_name;
   --
   g_vc_owner_stg               t_object_name;
   g_vc_table_name_stage        t_object_name;
   g_vc_table_name_diff         t_object_name;
   g_vc_table_name_dupl         t_object_name;
   g_vc_table_name_hist         t_object_name;
   g_vc_table_comment           t_string;
   g_vc_nk_name_diff            t_object_name;
   g_vc_nk_name_stage           t_object_name;
   g_vc_nk_name_hist            t_object_name;
   g_vc_view_name_hist          t_object_name;
   g_vc_view_name_fbda          t_object_name;
   g_vc_package_main            t_object_name;
   g_vc_filter_clause           t_string;
   g_vc_dedupl_rank_clause      t_string;
   g_vc_partition_expr          t_string;
   g_vc_increment_column        t_string;
   g_vc_increment_coldef        t_string;
   g_n_increment_buffer         NUMBER;
   --
   g_vc_tablespace_stage_data   t_object_name;
   g_vc_tablespace_stage_indx   t_object_name;
   g_vc_tablespace_hist_data    t_object_name;
   g_vc_tablespace_hist_indx    t_object_name;
   g_vc_fb_archive              t_object_name;
   -- List of source related identifiers
   g_l_dblink                   DBMS_SQL.varchar2s;
   g_l_owner_src                DBMS_SQL.varchar2s;
   g_l_distr_code               DBMS_SQL.varchar2s;
   -- List of columns
   g_vc_col_def                 t_string;
   g_vc_col_all                 t_string;
   g_vc_col_pk_src              t_string;
   g_vc_col_pk                  t_string;
   --
   g_vc_col_hist                t_string;
   g_vc_col_update              t_string;

   PROCEDURE prc_create_stage_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_duplicate_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_diff_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_hist_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_hist_view (p_b_raise_flag BOOLEAN DEFAULT FALSE);

   PROCEDURE prc_create_hist_synonym (p_b_raise_flag BOOLEAN DEFAULT FALSE);

   PROCEDURE prc_create_fbda_view (p_b_raise_flag BOOLEAN DEFAULT FALSE);

   PROCEDURE prc_create_package_main (
      p_b_hist_only_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag        BOOLEAN DEFAULT FALSE
   );
END p#frm#stag_ddl;
2014-11-28 13:53:24.975 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stag_ddl
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version      CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url          CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version               VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                   VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   -- Object related identifiers
   g_n_object_id                NUMBER;
   g_n_source_nk_flag           NUMBER;
   g_n_fbda_flag                NUMBER;
   g_n_parallel_degree          NUMBER;
   g_vc_source_code             t_object_name;
   g_vc_object_name             t_object_name;
   g_vc_prefix_src              t_object_name;
   --
   g_vc_dblink                  t_object_name;
   g_vc_owner_src               t_object_name;
   g_vc_table_name_source       t_object_name;
   g_vc_source_identifier       t_object_name;
   --
   g_vc_owner_stg               t_object_name;
   g_vc_table_name_stage        t_object_name;
   g_vc_table_name_diff         t_object_name;
   g_vc_table_name_dupl         t_object_name;
   g_vc_table_name_hist         t_object_name;
   g_vc_table_comment           t_string;
   g_vc_nk_name_diff            t_object_name;
   g_vc_nk_name_stage           t_object_name;
   g_vc_nk_name_hist            t_object_name;
   g_vc_view_name_hist          t_object_name;
   g_vc_view_name_fbda          t_object_name;
   g_vc_package_main            t_object_name;
   g_vc_filter_clause           t_string;
   g_vc_dedupl_rank_clause      t_string;
   g_vc_partition_expr          t_string;
   g_vc_increment_column        t_string;
   g_vc_increment_coldef        t_string;
   g_n_increment_buffer         NUMBER;
   --
   g_vc_tablespace_stage_data   t_object_name;
   g_vc_tablespace_stage_indx   t_object_name;
   g_vc_tablespace_hist_data    t_object_name;
   g_vc_tablespace_hist_indx    t_object_name;
   g_vc_fb_archive              t_object_name;
   -- List of source related identifiers
   g_l_dblink                   DBMS_SQL.varchar2s;
   g_l_owner_src                DBMS_SQL.varchar2s;
   g_l_distr_code               DBMS_SQL.varchar2s;
   -- List of columns
   g_vc_col_def                 t_string;
   g_vc_col_all                 t_string;
   g_vc_col_pk_src              t_string;
   g_vc_col_pk                  t_string;
   --
   g_vc_col_hist                t_string;
   g_vc_col_update              t_string;

   PROCEDURE prc_create_stage_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_duplicate_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_diff_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_hist_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   );

   PROCEDURE prc_create_hist_view (p_b_raise_flag BOOLEAN DEFAULT FALSE);

   PROCEDURE prc_create_hist_synonym (p_b_raise_flag BOOLEAN DEFAULT FALSE);

   PROCEDURE prc_create_fbda_view (p_b_raise_flag BOOLEAN DEFAULT FALSE);

   PROCEDURE prc_create_package_main (
      p_b_hist_only_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag        BOOLEAN DEFAULT FALSE
   );
END dwhutl_stag_ddl;
2014-11-28 13:53:24.995 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ddl/stag_ddl-def.sql executed
2014-11-28 13:53:24.995 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ddl/stag_ddl-impl.sql delimiter 
2014-11-28 13:53:24.997 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#stag_ddl
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Templates for standard code tokens
   **/
   --
   c_token_utl_column_hist        t_string := '#validFromColumnName#, #validToColumnName#, #dmlOpColumnName#';
   c_token_utl_coldef_hist        t_string := '#validFromColumnName# DATE, #validToColumnName# DATE, #dmlOpColumnName# VARCHAR2(10)';
   c_token_utl_colval_hist        t_string := 'SYSDATE, TO_DATE(''99991231'',''yyyymmdd''), ''I''';
   c_token_utl_column_source_db   t_string := '#sourceDbColumnName#';
   c_token_utl_coldef_source_db   t_string := '#sourceDbColumnName# VARCHAR(100)';
   c_token_utl_column_partition   t_string := '#partitionColumnName#';
   c_token_utl_coldef_partition   t_string := '#partitionColumnName# NUMBER(1)';
   --
   c_token_diff_partition         CLOB
                                     :=    'PARTITION BY LIST ('
                                        || p#frm#stag_param.c_vc_column_dml_op
                                        || ')
    (  
	  PARTITION PI VALUES (''I'') NOLOGGING NOCOMPRESS
    , PARTITION PH VALUES (''H'') NOLOGGING NOCOMPRESS
    , PARTITION PU VALUES (''U'') NOLOGGING NOCOMPRESS
    , PARTITION PD VALUES (''D'') NOLOGGING NOCOMPRESS
    , PARTITION PR VALUES (''R'') NOLOGGING NOCOMPRESS
	)';
   c_token_diff_subpartition      CLOB
                                     :=    'PARTITION BY LIST (#partitionColumnName#)
    SUBPARTITION BY LIST ('
                                        || p#frm#stag_param.c_vc_column_dml_op
                                        || ')
    SUBPARTITION TEMPLATE 
    (  
        SUBPARTITION PI VALUES (''I''),
        SUBPARTITION PH VALUES (''H''),
        SUBPARTITION PU VALUES (''U''),
        SUBPARTITION PD VALUES (''D''),
        SUBPARTITION PR VALUES (''R'')
    )
    (
        PARTITION p0 VALUES (0) NOLOGGING NOCOMPRESS,
        PARTITION p1 VALUES (1) NOLOGGING NOCOMPRESS,
        PARTITION p2 VALUES (2) NOLOGGING NOCOMPRESS,
        PARTITION p3 VALUES (3) NOLOGGING NOCOMPRESS,
        PARTITION p4 VALUES (4) NOLOGGING NOCOMPRESS,
        PARTITION p5 VALUES (5) NOLOGGING NOCOMPRESS,
        PARTITION p6 VALUES (6) NOLOGGING NOCOMPRESS,
        PARTITION p7 VALUES (7) NOLOGGING NOCOMPRESS,
        PARTITION p8 VALUES (8) NOLOGGING NOCOMPRESS,
        PARTITION p9 VALUES (9) NOLOGGING NOCOMPRESS
    )';
   c_token_partition              CLOB := 'PARTITION BY LIST (#partitionColumnName#)
    (
        PARTITION p0 VALUES (0) NOLOGGING NOCOMPRESS,
        PARTITION p1 VALUES (1) NOLOGGING NOCOMPRESS,
        PARTITION p2 VALUES (2) NOLOGGING NOCOMPRESS,
        PARTITION p3 VALUES (3) NOLOGGING NOCOMPRESS,
        PARTITION p4 VALUES (4) NOLOGGING NOCOMPRESS,
        PARTITION p5 VALUES (5) NOLOGGING NOCOMPRESS,
        PARTITION p6 VALUES (6) NOLOGGING NOCOMPRESS,
        PARTITION p7 VALUES (7) NOLOGGING NOCOMPRESS,
        PARTITION p8 VALUES (8) NOLOGGING NOCOMPRESS,
        PARTITION p9 VALUES (9) NOLOGGING NOCOMPRESS
    )';
   -- Template to initialize run time statistics in a procedure
   -- Set the step number and the workflow
   c_token_prc_initialize         CLOB := '';
   -- Template to finalize run time statistics in a procedure
   -- Set the final step number and finalize job statistics
   c_token_prc_finalize           CLOB := '';
   -- Exception handler
   c_token_prc_exception          CLOB := 'p#frm#stag_stat.prc_stat_end(l_n_stat_id, 0, 1);';
   -- Standard parameters for a generated procedure
   c_token_prc_param              CLOB := 'p_n_stream NUMBER DEFAULT NULL';
   -- Code body for the wrapper procedure
   c_token_prc_wrapper            CLOB := '
        p#frm#trac.log_sub_debug (l_vc_prc_name, ''Staging Begin'', ''Start extracting from #tableName#'');

		#prcLoadStage#

        #prcLoadDiff#

		#prcLoadHist#

		#prcTruncStage#

		#prcTruncDiff#

        p#frm#trac.log_sub_debug (l_vc_prc_name, ''Staging End'', ''Stage completed for #tableName#'');';
   -- Statistics token
   c_token_analyze                CLOB := '
        l_n_stat_id := p#frm#stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', NULL, ''#statisticsType#'');
        
        DBMS_STATS.UNLOCK_TABLE_STATS (''#stgOwner#'', ''#tableName#'') ;
        DBMS_STATS.GATHER_TABLE_STATS (''#stgOwner#'', ''#tableName#'', NULL, 1);
        p#frm#stag_stat.prc_size_store(''#sourceCode#'', ''#objectName#'', ''#tableName#'');

        p#frm#stag_stat.prc_stat_end(l_n_stat_id, 0);

        p#frm#trac.log_sub_debug (l_vc_prc_name, ''STAT END'', ''#tableName# : Statistics gathered'');
        ';
   -- Check token of the init procedure
   c_token_check_table_isempty    CLOB := '
		  p#frm#trac.log_sub_debug (l_vc_prc_name, ''CHECK'', ''Check table #tableName# '');
        SELECT COUNT (*)
          INTO l_n_result
          FROM #tableName#
         WHERE rownum = 1;
         
        IF l_n_result = 0 THEN
              p#frm#trac.log_sub_debug (l_vc_prc_name, ''CHECK'', ''Table #tableName# is empty'');
        ELSE
            p#frm#trac.log_sub_error (l_vc_prc_name, ''CHECK'', ''Table #tableName# is not empty'');
            raise_application_error (-20000, ''Cannot init load non-empty table'');        
        END IF;';
   -- Insert token of the staging 1 procedure
   c_token_stage_get_incr_bound   CLOB := '
   
          p#frm#trac.log_sub_debug (l_vc_prc_name, ''INCR BOUND'', ''#tableName# #partition# : get last #incrementColumn#'');
   
        SELECT MAX(#incrementColumn#)
          INTO l_t_increment_bound
          FROM #histTableName# #partition#;
          
          p#frm#trac.log_sub_debug (l_vc_prc_name, ''INCR BOUND'', ''#tableName# #partition# : last #incrementColumn# = '' || l_t_increment_bound);
        
        ';
   -- Insert token of the staging procedure
   c_token_stage_insert           CLOB := '
        l_n_stat_id := p#frm#stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''STIN'');

        #computeIncrementBound#
                   
        #insertStatement#

		l_n_result := SQL%ROWCOUNT;

		p#frm#stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

        COMMIT;

        p#frm#trac.log_sub_debug (l_vc_prc_name, ''INSERT END'', ''#targetIdentifier# #partition# : '' || l_n_result || '' rows inserted'', NULL, l_n_result);
		';
   -- Check token of the historicizing procedure
   c_token_diff_check             CLOB := '
        l_b_ok := p#frm#dict.fct_check_pk (
			NULL, ''#stgOwner#'', ''#stageTableName#'', ''#stgOwner#'', ''#histTableName#''
		);
		IF l_b_ok THEN
			  p#frm#trac.log_sub_debug (l_vc_prc_name, ''CHECK NK'', ''#stageTableName# and #histTableName# have the same NK'');
		ELSE
			  p#frm#trac.log_sub_warn (l_vc_prc_name, ''CHECK NK'', ''#stageTableName# and #histTableName# have not the same NK'');		
		END IF;
        
        SELECT COUNT(*) INTO l_n_result FROM #stageTableName#;
        
        IF l_n_result = 0 THEN
            p#frm#trac.log_sub_error (l_vc_prc_name, ''CHECK'', ''Table #stageTableName# is empty'');
            raise_application_error (-20000, ''Stage table is empty.'');        
        END IF;
        
        EXECUTE IMMEDIATE ''ALTER SESSION ENABLE PARALLEL DML'';
		
		-- Truncate Diff table
		 p#frm#trac.log_sub_debug (l_vc_prc_name, ''DIFF TRUNCATE'', ''Truncate #diffIdentifier#'');		
		EXECUTE IMMEDIATE ''TRUNCATE TABLE #diffIdentifier# DROP STORAGE'';
		 p#frm#trac.log_sub_debug (l_vc_prc_name, ''DIFF TRUNCATE'', ''#diffIdentifier# truncated'');
		';
   -- Diff token of the historicizing procedure - with nk
   c_token_diff_insert            CLOB := '
		p#frm#trac.log_sub_debug (l_vc_prc_name, ''DIFF BEGIN'', ''Insert into #diffIdentifier#'');

		l_n_stat_id := p#frm#stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''DFIN'');
      
        #insertStatement#
        
		l_n_result := SQL%ROWCOUNT;

      COMMIT;

	  p#frm#stag_stat.prc_stat_end(l_n_stat_id, l_n_result);
		
      p#frm#trac.log_sub_debug (l_vc_prc_name, ''DIFF INSERTED'', ''#diffIdentifier# : '' || l_n_result || '' rows inserted'');
';
   -- Merge token of the historicizing procedure - 2 separate statement
   c_token_hist_reconcile         CLOB := '
        #enableParallelDML#
		
        -- Close old and deleted records in hist table
        
        p#frm#trac.log_sub_debug (l_vc_prc_name, ''HIST CLOSE'', ''Update #targetIdentifier#'');
        l_n_stat_id := p#frm#stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''HSCL'');

        #closeStatement#

        l_n_result := SQL%ROWCOUNT;

        p#frm#stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

        COMMIT;
        
        p#frm#trac.log_sub_debug (l_vc_prc_name, ''HIST CLOSED'', ''#targetIdentifier# : '' || l_n_result || '' rows updated'');
        
    	-- Update Hist table
		
		p#frm#trac.log_sub_debug (l_vc_prc_name, ''HIST UPDATE'', ''Update #targetIdentifier#'');
		l_n_stat_id := p#frm#stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''HSUP'');

        #updateStatement#

		l_n_result := SQL%ROWCOUNT;

		p#frm#stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

        COMMIT;
		
        p#frm#trac.log_sub_debug (l_vc_prc_name, ''HIST UPDATED'', ''#targetIdentifier# : '' || l_n_result || '' rows updated'');
		
		-- Insert into Hist table
		
        p#frm#trac.log_sub_debug (l_vc_prc_name, ''HIST INSERT'', ''#targetIdentifier# : Insert'');

	    l_n_stat_id := p#frm#stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''HSIN'');
        
        #insertStatement#

        l_n_result := SQL%ROWCOUNT;

        p#frm#stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

	    COMMIT;

        p#frm#trac.log_sub_debug (l_vc_prc_name, ''HIST END'', ''#targetIdentifier# : '' || l_n_result || '' rows inserted'');';
   -- Buffers
   l_buffer_pkg_head              CLOB;
   l_buffer_pkg_body              CLOB;
   l_vc_col_src                   t_string;
   l_vc_col_dupl                  t_string;
   l_vc_col_pk_notnull            t_string;
   -- Anonymization
   l_vc_def_anonymized            t_string;
   l_vc_col_anonymized            t_string;
   l_vc_set_anonymized            t_string;
   l_vc_ins_anonymized            t_string;
   l_vc_fct_anonymized            t_string;
   l_vc_ini_anonymized            t_string;
   l_vc_viw_anonymized            t_string;

   FUNCTION fct_get_partition_db (p_vc_db_identifier VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN    CHR (10)
             || ' PARTITION '
             || p#frm#stag_param.c_vc_prefix_partition
             || '_'
             || p_vc_db_identifier
             || ' VALUES ('''
             || p_vc_db_identifier
             || ''') NOLOGGING COMPRESS';
   END;

   FUNCTION fct_get_partition_expr
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN    ' CASE WHEN TRIM( TRANSLATE ('
             || g_vc_partition_expr
             || ',''0123456789'',''          '')) IS NULL THEN TO_NUMBER('
             || g_vc_partition_expr
             || ') ELSE 0 END';
   END;

   PROCEDURE prc_set_utl_columns (p_vc_code_string IN OUT CLOB)
   IS
      l_vc_prc_name   t_object_name := 'prc_set_utl_columns';
   BEGIN
      p#frm#ddls.prc_set_text_param (
         p_vc_code_string
       , 'validFromColumnName'
       , p#frm#stag_param.c_vc_column_valid_from
      );
      p#frm#ddls.prc_set_text_param (
         p_vc_code_string
       , 'validToColumnName'
       , p#frm#stag_param.c_vc_column_valid_to
      );
      p#frm#ddls.prc_set_text_param (
         p_vc_code_string
       , 'dmlOpColumnName'
       , p#frm#stag_param.c_vc_column_dml_op
      );
      p#frm#ddls.prc_set_text_param (
         p_vc_code_string
       , 'sourceDbColumnName'
       , p#frm#stag_param.c_vc_column_source_db
      );
      p#frm#ddls.prc_set_text_param (
         p_vc_code_string
       , 'partitionColumnName'
       , p#frm#stag_param.c_vc_column_partition
      );
   END prc_set_utl_columns;

   -- Procedure to set column definition list in order to add anonymized columns to the stage2 table
   /*PROCEDURE prc_set_anonymized_coldefs
   IS
   BEGIN
      FOR r_col IN (SELECT   table_name
                           , src_column_name
                           , trg_column_name
                           , stag_column_def
                           , data_type
                           , data_length
                           , ora_function_name
                        FROM all_tab_columns exi
                           , (SELECT col.stag_object_id
                                   , col.stag_object_name
                                   , col.stag_stg2_table_name
                                   , col.stag_column_pos
                                   , col.stag_column_def
                                   , msk.src_column_name
                                   , msk.trg_column_name
                                   , msk.ora_function_name
                                FROM (SELECT o.stag_object_id
                                           , o.stag_object_name
                                           , o.stag_stg2_table_name
                                           , c.stag_column_pos
                                           , c.stag_column_name
                                           , c.stag_column_def
                                        FROM stag_object_t o
                                           , stag_column_t c
                                       WHERE o.stag_object_id = c.stag_object_id) col
                                   , (SELECT atab.table_name
                                           , acol.src_column_name
                                           , acol.trg_column_name
                                           , meth.ora_function_name
                                        FROM dmaskadmin.da_schema_v asch
                                           , dmaskadmin.da_table_v atab
                                           , dmaskadmin.da_column_v acol
                                           , dmaskadmin.da_business_attribute_v attr
                                           , dmaskadmin.da_method_v meth
                                       WHERE asch.schema_id = atab.schema_id
                                         AND atab.table_id = acol.table_id
                                         AND acol.business_attribute_id = attr.attribute_id
                                         AND attr.anonym_method_id = meth.method_id) msk
                               WHERE col.stag_stg2_table_name = msk.table_name
                                 AND col.stag_column_name = msk.src_column_name) met
                       WHERE met.stag_stg2_table_name = exi.table_name(+)
                         AND met.trg_column_name = exi.column_name(+)
                         AND exi.owner(+) = g_vc_owner_stg
                         AND exi.owner IS NULL
                    ORDER BY stag_column_pos)
      LOOP
         l_vc_def_anonymized    := l_vc_def_anonymized || ',' || r_col.trg_column_name || ' ' || r_col.stag_column_def;
         l_vc_ini_anonymized    :=
               l_vc_ini_anonymized
            || ','
            || r_col.trg_column_name
            || ' = '
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || r_col.ora_function_name
            || '('
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || CHR (10);
      END LOOP;

      NULL;
   END;

   -- Procedure to set column lists for stage2 update and insert statements
   PROCEDURE prc_set_anonymized_columns
   IS
   BEGIN
      FOR r_col IN (SELECT   msk.table_name
                           , msk.src_column_name
                           , msk.trg_column_name
                           , col.stag_column_def
                           , data_type
                           , data_length
                           , msk.ora_function_name
                        FROM all_tab_columns exi
                           , (SELECT o.stag_object_id
                                   , o.stag_object_name
                                   , o.stag_stg2_table_name
                                   , c.stag_column_pos
                                   , c.stag_column_name
                                   , c.stag_column_def
                                FROM stag_object_t o
                                   , stag_column_t c
                               WHERE o.stag_object_id = c.stag_object_id) col
                           , (SELECT atab.table_name
                                   , acol.src_column_name
                                   , acol.trg_column_name
                                   , meth.ora_function_name
                                FROM dmaskadmin.da_schema_v asch
                                   , dmaskadmin.da_table_v atab
                                   , dmaskadmin.da_column_v acol
                                   , dmaskadmin.da_business_attribute_v attr
                                   , dmaskadmin.da_method_v meth
                               WHERE asch.schema_id = atab.schema_id
                                 AND atab.table_id = acol.table_id
                                 AND acol.business_attribute_id = attr.attribute_id
                                 AND attr.anonym_method_id = meth.method_id) msk
                       WHERE col.stag_stg2_table_name = exi.table_name
                         AND col.stag_column_name = exi.column_name
                         AND col.stag_stg2_table_name = msk.table_name
                         AND col.stag_column_name = msk.src_column_name
                         AND col.stag_object_id = g_n_object_id
                         AND exi.owner = g_vc_owner_stg
                    ORDER BY stag_column_pos)
      LOOP
         l_vc_col_anonymized    := l_vc_col_anonymized || ',' || r_col.trg_column_name || CHR (10);
         l_vc_set_anonymized    :=
               l_vc_set_anonymized
            || ',trg.'
            || r_col.trg_column_name
            || ' = CASE WHEN dmaskadmin.pkg_da_anonymization_lib.is_ano_required('''
            || g_vc_owner_stg
            || ''','''
            || r_col.table_name
            || ''','''
            || r_col.src_column_name
            || ''','
            || r_col.src_column_name
            || ') = ''Y'' THEN'
            || CHR (10)
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || 'dmaskadmin.'
            || r_col.ora_function_name
            || '(src.'
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || 'ELSE src.'
            || r_col.src_column_name
            || CHR (10)
            || 'END';
         l_vc_ins_anonymized    :=
               l_vc_ins_anonymized
            || ',CASE WHEN dmaskadmin.pkg_da_anonymization_lib.is_ano_required('''
            || g_vc_owner_stg
            || ''','''
            || r_col.table_name
            || ''','''
            || r_col.src_column_name
            || ''','
            || r_col.src_column_name
            || ') = ''Y'' THEN'
            || CHR (10)
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || 'dmaskadmin.'
            || r_col.ora_function_name
            || '(src.'
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || CHR (10)
            || 'ELSE src.'
            || r_col.src_column_name
            || CHR (10)
            || 'END';
         l_vc_fct_anonymized    :=
               l_vc_fct_anonymized
            || ',CASE WHEN dmaskadmin.pkg_da_anonymization_lib.is_ano_required('''
            || g_vc_owner_stg
            || ''','''
            || r_col.table_name
            || ''','''
            || r_col.src_column_name
            || ''','
            || r_col.src_column_name
            || ') = ''Y'' THEN'
            || CHR (10)
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || 'dmaskadmin.'
            || r_col.ora_function_name
            || '('
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || CHR (10)
            || 'ELSE '
            || r_col.src_column_name
            || CHR (10)
            || 'END';
      END LOOP;

      NULL;
   END;

   PROCEDURE prc_set_anonymized_viewcols
   IS
   BEGIN
      FOR r_col IN (SELECT   exi.table_name
                           , exi.column_name
                           , msk.trg_column_name
                        FROM all_tab_columns exi
                           , (SELECT atab.table_name
                                   , acol.src_column_name
                                   , acol.trg_column_name
                                   , meth.ora_function_name
                                FROM dmaskadmin.da_schema_v asch
                                   , dmaskadmin.da_table_v atab
                                   , dmaskadmin.da_column_v acol
                                   , dmaskadmin.da_business_attribute_v attr
                                   , dmaskadmin.da_method_v meth
                               WHERE asch.schema_id = atab.schema_id
                                 AND atab.table_id = acol.table_id
                                 AND acol.business_attribute_id = attr.attribute_id
                                 AND attr.anonym_method_id = meth.method_id) msk
                       WHERE exi.table_name = msk.table_name(+)
                         AND exi.column_name = msk.src_column_name(+)
                         AND exi.table_name = UPPER (g_vc_table_name_hist)
                         AND exi.owner = g_vc_owner_stg
                    ORDER BY exi.column_id)
      LOOP
         l_vc_viw_anonymized    :=
               l_vc_viw_anonymized
            || ','
            || CASE
                  WHEN pkg_param.c_vc_db_name_actual IN (pkg_param.c_vc_db_name_dev, pkg_param.c_vc_db_name_tst)
                  AND r_col.trg_column_name IS NOT NULL
                     THEN r_col.trg_column_name || ' AS ' || r_col.column_name
                  ELSE r_col.column_name
               END
            || CHR (10);
      END LOOP;
   END;*/
   PROCEDURE prc_store_ddl (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_object_ddl     CLOB
   )
   IS
      l_vc_prc_name   t_object_name := 'prc_store_ddl';
   BEGIN
      MERGE INTO p#frm#stag_ddl_t trg
           USING (SELECT UPPER (p_vc_object_type) AS object_type
                       , UPPER (p_vc_object_name) AS object_name
                       , p_vc_object_ddl AS object_ddl
                    FROM DUAL) src
              ON (UPPER (trg.stag_ddl_type) = UPPER (src.object_type)
              AND UPPER (trg.stag_ddl_name) = UPPER (src.object_name))
      WHEN MATCHED THEN
         UPDATE SET trg.stag_ddl_code = src.object_ddl
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_ddl_type
                     , trg.stag_ddl_name
                     , trg.stag_ddl_code
                    )
             VALUES (
                       src.object_type
                     , src.object_name
                     , src.object_ddl
                    );

      COMMIT;
   END prc_store_ddl;

   PROCEDURE prc_create_stage_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name    t_object_name := 'prc_create_stage_table';
      l_vc_message     t_string
                          :=    'Stage Table '
                             || g_vc_table_name_stage;
      l_sql_create     CLOB;
      l_list_utl_col   t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_coldef_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_coldef_partition
               || ','
         END;
      -- Build create table statement
      l_sql_create := p#frm#ddls.c_template_create_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_stage
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       , g_vc_col_def
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING COMPRESS '
         || CASE
               WHEN g_vc_tablespace_stage_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_data
            END
      );

      -- Partitions
      IF g_l_distr_code.COUNT > 1 THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ' PARTITION BY LIST (#sourceDbColumnName#) (';

         FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
            IF i > 1 THEN
               l_sql_create :=
                     l_sql_create
                  || ',';
            END IF;

            l_sql_create :=
                  l_sql_create
               || fct_get_partition_db (g_l_distr_code (i));
         END LOOP;

         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ')';
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || c_token_partition;
      END IF;

      prc_set_utl_columns (l_sql_create);
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_stage
       , l_sql_create
      );

      BEGIN
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Creating table'
         );
         p#frm#ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_stage
          , l_sql_create
          , p_b_drop_flag
          , TRUE
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Table created'
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Error creating'
            );
            RAISE;
      END;

      BEGIN
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Setting compression option...'
         );

         EXECUTE IMMEDIATE
               'ALTER TABLE '
            || g_vc_table_name_stage
            || ' COMPRESS FOR QUERY LOW';

         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Compression option set'
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'FOR QUERY LOW option not available'
            );
      END;

      -- Build constraint statement
      /*l_sql_create          := c_token_create_pk;
      p#frm#ddls.prc_set_text_param (l_sql_create
                                    , 'tableName'
                                    , g_vc_table_name_stage
                                     );
      p#frm#ddls.prc_set_text_param (l_sql_create
                                    , 'pkName'
                                    , g_vc_nk_name_stage
                                     );
      p#frm#ddls.prc_set_text_param (l_sql_create
                                    , 'listColPk'
                                    , g_vc_col_pk
                                     );
      p#frm#ddls.prc_set_text_param (l_sql_create
                                    , 'storageClause'
                                    , 'NOLOGGING ' || CASE
                                         WHEN g_l_distr_code.COUNT > 1
                                            THEN 'LOCAL'
                                      END || CASE
                                         WHEN g_vc_tablespace_stage_indx IS NOT NULL
                                            THEN ' TABLESPACE ' || g_vc_tablespace_stage_indx
                                      END
                                     );
      prc_set_utl_columns (l_sql_create);
      prc_store_ddl ('CONSTRAINT'
                   , g_vc_nk_name_stage
                   , l_sql_create
                    );

      BEGIN
           p#frm#trac.log_sub_debug (l_vc_message, 'Creating NK...');
         p#frm#ddls.prc_create_object ('CONSTRAINT'
                                      , g_vc_nk_name_stage
                                      , l_sql_create
                                      , p_b_drop_flag
                                      , TRUE
                                       );
           p#frm#trac.log_sub_debug (l_vc_message, 'NK created');
      EXCEPTION
         WHEN OTHERS
         THEN
              p#frm#trac.log_sub_debug (SQLERRM
                           , 'NK not created'
                           , param.gc_log_warn
                            );
            RAISE;
      END;*/
      IF g_n_parallel_degree > 1 THEN
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Setting parallel option...'
         );

         EXECUTE IMMEDIATE
               'ALTER TABLE '
            || g_vc_table_name_stage
            || ' PARALLEL '
            || g_n_parallel_degree;

         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Parallel option set...'
         );
      END IF;

      -- Comments from source system
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Setting comments...'
      );

      EXECUTE IMMEDIATE
            'COMMENT ON TABLE '
         || g_vc_table_name_stage
         || ' IS '''
         || g_vc_table_comment
         || '''';

      FOR r_comm IN (SELECT c.stag_column_name
                          , c.stag_column_comment
                       FROM p#frm#stag_object_t o
                          , p#frm#stag_column_t c
                      WHERE o.stag_object_id = c.stag_object_id
                        AND o.stag_object_id = g_n_object_id) LOOP
         EXECUTE IMMEDIATE
               'COMMENT ON COLUMN '
            || g_vc_table_name_stage
            || '.'
            || r_comm.stag_column_name
            || ' IS '''
            || r_comm.stag_column_comment
            || '''';
      END LOOP;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Comments set...'
      );
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_error (
            l_vc_prc_name
          , l_vc_message
          , 'Stage Table: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_stage_table;

   PROCEDURE prc_create_duplicate_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name    t_object_name := 'prc_create_duplicate_table';
      l_vc_message     t_string
                          :=    'Table duplicates '
                             || g_vc_table_name_dupl;
      l_sql_create     CLOB;
      l_list_utl_col   t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_coldef_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_coldef_partition
               || ','
         END;
      -- Build create table statement
      l_sql_create := p#frm#ddls.c_template_create_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_dupl
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       , g_vc_col_def
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING'
         || CASE
               WHEN g_vc_tablespace_stage_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_data
            END
      );

      -- Stage1 partitions
      IF g_l_distr_code.COUNT > 1 THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ' PARTITION BY LIST (#sourceDbColumnName#) (';

         FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
            IF i > 1 THEN
               l_sql_create :=
                     l_sql_create
                  || ',';
            END IF;

            l_sql_create :=
                  l_sql_create
               || fct_get_partition_db (g_l_distr_code (i));
         END LOOP;

         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ')';
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || c_token_partition;
      END IF;

      prc_set_utl_columns (l_sql_create);
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_dupl
       , l_sql_create
      );

      BEGIN
         p#frm#ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_dupl
          , l_sql_create
          , p_b_drop_flag
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Duplicates Table: Warning'
            );
            RAISE;
      END;

      IF g_n_parallel_degree > 1 THEN
         l_sql_create :=
               'ALTER TABLE '
            || g_vc_table_name_dupl
            || ' PARALLEL '
            || g_n_parallel_degree;
         p#frm#ddls.prc_execute (l_sql_create);
      END IF;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Duplicates Table: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_error (
            l_vc_prc_name
          , l_vc_message
          , 'Stage Table: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_duplicate_table;

   PROCEDURE prc_create_diff_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name            t_object_name := 'prc_create_diff_table';
      l_vc_message             t_string
                                  :=    'Table difference '
                                     || g_vc_table_name_diff;
      l_sql_create             CLOB;
      l_sql_subpart_template   t_string;
      l_list_utl_col           t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Difference table: Begin'
      );
      l_list_utl_col :=
            c_token_utl_coldef_hist
         || ','
         || CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     c_token_utl_coldef_source_db
                  || ','
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     c_token_utl_coldef_partition
                  || ','
            END;
      l_sql_create := p#frm#ddls.c_template_create_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       , g_vc_col_def
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING '
         || CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_diff_subpartition
               ELSE
                  c_token_diff_partition
            END
         || CASE
               WHEN g_vc_tablespace_stage_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_data
            END
      );
      prc_set_utl_columns (l_sql_create);
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_diff
       , l_sql_create
      );

      BEGIN
         p#frm#ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_diff
          , l_sql_create
          , p_b_drop_flag
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Difference Table: Error'
            );
            RAISE;
      END;

      l_sql_create := p#frm#ddls.c_template_create_pk;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'pkName'
       , g_vc_nk_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColPk'
       , g_vc_col_pk
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING'
         || CASE
               WHEN g_vc_tablespace_stage_indx IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_indx
            END
      );
      prc_store_ddl (
         'CONSTRAINT'
       , g_vc_nk_name_diff
       , l_sql_create
      );

      BEGIN
         p#frm#ddls.prc_create_object (
            'CONSTRAINT'
          , g_vc_table_name_diff
          , l_sql_create
          , p_b_drop_flag
          , p_b_raise_flag
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Difference table: Warning'
            );
            RAISE;
      END;

      IF g_n_parallel_degree > 1 THEN
         l_sql_create :=
               'ALTER TABLE '
            || g_vc_table_name_diff
            || ' PARALLEL '
            || g_n_parallel_degree;
         p#frm#ddls.prc_execute (l_sql_create);
      END IF;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Difference table: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_error (
            l_vc_prc_name
          , l_vc_message
          , 'Difference table: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_diff_table;

   PROCEDURE prc_create_hist_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name     t_object_name := 'prc_create_hist_table';
      l_vc_message      t_string
                           :=    'History Table '
                              || g_vc_table_name_hist;
      l_sql_create      t_string;
      l_list_utl_col    t_string;
      l_l_utl_columns   DBMS_SQL.varchar2s;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Diff Table: Begin'
      );
      -- Set anonymizad column lists
      l_vc_def_anonymized := '';
      l_vc_ini_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_coldefs;
      -- Generate table ddl
      l_list_utl_col :=
            c_token_utl_coldef_hist
         || ','
         || CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     c_token_utl_coldef_source_db
                  || ','
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     c_token_utl_coldef_partition
                  || ','
            END;
      l_sql_create := p#frm#ddls.c_template_create_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_hist
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       ,    g_vc_col_def
         || l_vc_def_anonymized
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING COMPRESS '
         || CASE
               WHEN g_vc_tablespace_hist_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_hist_data
            END
      );

      IF g_vc_partition_expr IS NOT NULL THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || c_token_partition;
      END IF;

      prc_set_utl_columns (l_sql_create);
      -- Execute table ddl
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_hist
       , l_sql_create
      );

      BEGIN
         -- Try to create table
         p#frm#ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_hist
          , l_sql_create
          , FALSE
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'History Table Create: Warning'
            );

            IF l_vc_def_anonymized IS NOT NULL THEN
               BEGIN
                  p#frm#trac.log_sub_debug (
                     'Add new anonymized columns'
                   , 'History Table Add Anonymized'
                  );

                  -- Try to add newly anonymized columns
                  EXECUTE IMMEDIATE
                        'ALTER TABLE '
                     || g_vc_table_name_hist
                     || ' ADD ('
                     || LTRIM (
                           l_vc_def_anonymized
                         , ','
                        )
                     || ')';
               EXCEPTION
                  WHEN OTHERS THEN
                     p#frm#trac.log_sub_warn (
                        l_vc_prc_name
                      , l_vc_message
                      , 'History Table Add Anonymized: Warning'
                     );

                     IF p_b_raise_flag THEN
                        RAISE;
                     END IF;
               END;
            END IF;

            IF l_vc_ini_anonymized IS NOT NULL THEN
               BEGIN
                  p#frm#trac.log_sub_debug (
                     l_vc_prc_name
                   , l_vc_message
                   , 'Fill new anonymized columns - History Table Upd Anonymized'
                  );

                  -- Try to fill newly added anonymized columns
                  EXECUTE IMMEDIATE
                        'UPDATE '
                     || g_vc_table_name_hist
                     || ' SET '
                     || LTRIM (
                           l_vc_ini_anonymized
                         , ','
                        );

                  COMMIT;
               EXCEPTION
                  WHEN OTHERS THEN
                     p#frm#trac.log_sub_warn (
                        l_vc_prc_name
                      , l_vc_message
                      , 'History Table Upd Anonymized: Warning'
                     );

                     IF p_b_raise_flag THEN
                        RAISE;
                     END IF;
               END;
            END IF;

            IF p_b_raise_flag THEN
               RAISE;
            END IF;
      END;

      IF g_n_parallel_degree > 1 THEN
         l_sql_create :=
               'ALTER TABLE '
            || g_vc_table_name_hist
            || ' PARALLEL '
            || g_n_parallel_degree;
         p#frm#ddls.prc_execute (l_sql_create);
      END IF;

      IF g_vc_fb_archive IS NOT NULL
     AND g_n_fbda_flag = 1 THEN
         BEGIN
            EXECUTE IMMEDIATE
                  'ALTER TABLE '
               || g_vc_table_name_hist
               || ' FLASHBACK ARCHIVE '
               || g_vc_fb_archive;
         EXCEPTION
            WHEN OTHERS THEN
               p#frm#trac.log_sub_debug (
                  l_vc_prc_name
                , l_vc_message
                , 'History Table: FLASHBACK'
               );
         END;
      END IF;

      BEGIN
         EXECUTE IMMEDIATE
               'ALTER TABLE '
            || g_vc_table_name_hist
            || ' COMPRESS FOR QUERY LOW';
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_warn (
               l_vc_prc_name
             , l_vc_message
             , 'FOR QUERY LOW option not available'
            );
      END;

      -- Generate NK ddl
      l_sql_create := p#frm#ddls.c_template_create_pk;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_hist
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'pkName'
       , g_vc_nk_name_hist
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'listColPk'
       ,    p#frm#stag_param.c_vc_column_valid_to
         || ','
         || g_vc_col_pk
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING '
         || CASE
               WHEN g_l_distr_code.COUNT > 1
                AND p#frm#dict.fct_check_part (
                       NULL
                     , g_vc_owner_stg
                     , g_vc_table_name_hist
                    ) THEN
                  'LOCAL'
            END
         || CASE
               WHEN g_vc_tablespace_hist_indx IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_hist_indx
            END
      );
      -- Execute NK ddl
      prc_store_ddl (
         'CONSTRAINT'
       , g_vc_nk_name_hist
       , l_sql_create
      );

      BEGIN
         p#frm#ddls.prc_create_object (
            'CONSTRAINT'
          , g_vc_nk_name_hist
          , l_sql_create
          , FALSE
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            p#frm#trac.log_sub_warn (
               l_vc_prc_name
             , l_vc_message
             , 'Hist table Natural Key: Warning'
            );

            IF p_b_raise_flag THEN
               RAISE;
            END IF;
      END;

      -- Create not null constraints
      l_l_utl_columns :=
         p#frm#type.fct_string_to_list (
            c_token_utl_column_hist
          , ','
         );

      FOR i IN l_l_utl_columns.FIRST .. l_l_utl_columns.LAST LOOP
         l_sql_create := p#frm#ddls.c_template_create_notnull;
         p#frm#ddls.prc_set_text_param (
            l_sql_create
          , 'tableName'
          , g_vc_table_name_hist
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_create
          , 'columnName'
          , l_l_utl_columns (i)
         );
         -- Execute Check ddl
         prc_set_utl_columns (l_sql_create);
         prc_store_ddl (
            'CONSTRAINT'
          ,    SUBSTR (
                  g_vc_nk_name_hist
                , 1
                , 25
               )
            || '_NN'
            || TO_CHAR (
                  i
                , '00'
               )
          , l_sql_create
         );

         BEGIN
            p#frm#ddls.prc_create_object (
               'CONSTRAINT'
             ,    SUBSTR (
                     g_vc_nk_name_hist
                   , 1
                   , 25
                  )
               || '_NN'
               || TO_CHAR (
                     i
                   , '00'
                  )
             , l_sql_create
             , FALSE
             , TRUE
            );
         EXCEPTION
            WHEN OTHERS THEN
               p#frm#trac.log_warn (
                  SQLERRM
                , 'Hist Natural Key: Warning'
               );

               IF p_b_raise_flag THEN
                  RAISE;
               END IF;
         END;
      END LOOP;

      /*EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_table_name_hist
         || ' TO '
         || p#frm#stag_param.c_vc_list_grantee;*/
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'History Table: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_warn (
            l_vc_prc_name
          , l_vc_message
          , 'History Table: Warning'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_hist_table;

   PROCEDURE prc_create_hist_view (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_create_hist_view';
      l_vc_message    t_string
                         :=    'View Hist '
                            || g_vc_view_name_hist;
      l_sql_create    t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: Begin'
      );
      l_vc_viw_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_viewcols;
      --
      l_sql_create :=
            'CREATE OR REPLACE FORCE VIEW '
         || g_vc_view_name_hist
         || ' AS SELECT '
         || NVL (
               LTRIM (
                  l_vc_viw_anonymized
                , ','
               )
             , '*'
            )
         || ' FROM '
         || g_vc_table_name_hist;
      prc_store_ddl (
         'VIEW'
       , g_vc_view_name_hist
       , l_sql_create
      );

      EXECUTE IMMEDIATE l_sql_create;

      EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_view_name_hist
         || ' TO '
         || p#frm#stag_param.c_vc_list_grantee;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Hist View: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         ELSE
            NULL;
         END IF;
   END;

   PROCEDURE prc_create_hist_synonym (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_create_hist_synonym';
      l_vc_message    t_string
                         :=    'Synonym Hist '
                            || g_vc_view_name_hist;
      l_sql_create    t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist Synonym: Begin'
      );
      l_vc_viw_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_viewcols;
      --
      l_sql_create :=
            'CREATE OR REPLACE SYNONYM '
         || g_vc_view_name_hist
         || ' FOR '
         || g_vc_table_name_hist;
      prc_store_ddl (
         'SYNONYM'
       , g_vc_view_name_hist
       , l_sql_create
      );

      EXECUTE IMMEDIATE l_sql_create;

      EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_view_name_hist
         || ' TO '
         || p#frm#stag_param.c_vc_list_grantee;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist Synonym: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_warn (
            l_vc_prc_name
          , l_vc_message
          , 'Hist Synonym: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         ELSE
            NULL;
         END IF;
   END;

   PROCEDURE prc_create_fbda_view (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_create_fbda_view';
      l_vc_message    t_string
                         :=    'View Hist '
                            || g_vc_view_name_hist;
      l_sql_create    t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: Begin'
      );
      l_vc_viw_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_viewcols;
      --
      l_sql_create :=
            'CREATE OR REPLACE FORCE VIEW '
         || g_vc_view_name_fbda
         || ' AS SELECT versions_starttime
     , versions_startscn
     , versions_endtime
     , versions_endscn
     , versions_xid
     , versions_operation
     '
         || l_vc_viw_anonymized
         || ' FROM '
         || g_vc_table_name_hist
         || ' VERSIONS BETWEEN TIMESTAMP MINVALUE AND MAXVALUE';
      prc_store_ddl (
         'VIEW'
       , g_vc_view_name_fbda
       , l_sql_create
      );

      EXECUTE IMMEDIATE l_sql_create;

      EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_view_name_fbda
         || ' TO '
         || p#frm#stag_param.c_vc_list_grantee;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         p#frm#trac.log_sub_warn (
            l_vc_prc_name
          , l_vc_message
          , 'Hist View: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         ELSE
            NULL;
         END IF;
   END;

   PROCEDURE prc_create_prc_trunc_stage (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_trunc_stage';
      l_vc_message       t_string
                            :=    'Procedure trunc stage '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- HEAD
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_trunc_stage
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      l_sql_prc_token := p#frm#stmt.c_token_truncate_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_stage
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         l_sql_prc_token := p#frm#stmt.c_token_truncate_table;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_trunc_stage
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_trunc_stage;

   PROCEDURE prc_create_prc_trunc_diff (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_trunc_diff';
      l_vc_message       t_string
                            :=    'Procedure trunc diff '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- HEAD
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_trunc_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      l_sql_prc_buffer := p#frm#stmt.c_token_truncate_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'tableName'
       , g_vc_table_name_diff
      );
      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_trunc_diff
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_trunc_diff;

   PROCEDURE prc_create_prc_init (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name         t_object_name := 'prc_create_prc_init';
      l_vc_message          t_string
                               :=    'Procedure load init '
                                  || g_vc_package_main;
      l_sql_prc             CLOB;
      l_sql_prc_token       CLOB;
      l_sql_prc_buffer      CLOB;
      -- List of columns
      l_vc_col_all          t_string;
      l_list_utl_col        t_string;
      l_list_utl_val        t_string;
      l_list_utl_col_dupl   t_string;
      l_list_utl_val_dupl   t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_vc_col_anonymized := '';
      l_vc_fct_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_columns;
      --
      -- Set utl columns strings
      l_list_utl_col_dupl :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_column_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_column_partition
               || ','
         END;
      prc_set_utl_columns (l_list_utl_col_dupl);
      l_list_utl_col :=
            c_token_utl_column_hist
         || ','
         || l_list_utl_col_dupl;
      prc_set_utl_columns (l_list_utl_col);
      --
      -- Get lists of columns
      l_vc_col_all :=
         p#frm#dict.fct_get_column_subset (
            g_vc_dblink
          , g_vc_owner_src
          , g_vc_table_name_source
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
          , p_vc_exclude_list   => l_list_utl_col
         );
      --
      -- HEAD
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_init
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Add token to check if hist table is empty
      l_sql_prc_token :=
            p#frm#stmt.c_token_enable_parallel_dml
         || CHR (10)
         || c_token_check_table_isempty;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_hist
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Truncate duplicates table
         l_sql_prc_token := p#frm#stmt.c_token_truncate_table;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Fill stage hist for each source db
      FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
         l_sql_prc_token := c_token_stage_insert;
         --
         -- Values for the utility columns
         l_list_utl_val_dupl :=
            CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     ''''
                  || g_l_distr_code (i)
                  || ''', '
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     fct_get_partition_expr
                  || ','
            END;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NOT NULL THEN
            l_vc_col_pk_notnull :=
               p#frm#stag_meta.fct_get_column_list (
                  g_n_object_id
                , 'PK'
                , 'AND_NOTNULL'
               );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_dedupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'duplIdentifier'
             , g_vc_table_name_dupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'pkColumnList'
             , g_vc_col_pk_src
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'deduplRankClause'
             , g_vc_dedupl_rank_clause
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlColumnListForDupl'
             , l_list_utl_col_dupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlValueListForDupl'
             , l_list_utl_val_dupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'notNullClause'
             , l_vc_col_pk_notnull
            );
         ELSE
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_copy
            );
         END IF;

         l_list_utl_val :=
               c_token_utl_colval_hist
            || ','
            || l_list_utl_val_dupl;
         -- There is no optional incremental retrieval (this is an init procedure)
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'computeIncrementBound'
          , NULL
         );
         --
         --
         p#frm#stmt.prc_set_text_param (
            l_sql_prc_token
          , 'targetIdentifier'
          , g_vc_table_name_hist
         );
         p#frm#stmt.prc_set_text_param (
            l_sql_prc_token
          , 'sourceIdentifier'
          , g_vc_source_identifier
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourceColumnList'
          , l_vc_col_all
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetColumnList'
          , l_vc_col_all
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlColumnList'
          , l_list_utl_col
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlValueList'
          , l_list_utl_val
         );
         --
         --
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'filterClause'
          , CASE
               WHEN g_vc_filter_clause IS NOT NULL THEN
                     ' WHERE '
                  || g_vc_filter_clause
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , NULL
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      l_sql_prc_token := c_token_analyze;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'HSAN'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_hist
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'partition'
       , NULL
      );
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Truncate duplicates table
         l_sql_prc_token := c_token_analyze;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'statisticsType'
          , 'DUAN'
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'stgOwner'
          , g_vc_owner_stg
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , NULL
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceCode'
       , g_vc_source_code
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'objectName'
       , g_vc_object_name
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceTable'
       , g_vc_table_name_source
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_init
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_init;

   PROCEDURE prc_create_prc_load_stage (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_load_stage';
      l_vc_message       t_string
                            :=    'Procedure load stage '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
      l_list_utl_col     t_string;
      l_list_utl_val     t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- Set utl columns strings
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_column_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_column_partition
               || ','
         END;
      prc_set_utl_columns (l_list_utl_col);
      --
      -- HEAD
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_stage
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Truncate stage table
      l_sql_prc_token :=
            p#frm#stmt.c_token_enable_parallel_dml
         || CHR (10)
         || p#frm#stmt.c_token_truncate_table;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_stage
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Truncate duplicates table
         l_sql_prc_token := p#frm#stmt.c_token_truncate_table;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Fill stage table for each source db
      -- Fill stage for each source db
      FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
         l_sql_prc_token := c_token_stage_insert;
         --
         -- Values for the utility columns
         l_list_utl_val :=
            CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     ''''
                  || g_l_distr_code (i)
                  || ''', '
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     fct_get_partition_expr
                  || ', '
            END;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NOT NULL THEN
            l_vc_col_pk_notnull :=
               p#frm#stag_meta.fct_get_column_list (
                  g_n_object_id
                , 'PK'
                , 'AND_NOTNULL'
               );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_dedupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'duplIdentifier'
             , g_vc_table_name_dupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'pkColumnList'
             , g_vc_col_pk_src
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'deduplRankClause'
             , g_vc_dedupl_rank_clause
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlColumnListForDupl'
             , l_list_utl_col
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlValueListForDupl'
             , l_list_utl_val
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'notNullClause'
             , l_vc_col_pk_notnull
            );
         ELSE
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_copy
            );
         END IF;

         -- Add optional increment retrieval statement
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'computeIncrementBound'
          , CASE
               WHEN g_vc_increment_column IS NOT NULL THEN
                  c_token_stage_get_incr_bound
            END
         );
         --
         --
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'insertStatement'
          , p#frm#stmt.c_sql_insert_copy
         );
         p#frm#stmt.prc_set_text_param (
            l_sql_prc_token
          , 'targetIdentifier'
          , g_vc_table_name_stage
         );
         p#frm#stmt.prc_set_text_param (
            l_sql_prc_token
          , 'sourceIdentifier'
          , g_vc_source_identifier
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourceColumnList'
          , g_vc_col_all
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetColumnList'
          , g_vc_col_all
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlColumnList'
          , l_list_utl_col
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlValueList'
          , l_list_utl_val
         );
         --
         --
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'incrementColumn'
          , g_vc_increment_column
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'histTableName'
          , g_vc_table_name_hist
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'filterClause'
          ,    CASE
                  WHEN g_vc_filter_clause IS NOT NULL THEN
                        'WHERE '
                     || g_vc_filter_clause
               END
            || CASE
                  WHEN g_vc_increment_column IS NOT NULL THEN
                        CASE
                           WHEN g_vc_filter_clause IS NULL THEN
                              ' WHERE '
                           ELSE
                              ' AND '
                        END
                     || g_vc_increment_column
                     || ' > l_t_increment_bound - '
                     || NVL (g_n_increment_buffer, 0)
               END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || '_'
                  || g_l_distr_code (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , CASE
            WHEN g_vc_increment_column IS NOT NULL THEN
                  'l_t_increment_bound '
               || g_vc_increment_coldef
               || ';'
         END
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceCode'
       , g_vc_source_code
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'objectName'
       , g_vc_object_name
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceTable'
       , g_vc_table_name_source
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_stage
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_stage;

   PROCEDURE prc_create_prc_load_stage_p (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_load_stage_p';
      l_vc_message       t_string
                            :=    'Procedure load stage partition '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
      l_n_iter_begin     NUMBER;
      l_n_iter_end       NUMBER;
      l_list_utl_col     t_string;
      l_list_utl_val     t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- Set utl columns strings
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_column_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_column_partition
               || ','
         END;
      prc_set_utl_columns (l_list_utl_col);

      --
      -- HEAD
      --
      IF g_l_distr_code.COUNT > 1 THEN
         FOR i IN g_l_dblink.FIRST .. g_l_dblink.LAST LOOP
            -- Stage1 procedure head
            l_sql_prc := p#frm#ddls.c_template_prc_head;
            p#frm#ddls.prc_set_text_param (
               l_sql_prc
             , 'prcName'
             ,    p#frm#stag_param.c_vc_procedure_load_stage_p
               || '_'
               || g_l_distr_code (i)
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc
             , 'prcParameters'
             , c_token_prc_param
            );
            l_buffer_pkg_head :=
                  l_buffer_pkg_head
               || CHR (10)
               || l_sql_prc;
         END LOOP;
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         FOR i IN 0 .. 9 LOOP
            -- Stage1 procedure head
            l_sql_prc := p#frm#ddls.c_template_prc_head;
            p#frm#ddls.prc_set_text_param (
               l_sql_prc
             , 'prcName'
             ,    p#frm#stag_param.c_vc_procedure_load_stage_p
               || '_p'
               || i
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc
             , 'prcParameters'
             , c_token_prc_param
            );
            l_buffer_pkg_head :=
                  l_buffer_pkg_head
               || CHR (10)
               || l_sql_prc;
         END LOOP;
      END IF;

      --
      -- BODY
      --
      IF g_l_distr_code.COUNT > 1 THEN
         l_n_iter_begin := g_l_dblink.FIRST;
         l_n_iter_end := g_l_dblink.LAST;
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         l_n_iter_begin := 0;
         l_n_iter_end := 9;
      END IF;

      FOR i IN l_n_iter_begin .. l_n_iter_end LOOP
         l_sql_prc_token := p#frm#stmt.c_token_truncate_partition;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_stage
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || '_'
                  || g_l_distr_code (i)
                  || ')'
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         -- Fill stage table for each source db
         l_sql_prc_token :=
               l_sql_prc_token
            || CHR (10)
            || c_token_stage_insert;
         --
         -- Values for the utility columns
         l_list_utl_val :=
            CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     ''''
                  || g_l_distr_code (i)
                  || ''', '
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     fct_get_partition_expr
                  || ', '
            END;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NOT NULL THEN
            l_vc_col_pk_notnull :=
               p#frm#stag_meta.fct_get_column_list (
                  g_n_object_id
                , 'PK'
                , 'AND_NOTNULL'
               );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_dedupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'duplIdentifier'
             , g_vc_table_name_dupl
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'pkColumnList'
             , g_vc_col_pk_src
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'deduplRankClause'
             , g_vc_dedupl_rank_clause
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlColumnListForDupl'
             , l_list_utl_col
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlValueListForDupl'
             , l_list_utl_val
            );
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'notNullClause'
             , l_vc_col_pk_notnull
            );
         ELSE
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_copy
            );
         END IF;

         -- Add optional increment retrieval statement
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'computeIncrementBound'
          , CASE
               WHEN g_vc_increment_column IS NOT NULL THEN
                  c_token_stage_get_incr_bound
            END
         );
         --
         --
         g_vc_source_identifier :=
            CASE
               WHEN g_l_dblink.COUNT = 1 THEN
                  CASE
                     WHEN g_l_dblink (1) IS NULL
                      AND g_l_owner_src (1) = g_vc_owner_stg THEN
                        g_vc_table_name_source
                     ELSE
                           CASE
                              WHEN g_l_owner_src (1) IS NOT NULL THEN
                                    g_l_owner_src (1)
                                 || '.'
                           END
                        || g_vc_table_name_source
                        || CASE
                              WHEN g_l_dblink (1) IS NOT NULL THEN
                                    '@'
                                 || g_l_dblink (1)
                           END
                  END
               ELSE
                  CASE
                     WHEN g_l_dblink (i) IS NULL
                      AND g_l_owner_src (i) = g_vc_owner_stg THEN
                        g_vc_table_name_source
                     ELSE
                        CASE
                           WHEN g_l_owner_src (i) IS NOT NULL THEN
                                 g_l_owner_src (i)
                              || '.'
                              || g_vc_table_name_source
                              || CASE
                                    WHEN g_l_dblink (i) IS NOT NULL THEN
                                          '@'
                                       || g_l_dblink (i)
                                 END
                        END
                  END
            END;
         --
         --
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'insertStatement'
          , p#frm#stmt.c_sql_insert_copy
         );
         p#frm#stmt.prc_set_text_param (
            l_sql_prc_token
          , 'targetIdentifier'
          , g_vc_table_name_stage
         );
         p#frm#stmt.prc_set_text_param (
            l_sql_prc_token
          , 'sourceIdentifier'
          , g_vc_source_identifier
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourceColumnList'
          , g_vc_col_all
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetColumnList'
          , g_vc_col_all
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlColumnList'
          , l_list_utl_col
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlValueList'
          , l_list_utl_val
         );
         --
         --
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'incrementColumn'
          , g_vc_increment_column
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'filterClause'
          ,    CASE
                  WHEN g_vc_partition_expr IS NOT NULL THEN
                        ' WHERE '
                     || fct_get_partition_expr
                     || ' = '
                     || i
               END
            || CASE
                  WHEN g_vc_filter_clause IS NOT NULL THEN
                        CASE
                           WHEN g_vc_partition_expr IS NULL THEN
                              ' WHERE '
                           ELSE
                              ' AND '
                        END
                     || g_vc_filter_clause
               END
            || CASE
                  WHEN g_vc_increment_column IS NOT NULL THEN
                        CASE
                           WHEN g_vc_partition_expr IS NULL
                            AND g_vc_filter_clause IS NULL THEN
                              ' WHERE '
                           ELSE
                              ' AND '
                        END
                     || g_vc_increment_column
                     || ' > l_t_increment_bound'
               END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || '_'
                  || g_l_distr_code (i)
                  || ')'
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_l_distr_code.COUNT > 1
                 OR g_vc_partition_expr IS NOT NULL THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         -- Put body in the generic prc template
         l_sql_prc := p#frm#ddls.c_template_prc_body;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'prcParameters'
          , c_token_prc_param
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'varList'
          , CASE
               WHEN g_vc_increment_column IS NOT NULL THEN
                     'l_t_increment_bound '
                  || g_vc_increment_coldef
                  || ';'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'prcInitialize'
          , c_token_prc_initialize
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'prcFinalize'
          , c_token_prc_finalize
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'exceptionHandling'
          , c_token_prc_exception
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'prcBody'
          , l_sql_prc_token
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'sourceCode'
          , g_vc_source_code
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'objectName'
          , g_vc_object_name
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'sourceTable'
          , g_vc_table_name_source
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc
          , 'prcName'
          ,    p#frm#stag_param.c_vc_procedure_load_stage_p
            || '_'
            || CASE
                  WHEN g_l_distr_code.COUNT > 1 THEN
                     g_l_distr_code (i)
                  ELSE
                        'p'
                     || i
               END
         );
         l_buffer_pkg_body :=
               l_buffer_pkg_body
            || CHR (10)
            || l_sql_prc;
      END LOOP;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_stage_p;

   PROCEDURE prc_create_prc_load_diff (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name         t_object_name := 'prc_create_prc_load_diff';
      l_vc_message          t_string
                               :=    'Procedure load diff '
                                  || g_vc_package_main;
      l_sql_prc             CLOB;
      l_sql_prc_token       CLOB;
      l_sql_prc_buffer      CLOB;
      --
      l_n_iter_begin        NUMBER;
      l_n_iter_end          NUMBER;
      -- List of columns
      l_vc_col_list         t_string;
      l_vc_col_pk_hist      t_string;
      l_vc_clause_on        t_string;
      l_vc_upd_clause_set   t_string;
      l_vc_clause_history   t_string;
      l_vc_clause_update    t_string;
      l_vc_col_nvl2         t_string;
      -- Utl columns
      l_list_utl_col        t_string;
      l_list_utl_val        t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- Set utl columns strings
      l_list_utl_col := c_token_utl_column_hist;
      -- Get list of pk columns of the History Table
      p#frm#trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Get list of pk columns of the History Table'
      );
      l_vc_col_pk_hist :=
         p#frm#dict.fct_get_column_list (
            NULL
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'PK'
          , 'LIST_SIMPLE'
          , p_vc_exclude_list   => p#frm#stag_param.c_vc_column_valid_to
         );
      p#frm#trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Got columns'
      );
      --
      -- HEAD
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      -- Hist incremental procedure head
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_diff_incr
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Get list of all columns
      p#frm#trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Get list of all columns in common within stage and hist tables'
      );
      l_vc_col_list :=
         p#frm#dict.fct_get_column_subset (
            NULL
          , g_vc_owner_stg
          , g_vc_table_name_stage
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
         );
      p#frm#trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Got columns'
      );                                                                                                                                                                   -- In case the pk of stage 1 and History Tables is not the same, write a warning log

      IF g_vc_col_pk = l_vc_col_pk_hist
      OR (g_vc_col_pk IS NULL
      AND l_vc_col_pk_hist IS NULL) THEN
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          ,    'Source '
            || g_vc_source_code
            || ', Object '
            || g_vc_table_name_source
            || ' : Stage and hist table have the same Natural Keys'
         );
      ELSE
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          ,    'Source '
            || g_vc_source_code
            || ', Object '
            || g_vc_table_name_source
            || ' : Stage and hist table have different Natural Keys'
         );
      END IF;

      -- analyze stage table
      l_sql_prc_token := c_token_analyze;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'STAN'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_stage
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'partition'
       , NULL
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Analyse duplicates table
         l_sql_prc_token := c_token_analyze;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'statisticsType'
          , 'DUAN'
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'stgOwner'
          , g_vc_owner_stg
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , NULL
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Check hist/stage nk differences and truncate diff table
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || c_token_diff_check;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'stgOwner'
       , g_vc_owner_stg
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'stageTableName'
       , g_vc_table_name_stage
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffTableName'
       , g_vc_table_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'histTableName'
       , g_vc_table_name_hist
      );

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NULL THEN
         -- If there is no natural key (tecnical PK) then use the alternate difference method
         l_vc_clause_on :=
            p#frm#dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_ALL'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
            );
      ELSE
         -- If there is a natural key (tecnical PK) and the full outer join method is specified,
         -- then use the merge template
         -- Get list of conditions for the on clause of the merge
         l_vc_clause_on :=
            p#frm#dict.fct_get_column_list (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'PK'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => p#frm#stag_param.c_vc_column_valid_to
            );
         l_vc_col_nvl2 :=
            p#frm#dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_ALL'
             , 'LIST_NVL2'
             , 'src'
             , 'trg'
            );
         l_vc_clause_history :=
            p#frm#dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_NPK'
             , 'OR_DECODE'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => g_vc_col_update
            );
         l_vc_clause_update :=
            p#frm#dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_NPK'
             , 'OR_DECODE'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => g_vc_col_hist
            );
      END IF;

      l_n_iter_begin := 0;

      IF g_vc_partition_expr IS NOT NULL THEN
         l_n_iter_end := 9;
      ELSE
         l_n_iter_end := 0;
      END IF;

      l_sql_prc_token := '';

      FOR i IN l_n_iter_begin .. l_n_iter_end LOOP
         l_sql_prc_token := c_token_diff_insert;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NULL THEN
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_diff_without_nk
            );
         ELSE
            p#frm#ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , p#frm#stmt.c_sql_insert_diff_with_nk
            );
         END IF;

         p#frm#dict.prc_set_text_param (
            l_sql_prc_token
          , 'enableParallelDML'
          , CASE
               WHEN l_vc_set_anonymized IS NOT NULL THEN
                  p#frm#stmt.c_token_enable_parallel_dml
               ELSE
                  p#frm#stmt.c_token_disable_parallel_dml
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'diffPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourcePartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      -- Set object identifiers
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffIdentifier'
       , g_vc_table_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceIdentifier'
       , g_vc_table_name_stage
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetIdentifier'
       , g_vc_table_name_hist
      );
      -- Set list of columns
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'nvl2ColumnList'
       , l_vc_col_nvl2
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetColumnList'
       , l_vc_col_list
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'utlColumnList'
       , l_list_utl_col
      );
      -- Set clauses
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'historyClause'
       , NVL (l_vc_clause_history, '1=0')
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'updateClause'
       , NVL (l_vc_clause_update, '1=0')
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'joinClause'
       , l_vc_clause_on
      );
      prc_set_utl_columns (l_sql_prc_buffer);
      -- Ad analyze token
      l_sql_prc_token := c_token_analyze;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'DFAN'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'partition'
       , NULL
      );
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || l_sql_prc_token;
      -- Put all other code parameters
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceCode'
       , g_vc_source_code
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'objectName'
       , g_vc_object_name
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceTable'
       , g_vc_table_name_source
      );
      --
      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'joinType'
       , 'FULL'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_diff
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      --
      -- Load Hist without deletes
      --
      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'joinType'
       , 'LEFT'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_diff_incr
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_diff;

   PROCEDURE prc_create_prc_load_hist (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name         t_object_name := 'prc_create_prc_load_hist';
      l_vc_message          t_string
                               :=    'Procedure load hist '
                                  || g_vc_package_main;
      l_sql_prc             CLOB;
      l_sql_prc_token       CLOB;
      l_sql_prc_buffer      CLOB;
      --
      l_n_iter_begin        NUMBER;
      l_n_iter_end          NUMBER;
      -- List of columns
      l_vc_col_simple       t_string;
      l_vc_clause_on        t_string;
      l_vc_upd_clause_set   t_string;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      -- Set anonymizad column lists
      l_vc_set_anonymized := '';
      l_vc_col_anonymized := '';
      l_vc_fct_anonymized := '';
      l_vc_ins_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_columns;
      --
      -- HEAD
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_hist
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Get list of all columns
      l_vc_col_simple :=
         p#frm#dict.fct_get_column_subset (
            NULL
          , g_vc_owner_stg
          , g_vc_table_name_stage
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
         );

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NULL THEN
         -- If there is no natural key (tecnical PK) then use the alternate difference method
         l_vc_clause_on :=
            p#frm#dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_ALL'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
            );
      ELSE
         -- If there is a natural key (tecnical PK) and the full outer join method is specified,
         -- then use the merge template
         -- Get list of conditions for the on clause of the merge
         l_vc_clause_on :=
            p#frm#dict.fct_get_column_list (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'PK'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => p#frm#stag_param.c_vc_column_valid_to
            );
         l_vc_upd_clause_set :=
            p#frm#dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_NPK'
             , 'SET_ALIAS'
             , 'trg'
             , 'src'
            );
      END IF;

      l_n_iter_begin := 0;

      IF g_vc_partition_expr IS NOT NULL THEN
         l_n_iter_end := 9;
      ELSE
         l_n_iter_end := 0;
      END IF;

      l_sql_prc_token := '';

      FOR i IN l_n_iter_begin .. l_n_iter_end LOOP
         l_sql_prc_token := c_token_hist_reconcile;
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'closeStatement'
          , p#frm#stmt.c_sql_reconcile_close
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'updateStatement'
          , p#frm#stmt.c_sql_reconcile_update
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'insertStatement'
          , p#frm#stmt.c_sql_reconcile_insert
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'enableParallelDML'
          , CASE
               WHEN l_vc_set_anonymized IS NOT NULL THEN
                  p#frm#stmt.c_token_enable_parallel_dml
               ELSE
                  p#frm#stmt.c_token_disable_parallel_dml
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'diffPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'diffPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || p#frm#stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      -- Set object identifiers
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffIdentifier'
       , g_vc_table_name_diff
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetIdentifier'
       , g_vc_table_name_hist
      );
      -- Set list of columns
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffColumnList'
       ,    l_vc_col_simple
         || CHR (10)
         || l_vc_ins_anonymized
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetColumnList'
       ,    l_vc_col_simple
         || CHR (10)
         || l_vc_col_anonymized
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'utlColumnList'
       , c_token_utl_column_hist
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'utlValueList'
       , c_token_utl_colval_hist
      );
      -- Set clauses
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'joinClause'
       , l_vc_clause_on
      );
      -- Set the matched clause of the merge statement. This exists only if there are non-NK columns to set
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'matchedClause'
       , CASE
            WHEN l_vc_upd_clause_set IS NOT NULL THEN
                  l_vc_upd_clause_set
               || CHR (10)
               || l_vc_set_anonymized
               || ', '
         END
      );
      prc_set_utl_columns (l_sql_prc_buffer);
      -- Analyze token
      l_sql_prc_token := c_token_analyze;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'HSAN'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_hist
      );
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || l_sql_prc_token;                                                                                                                                                                                                   -- Put all other code parameters
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceCode'
       , g_vc_source_code
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'objectName'
       , g_vc_object_name
      );
      --
      -- Load Hist with table comparison
      --
      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_load_hist
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_hist;

   PROCEDURE prc_create_prc_wrapper (
      p_b_tc_only_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_wrapper';
      l_vc_message       t_string
                            :=    'Procedure wrapper '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- HEAD for FULL load
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_wrapper
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY for FULL load
      --
      l_sql_prc_buffer := c_token_prc_wrapper;

      IF p_b_tc_only_flag THEN
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          , NULL
         );
      ELSE
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          ,    p#frm#stag_param.c_vc_procedure_load_stage
            || ';'
         );
      END IF;

      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadDiff'
       ,    p#frm#stag_param.c_vc_procedure_load_diff
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadHist'
       ,    p#frm#stag_param.c_vc_procedure_load_hist
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncStage'
       ,    p#frm#stag_param.c_vc_procedure_trunc_stage
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncDiff'
       ,    p#frm#stag_param.c_vc_procedure_trunc_diff
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'tableName'
       , g_vc_table_name_hist
      );
      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_wrapper
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      --
      -- HEAD for INCREMENTAL load
      --
      l_sql_prc := p#frm#ddls.c_template_prc_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_wrapper_incr
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY for DELTA load
      --
      l_sql_prc_buffer := c_token_prc_wrapper;

      IF p_b_tc_only_flag THEN
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          , NULL
         );
      ELSE
         p#frm#ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          ,    p#frm#stag_param.c_vc_procedure_load_stage
            || ';'
         );
      END IF;

      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadDiff'
       ,    p#frm#stag_param.c_vc_procedure_load_diff
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadHist'
       ,    p#frm#stag_param.c_vc_procedure_load_diff_incr
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncStage'
       ,    p#frm#stag_param.c_vc_procedure_trunc_stage
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncDiff'
       ,    p#frm#stag_param.c_vc_procedure_trunc_diff
         || ';'
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'tableName'
       , g_vc_table_name_hist
      );
      -- Put body in the generic prc template
      l_sql_prc := p#frm#ddls.c_template_prc_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , NULL
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , p#frm#stag_param.c_vc_procedure_wrapper_incr
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_wrapper;

   PROCEDURE prc_compile_package_main (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_compile_package_main';
      l_vc_message    t_string
                         :=    'Package compile '
                            || g_vc_package_main;
      l_sql_create    CLOB;
   BEGIN
      -- Package head
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package head: Begin'
      );
      l_sql_create := p#frm#ddls.c_template_pkg_head;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'pkgName'
       , g_vc_package_main
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'varList'
       , ''
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'prcList'
       , l_buffer_pkg_head
      );
      -- Execute ddl for package head
      prc_store_ddl (
         'PACKAGE'
       , g_vc_package_main
       , l_sql_create
      );
      p#frm#ddls.prc_create_object (
         'PACKAGE'
       , g_vc_package_main
       , l_sql_create
       , FALSE
       , p_b_raise_flag
      );
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package head: End'
      );
      -- Package body
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package body: Begin'
      );
      l_sql_create := p#frm#ddls.c_template_pkg_body;
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'varList'
       , ''
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'prcList'
       , l_buffer_pkg_body
      );
      p#frm#ddls.prc_set_text_param (
         l_sql_create
       , 'pkgName'
       , g_vc_package_main
      );
      -- Execute ddl for package body
      prc_store_ddl (
         'PACKAGE BODY'
       , g_vc_package_main
       , l_sql_create
      );
      p#frm#ddls.prc_create_object (
         'PACKAGE BODY'
       , g_vc_package_main
       , l_sql_create
       , FALSE
       , p_b_raise_flag
      );
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package body: End'
      );
   END prc_compile_package_main;

   PROCEDURE prc_create_package_main (
      p_b_hist_only_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag        BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name   t_object_name := 'prc_create_package_main';
      l_vc_message    t_string
                         :=    'Package create '
                            || g_vc_package_main;
      l_sql_create    CLOB;
   BEGIN
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_buffer_pkg_head := '';
      l_buffer_pkg_body := '';

      IF NOT p_b_hist_only_flag THEN
         -- Get list of columns for the stage 1 and init procedures
         l_vc_col_src :=
            p#frm#dict.fct_get_column_list (
               g_vc_dblink
             , g_vc_owner_src
             , g_vc_table_name_source
             , 'ALL'
             , 'LIST_SIMPLE'
            );
         l_vc_col_dupl :=
            p#frm#dict.fct_get_column_subset (
               g_vc_dblink
             , g_vc_owner_src
             , g_vc_table_name_source
             , g_vc_owner_stg
             , g_vc_table_name_dupl
             , 'COMMON_ALL'
             , 'LIST_SIMPLE'
            );
      END IF;

      --
      -- Fill buffers with single procedures
      --
      -- Trunc Stage Table
      prc_create_prc_trunc_stage (p_b_raise_flag);
      --
      -- Trunc Diff table
      prc_create_prc_trunc_diff (p_b_raise_flag);

      IF NOT p_b_hist_only_flag THEN
         --
         -- Initial load
         prc_create_prc_init (p_b_raise_flag);
         --
         -- Stage 1 load
         prc_create_prc_load_stage (p_b_raise_flag);

         IF g_l_dblink.COUNT > 1
         OR g_vc_partition_expr IS NOT NULL THEN
            --
            -- Stage 1 load - single partitions
            prc_create_prc_load_stage_p (p_b_raise_flag);
         END IF;
      END IF;

      --
      -- Hist load
      prc_create_prc_load_diff (p_b_raise_flag);
      prc_create_prc_load_hist (p_b_raise_flag);
      --
      -- Wrapper
      prc_create_prc_wrapper (
         p_b_hist_only_flag
       , p_b_raise_flag
      );
      --
      -- Compile package
      prc_compile_package_main (p_b_raise_flag);
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_package_main;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#stag_ddl;
2014-11-28 13:53:25.001 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_stag_ddl
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Templates for standard code tokens
   **/
   --
   c_token_utl_column_hist        t_string := '#validFromColumnName#, #validToColumnName#, #dmlOpColumnName#';
   c_token_utl_coldef_hist        t_string := '#validFromColumnName# DATE, #validToColumnName# DATE, #dmlOpColumnName# VARCHAR2(10)';
   c_token_utl_colval_hist        t_string := 'SYSDATE, TO_DATE(''99991231'',''yyyymmdd''), ''I''';
   c_token_utl_column_source_db   t_string := '#sourceDbColumnName#';
   c_token_utl_coldef_source_db   t_string := '#sourceDbColumnName# VARCHAR(100)';
   c_token_utl_column_partition   t_string := '#partitionColumnName#';
   c_token_utl_coldef_partition   t_string := '#partitionColumnName# NUMBER(1)';
   --
   c_token_diff_partition         CLOB
                                     :=    'PARTITION BY LIST ('
                                        || dwhutl_stag_param.c_vc_column_dml_op
                                        || ')
    (  
	  PARTITION PI VALUES (''I'') NOLOGGING NOCOMPRESS
    , PARTITION PH VALUES (''H'') NOLOGGING NOCOMPRESS
    , PARTITION PU VALUES (''U'') NOLOGGING NOCOMPRESS
    , PARTITION PD VALUES (''D'') NOLOGGING NOCOMPRESS
    , PARTITION PR VALUES (''R'') NOLOGGING NOCOMPRESS
	)';
   c_token_diff_subpartition      CLOB
                                     :=    'PARTITION BY LIST (#partitionColumnName#)
    SUBPARTITION BY LIST ('
                                        || dwhutl_stag_param.c_vc_column_dml_op
                                        || ')
    SUBPARTITION TEMPLATE 
    (  
        SUBPARTITION PI VALUES (''I''),
        SUBPARTITION PH VALUES (''H''),
        SUBPARTITION PU VALUES (''U''),
        SUBPARTITION PD VALUES (''D''),
        SUBPARTITION PR VALUES (''R'')
    )
    (
        PARTITION p0 VALUES (0) NOLOGGING NOCOMPRESS,
        PARTITION p1 VALUES (1) NOLOGGING NOCOMPRESS,
        PARTITION p2 VALUES (2) NOLOGGING NOCOMPRESS,
        PARTITION p3 VALUES (3) NOLOGGING NOCOMPRESS,
        PARTITION p4 VALUES (4) NOLOGGING NOCOMPRESS,
        PARTITION p5 VALUES (5) NOLOGGING NOCOMPRESS,
        PARTITION p6 VALUES (6) NOLOGGING NOCOMPRESS,
        PARTITION p7 VALUES (7) NOLOGGING NOCOMPRESS,
        PARTITION p8 VALUES (8) NOLOGGING NOCOMPRESS,
        PARTITION p9 VALUES (9) NOLOGGING NOCOMPRESS
    )';
   c_token_partition              CLOB := 'PARTITION BY LIST (#partitionColumnName#)
    (
        PARTITION p0 VALUES (0) NOLOGGING NOCOMPRESS,
        PARTITION p1 VALUES (1) NOLOGGING NOCOMPRESS,
        PARTITION p2 VALUES (2) NOLOGGING NOCOMPRESS,
        PARTITION p3 VALUES (3) NOLOGGING NOCOMPRESS,
        PARTITION p4 VALUES (4) NOLOGGING NOCOMPRESS,
        PARTITION p5 VALUES (5) NOLOGGING NOCOMPRESS,
        PARTITION p6 VALUES (6) NOLOGGING NOCOMPRESS,
        PARTITION p7 VALUES (7) NOLOGGING NOCOMPRESS,
        PARTITION p8 VALUES (8) NOLOGGING NOCOMPRESS,
        PARTITION p9 VALUES (9) NOLOGGING NOCOMPRESS
    )';
   -- Template to initialize run time statistics in a procedure
   -- Set the step number and the workflow
   c_token_prc_initialize         CLOB := '';
   -- Template to finalize run time statistics in a procedure
   -- Set the final step number and finalize job statistics
   c_token_prc_finalize           CLOB := '';
   -- Exception handler
   c_token_prc_exception          CLOB := 'dwhutl_stag_stat.prc_stat_end(l_n_stat_id, 0, 1);';
   -- Standard parameters for a generated procedure
   c_token_prc_param              CLOB := 'p_n_stream NUMBER DEFAULT NULL';
   -- Code body for the wrapper procedure
   c_token_prc_wrapper            CLOB := '
        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''Staging Begin'', ''Start extracting from #tableName#'');

		#prcLoadStage#

        #prcLoadDiff#

		#prcLoadHist#

		#prcTruncStage#

		#prcTruncDiff#

        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''Staging End'', ''Stage completed for #tableName#'');';
   -- Statistics token
   c_token_analyze                CLOB := '
        l_n_stat_id := dwhutl_stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', NULL, ''#statisticsType#'');
        
        DBMS_STATS.UNLOCK_TABLE_STATS (''#stgOwner#'', ''#tableName#'') ;
        DBMS_STATS.GATHER_TABLE_STATS (''#stgOwner#'', ''#tableName#'', NULL, 1);
        dwhutl_stag_stat.prc_size_store(''#sourceCode#'', ''#objectName#'', ''#tableName#'');

        dwhutl_stag_stat.prc_stat_end(l_n_stat_id, 0);

        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''STAT END'', ''#tableName# : Statistics gathered'');
        ';
   -- Check token of the init procedure
   c_token_check_table_isempty    CLOB := '
		  dwhutl_trac.log_sub_debug (l_vc_prc_name, ''CHECK'', ''Check table #tableName# '');
        SELECT COUNT (*)
          INTO l_n_result
          FROM #tableName#
         WHERE rownum = 1;
         
        IF l_n_result = 0 THEN
              dwhutl_trac.log_sub_debug (l_vc_prc_name, ''CHECK'', ''Table #tableName# is empty'');
        ELSE
            dwhutl_trac.log_sub_error (l_vc_prc_name, ''CHECK'', ''Table #tableName# is not empty'');
            raise_application_error (-20000, ''Cannot init load non-empty table'');        
        END IF;';
   -- Insert token of the staging 1 procedure
   c_token_stage_get_incr_bound   CLOB := '
   
          dwhutl_trac.log_sub_debug (l_vc_prc_name, ''INCR BOUND'', ''#tableName# #partition# : get last #incrementColumn#'');
   
        SELECT MAX(#incrementColumn#)
          INTO l_t_increment_bound
          FROM #histTableName# #partition#;
          
          dwhutl_trac.log_sub_debug (l_vc_prc_name, ''INCR BOUND'', ''#tableName# #partition# : last #incrementColumn# = '' || l_t_increment_bound);
        
        ';
   -- Insert token of the staging procedure
   c_token_stage_insert           CLOB := '
        l_n_stat_id := dwhutl_stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''STIN'');

        #computeIncrementBound#
                   
        #insertStatement#

		l_n_result := SQL%ROWCOUNT;

		dwhutl_stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

        COMMIT;

        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''INSERT END'', ''#targetIdentifier# #partition# : '' || l_n_result || '' rows inserted'', NULL, l_n_result);
		';
   -- Check token of the historicizing procedure
   c_token_diff_check             CLOB := '
        l_b_ok := dwhutl_dict.fct_check_pk (
			NULL, ''#stgOwner#'', ''#stageTableName#'', ''#stgOwner#'', ''#histTableName#''
		);
		IF l_b_ok THEN
			  dwhutl_trac.log_sub_debug (l_vc_prc_name, ''CHECK NK'', ''#stageTableName# and #histTableName# have the same NK'');
		ELSE
			  dwhutl_trac.log_sub_warn (l_vc_prc_name, ''CHECK NK'', ''#stageTableName# and #histTableName# have not the same NK'');		
		END IF;
        
        SELECT COUNT(*) INTO l_n_result FROM #stageTableName#;
        
        IF l_n_result = 0 THEN
            dwhutl_trac.log_sub_error (l_vc_prc_name, ''CHECK'', ''Table #stageTableName# is empty'');
            raise_application_error (-20000, ''Stage table is empty.'');        
        END IF;
        
        EXECUTE IMMEDIATE ''ALTER SESSION ENABLE PARALLEL DML'';
		
		-- Truncate Diff table
		 dwhutl_trac.log_sub_debug (l_vc_prc_name, ''DIFF TRUNCATE'', ''Truncate #diffIdentifier#'');		
		EXECUTE IMMEDIATE ''TRUNCATE TABLE #diffIdentifier# DROP STORAGE'';
		 dwhutl_trac.log_sub_debug (l_vc_prc_name, ''DIFF TRUNCATE'', ''#diffIdentifier# truncated'');
		';
   -- Diff token of the historicizing procedure - with nk
   c_token_diff_insert            CLOB := '
		dwhutl_trac.log_sub_debug (l_vc_prc_name, ''DIFF BEGIN'', ''Insert into #diffIdentifier#'');

		l_n_stat_id := dwhutl_stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''DFIN'');
      
        #insertStatement#
        
		l_n_result := SQL%ROWCOUNT;

      COMMIT;

	  dwhutl_stag_stat.prc_stat_end(l_n_stat_id, l_n_result);
		
      dwhutl_trac.log_sub_debug (l_vc_prc_name, ''DIFF INSERTED'', ''#diffIdentifier# : '' || l_n_result || '' rows inserted'');
';
   -- Merge token of the historicizing procedure - 2 separate statement
   c_token_hist_reconcile         CLOB := '
        #enableParallelDML#
		
        -- Close old and deleted records in hist table
        
        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''HIST CLOSE'', ''Update #targetIdentifier#'');
        l_n_stat_id := dwhutl_stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''HSCL'');

        #closeStatement#

        l_n_result := SQL%ROWCOUNT;

        dwhutl_stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

        COMMIT;
        
        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''HIST CLOSED'', ''#targetIdentifier# : '' || l_n_result || '' rows updated'');
        
    	-- Update Hist table
		
		dwhutl_trac.log_sub_debug (l_vc_prc_name, ''HIST UPDATE'', ''Update #targetIdentifier#'');
		l_n_stat_id := dwhutl_stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''HSUP'');

        #updateStatement#

		l_n_result := SQL%ROWCOUNT;

		dwhutl_stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

        COMMIT;
		
        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''HIST UPDATED'', ''#targetIdentifier# : '' || l_n_result || '' rows updated'');
		
		-- Insert into Hist table
		
        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''HIST INSERT'', ''#targetIdentifier# : Insert'');

	    l_n_stat_id := dwhutl_stag_stat.prc_stat_begin(''#sourceCode#'', ''#objectName#'', #partitionId#, ''HSIN'');
        
        #insertStatement#

        l_n_result := SQL%ROWCOUNT;

        dwhutl_stag_stat.prc_stat_end(l_n_stat_id, l_n_result);

	    COMMIT;

        dwhutl_trac.log_sub_debug (l_vc_prc_name, ''HIST END'', ''#targetIdentifier# : '' || l_n_result || '' rows inserted'');';
   -- Buffers
   l_buffer_pkg_head              CLOB;
   l_buffer_pkg_body              CLOB;
   l_vc_col_src                   t_string;
   l_vc_col_dupl                  t_string;
   l_vc_col_pk_notnull            t_string;
   -- Anonymization
   l_vc_def_anonymized            t_string;
   l_vc_col_anonymized            t_string;
   l_vc_set_anonymized            t_string;
   l_vc_ins_anonymized            t_string;
   l_vc_fct_anonymized            t_string;
   l_vc_ini_anonymized            t_string;
   l_vc_viw_anonymized            t_string;

   FUNCTION fct_get_partition_db (p_vc_db_identifier VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN    CHR (10)
             || ' PARTITION '
             || dwhutl_stag_param.c_vc_prefix_partition
             || '_'
             || p_vc_db_identifier
             || ' VALUES ('''
             || p_vc_db_identifier
             || ''') NOLOGGING COMPRESS';
   END;

   FUNCTION fct_get_partition_expr
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN    ' CASE WHEN TRIM( TRANSLATE ('
             || g_vc_partition_expr
             || ',''0123456789'',''          '')) IS NULL THEN TO_NUMBER('
             || g_vc_partition_expr
             || ') ELSE 0 END';
   END;

   PROCEDURE prc_set_utl_columns (p_vc_code_string IN OUT CLOB)
   IS
      l_vc_prc_name   t_object_name := 'prc_set_utl_columns';
   BEGIN
      dwhutl_ddls.prc_set_text_param (
         p_vc_code_string
       , 'validFromColumnName'
       , dwhutl_stag_param.c_vc_column_valid_from
      );
      dwhutl_ddls.prc_set_text_param (
         p_vc_code_string
       , 'validToColumnName'
       , dwhutl_stag_param.c_vc_column_valid_to
      );
      dwhutl_ddls.prc_set_text_param (
         p_vc_code_string
       , 'dmlOpColumnName'
       , dwhutl_stag_param.c_vc_column_dml_op
      );
      dwhutl_ddls.prc_set_text_param (
         p_vc_code_string
       , 'sourceDbColumnName'
       , dwhutl_stag_param.c_vc_column_source_db
      );
      dwhutl_ddls.prc_set_text_param (
         p_vc_code_string
       , 'partitionColumnName'
       , dwhutl_stag_param.c_vc_column_partition
      );
   END prc_set_utl_columns;

   -- Procedure to set column definition list in order to add anonymized columns to the stage2 table
   /*PROCEDURE prc_set_anonymized_coldefs
   IS
   BEGIN
      FOR r_col IN (SELECT   table_name
                           , src_column_name
                           , trg_column_name
                           , stag_column_def
                           , data_type
                           , data_length
                           , ora_function_name
                        FROM all_tab_columns exi
                           , (SELECT col.stag_object_id
                                   , col.stag_object_name
                                   , col.stag_stg2_table_name
                                   , col.stag_column_pos
                                   , col.stag_column_def
                                   , msk.src_column_name
                                   , msk.trg_column_name
                                   , msk.ora_function_name
                                FROM (SELECT o.stag_object_id
                                           , o.stag_object_name
                                           , o.stag_stg2_table_name
                                           , c.stag_column_pos
                                           , c.stag_column_name
                                           , c.stag_column_def
                                        FROM stag_object_t o
                                           , stag_column_t c
                                       WHERE o.stag_object_id = c.stag_object_id) col
                                   , (SELECT atab.table_name
                                           , acol.src_column_name
                                           , acol.trg_column_name
                                           , meth.ora_function_name
                                        FROM dmaskadmin.da_schema_v asch
                                           , dmaskadmin.da_table_v atab
                                           , dmaskadmin.da_column_v acol
                                           , dmaskadmin.da_business_attribute_v attr
                                           , dmaskadmin.da_method_v meth
                                       WHERE asch.schema_id = atab.schema_id
                                         AND atab.table_id = acol.table_id
                                         AND acol.business_attribute_id = attr.attribute_id
                                         AND attr.anonym_method_id = meth.method_id) msk
                               WHERE col.stag_stg2_table_name = msk.table_name
                                 AND col.stag_column_name = msk.src_column_name) met
                       WHERE met.stag_stg2_table_name = exi.table_name(+)
                         AND met.trg_column_name = exi.column_name(+)
                         AND exi.owner(+) = g_vc_owner_stg
                         AND exi.owner IS NULL
                    ORDER BY stag_column_pos)
      LOOP
         l_vc_def_anonymized    := l_vc_def_anonymized || ',' || r_col.trg_column_name || ' ' || r_col.stag_column_def;
         l_vc_ini_anonymized    :=
               l_vc_ini_anonymized
            || ','
            || r_col.trg_column_name
            || ' = '
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || r_col.ora_function_name
            || '('
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || CHR (10);
      END LOOP;

      NULL;
   END;

   -- Procedure to set column lists for stage2 update and insert statements
   PROCEDURE prc_set_anonymized_columns
   IS
   BEGIN
      FOR r_col IN (SELECT   msk.table_name
                           , msk.src_column_name
                           , msk.trg_column_name
                           , col.stag_column_def
                           , data_type
                           , data_length
                           , msk.ora_function_name
                        FROM all_tab_columns exi
                           , (SELECT o.stag_object_id
                                   , o.stag_object_name
                                   , o.stag_stg2_table_name
                                   , c.stag_column_pos
                                   , c.stag_column_name
                                   , c.stag_column_def
                                FROM stag_object_t o
                                   , stag_column_t c
                               WHERE o.stag_object_id = c.stag_object_id) col
                           , (SELECT atab.table_name
                                   , acol.src_column_name
                                   , acol.trg_column_name
                                   , meth.ora_function_name
                                FROM dmaskadmin.da_schema_v asch
                                   , dmaskadmin.da_table_v atab
                                   , dmaskadmin.da_column_v acol
                                   , dmaskadmin.da_business_attribute_v attr
                                   , dmaskadmin.da_method_v meth
                               WHERE asch.schema_id = atab.schema_id
                                 AND atab.table_id = acol.table_id
                                 AND acol.business_attribute_id = attr.attribute_id
                                 AND attr.anonym_method_id = meth.method_id) msk
                       WHERE col.stag_stg2_table_name = exi.table_name
                         AND col.stag_column_name = exi.column_name
                         AND col.stag_stg2_table_name = msk.table_name
                         AND col.stag_column_name = msk.src_column_name
                         AND col.stag_object_id = g_n_object_id
                         AND exi.owner = g_vc_owner_stg
                    ORDER BY stag_column_pos)
      LOOP
         l_vc_col_anonymized    := l_vc_col_anonymized || ',' || r_col.trg_column_name || CHR (10);
         l_vc_set_anonymized    :=
               l_vc_set_anonymized
            || ',trg.'
            || r_col.trg_column_name
            || ' = CASE WHEN dmaskadmin.pkg_da_anonymization_lib.is_ano_required('''
            || g_vc_owner_stg
            || ''','''
            || r_col.table_name
            || ''','''
            || r_col.src_column_name
            || ''','
            || r_col.src_column_name
            || ') = ''Y'' THEN'
            || CHR (10)
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || 'dmaskadmin.'
            || r_col.ora_function_name
            || '(src.'
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || 'ELSE src.'
            || r_col.src_column_name
            || CHR (10)
            || 'END';
         l_vc_ins_anonymized    :=
               l_vc_ins_anonymized
            || ',CASE WHEN dmaskadmin.pkg_da_anonymization_lib.is_ano_required('''
            || g_vc_owner_stg
            || ''','''
            || r_col.table_name
            || ''','''
            || r_col.src_column_name
            || ''','
            || r_col.src_column_name
            || ') = ''Y'' THEN'
            || CHR (10)
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || 'dmaskadmin.'
            || r_col.ora_function_name
            || '(src.'
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || CHR (10)
            || 'ELSE src.'
            || r_col.src_column_name
            || CHR (10)
            || 'END';
         l_vc_fct_anonymized    :=
               l_vc_fct_anonymized
            || ',CASE WHEN dmaskadmin.pkg_da_anonymization_lib.is_ano_required('''
            || g_vc_owner_stg
            || ''','''
            || r_col.table_name
            || ''','''
            || r_col.src_column_name
            || ''','
            || r_col.src_column_name
            || ') = ''Y'' THEN'
            || CHR (10)
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN 'SUBSTR('
               END
            || 'dmaskadmin.'
            || r_col.ora_function_name
            || '('
            || r_col.src_column_name
            || ')'
            || CASE
                  WHEN r_col.data_type LIKE '%CHAR%'
                     THEN ',1,' || r_col.data_length || ')'
               END
            || CHR (10)
            || 'ELSE '
            || r_col.src_column_name
            || CHR (10)
            || 'END';
      END LOOP;

      NULL;
   END;

   PROCEDURE prc_set_anonymized_viewcols
   IS
   BEGIN
      FOR r_col IN (SELECT   exi.table_name
                           , exi.column_name
                           , msk.trg_column_name
                        FROM all_tab_columns exi
                           , (SELECT atab.table_name
                                   , acol.src_column_name
                                   , acol.trg_column_name
                                   , meth.ora_function_name
                                FROM dmaskadmin.da_schema_v asch
                                   , dmaskadmin.da_table_v atab
                                   , dmaskadmin.da_column_v acol
                                   , dmaskadmin.da_business_attribute_v attr
                                   , dmaskadmin.da_method_v meth
                               WHERE asch.schema_id = atab.schema_id
                                 AND atab.table_id = acol.table_id
                                 AND acol.business_attribute_id = attr.attribute_id
                                 AND attr.anonym_method_id = meth.method_id) msk
                       WHERE exi.table_name = msk.table_name(+)
                         AND exi.column_name = msk.src_column_name(+)
                         AND exi.table_name = UPPER (g_vc_table_name_hist)
                         AND exi.owner = g_vc_owner_stg
                    ORDER BY exi.column_id)
      LOOP
         l_vc_viw_anonymized    :=
               l_vc_viw_anonymized
            || ','
            || CASE
                  WHEN pkg_param.c_vc_db_name_actual IN (pkg_param.c_vc_db_name_dev, pkg_param.c_vc_db_name_tst)
                  AND r_col.trg_column_name IS NOT NULL
                     THEN r_col.trg_column_name || ' AS ' || r_col.column_name
                  ELSE r_col.column_name
               END
            || CHR (10);
      END LOOP;
   END;*/
   PROCEDURE prc_store_ddl (
      p_vc_object_type    VARCHAR2
    , p_vc_object_name    VARCHAR2
    , p_vc_object_ddl     CLOB
   )
   IS
      l_vc_prc_name   t_object_name := 'prc_store_ddl';
   BEGIN
      MERGE INTO dwhutl_stag_ddl_t trg
           USING (SELECT UPPER (p_vc_object_type) AS object_type
                       , UPPER (p_vc_object_name) AS object_name
                       , p_vc_object_ddl AS object_ddl
                    FROM DUAL) src
              ON (UPPER (trg.stag_ddl_type) = UPPER (src.object_type)
              AND UPPER (trg.stag_ddl_name) = UPPER (src.object_name))
      WHEN MATCHED THEN
         UPDATE SET trg.stag_ddl_code = src.object_ddl
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_ddl_type
                     , trg.stag_ddl_name
                     , trg.stag_ddl_code
                    )
             VALUES (
                       src.object_type
                     , src.object_name
                     , src.object_ddl
                    );

      COMMIT;
   END prc_store_ddl;

   PROCEDURE prc_create_stage_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name    t_object_name := 'prc_create_stage_table';
      l_vc_message     t_string
                          :=    'Stage Table '
                             || g_vc_table_name_stage;
      l_sql_create     CLOB;
      l_list_utl_col   t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_coldef_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_coldef_partition
               || ','
         END;
      -- Build create table statement
      l_sql_create := dwhutl_ddls.c_template_create_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_stage
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       , g_vc_col_def
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING COMPRESS '
         || CASE
               WHEN g_vc_tablespace_stage_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_data
            END
      );

      -- Partitions
      IF g_l_distr_code.COUNT > 1 THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ' PARTITION BY LIST (#sourceDbColumnName#) (';

         FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
            IF i > 1 THEN
               l_sql_create :=
                     l_sql_create
                  || ',';
            END IF;

            l_sql_create :=
                  l_sql_create
               || fct_get_partition_db (g_l_distr_code (i));
         END LOOP;

         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ')';
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || c_token_partition;
      END IF;

      prc_set_utl_columns (l_sql_create);
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_stage
       , l_sql_create
      );

      BEGIN
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Creating table'
         );
         dwhutl_ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_stage
          , l_sql_create
          , p_b_drop_flag
          , TRUE
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Table created'
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Error creating'
            );
            RAISE;
      END;

      BEGIN
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Setting compression option...'
         );

         EXECUTE IMMEDIATE
               'ALTER TABLE '
            || g_vc_table_name_stage
            || ' COMPRESS FOR QUERY LOW';

         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Compression option set'
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'FOR QUERY LOW option not available'
            );
      END;

      -- Build constraint statement
      /*l_sql_create          := c_token_create_pk;
      dwhutl_ddls.prc_set_text_param (l_sql_create
                                    , 'tableName'
                                    , g_vc_table_name_stage
                                     );
      dwhutl_ddls.prc_set_text_param (l_sql_create
                                    , 'pkName'
                                    , g_vc_nk_name_stage
                                     );
      dwhutl_ddls.prc_set_text_param (l_sql_create
                                    , 'listColPk'
                                    , g_vc_col_pk
                                     );
      dwhutl_ddls.prc_set_text_param (l_sql_create
                                    , 'storageClause'
                                    , 'NOLOGGING ' || CASE
                                         WHEN g_l_distr_code.COUNT > 1
                                            THEN 'LOCAL'
                                      END || CASE
                                         WHEN g_vc_tablespace_stage_indx IS NOT NULL
                                            THEN ' TABLESPACE ' || g_vc_tablespace_stage_indx
                                      END
                                     );
      prc_set_utl_columns (l_sql_create);
      prc_store_ddl ('CONSTRAINT'
                   , g_vc_nk_name_stage
                   , l_sql_create
                    );

      BEGIN
           dwhutl_trac.log_sub_debug (l_vc_message, 'Creating NK...');
         dwhutl_ddls.prc_create_object ('CONSTRAINT'
                                      , g_vc_nk_name_stage
                                      , l_sql_create
                                      , p_b_drop_flag
                                      , TRUE
                                       );
           dwhutl_trac.log_sub_debug (l_vc_message, 'NK created');
      EXCEPTION
         WHEN OTHERS
         THEN
              dwhutl_trac.log_sub_debug (SQLERRM
                           , 'NK not created'
                           , param.gc_log_warn
                            );
            RAISE;
      END;*/
      IF g_n_parallel_degree > 1 THEN
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Setting parallel option...'
         );

         EXECUTE IMMEDIATE
               'ALTER TABLE '
            || g_vc_table_name_stage
            || ' PARALLEL '
            || g_n_parallel_degree;

         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Parallel option set...'
         );
      END IF;

      -- Comments from source system
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Setting comments...'
      );

      EXECUTE IMMEDIATE
            'COMMENT ON TABLE '
         || g_vc_table_name_stage
         || ' IS '''
         || g_vc_table_comment
         || '''';

      FOR r_comm IN (SELECT c.stag_column_name
                          , c.stag_column_comment
                       FROM dwhutl_stag_object_t o
                          , dwhutl_stag_column_t c
                      WHERE o.stag_object_id = c.stag_object_id
                        AND o.stag_object_id = g_n_object_id) LOOP
         EXECUTE IMMEDIATE
               'COMMENT ON COLUMN '
            || g_vc_table_name_stage
            || '.'
            || r_comm.stag_column_name
            || ' IS '''
            || r_comm.stag_column_comment
            || '''';
      END LOOP;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Comments set...'
      );
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_error (
            l_vc_prc_name
          , l_vc_message
          , 'Stage Table: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_stage_table;

   PROCEDURE prc_create_duplicate_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name    t_object_name := 'prc_create_duplicate_table';
      l_vc_message     t_string
                          :=    'Table duplicates '
                             || g_vc_table_name_dupl;
      l_sql_create     CLOB;
      l_list_utl_col   t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_coldef_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_coldef_partition
               || ','
         END;
      -- Build create table statement
      l_sql_create := dwhutl_ddls.c_template_create_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_dupl
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       , g_vc_col_def
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING'
         || CASE
               WHEN g_vc_tablespace_stage_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_data
            END
      );

      -- Stage1 partitions
      IF g_l_distr_code.COUNT > 1 THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ' PARTITION BY LIST (#sourceDbColumnName#) (';

         FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
            IF i > 1 THEN
               l_sql_create :=
                     l_sql_create
                  || ',';
            END IF;

            l_sql_create :=
                  l_sql_create
               || fct_get_partition_db (g_l_distr_code (i));
         END LOOP;

         l_sql_create :=
               l_sql_create
            || CHR (10)
            || ')';
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || c_token_partition;
      END IF;

      prc_set_utl_columns (l_sql_create);
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_dupl
       , l_sql_create
      );

      BEGIN
         dwhutl_ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_dupl
          , l_sql_create
          , p_b_drop_flag
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Duplicates Table: Warning'
            );
            RAISE;
      END;

      IF g_n_parallel_degree > 1 THEN
         l_sql_create :=
               'ALTER TABLE '
            || g_vc_table_name_dupl
            || ' PARALLEL '
            || g_n_parallel_degree;
         dwhutl_ddls.prc_execute (l_sql_create);
      END IF;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Duplicates Table: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_error (
            l_vc_prc_name
          , l_vc_message
          , 'Stage Table: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_duplicate_table;

   PROCEDURE prc_create_diff_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name            t_object_name := 'prc_create_diff_table';
      l_vc_message             t_string
                                  :=    'Table difference '
                                     || g_vc_table_name_diff;
      l_sql_create             CLOB;
      l_sql_subpart_template   t_string;
      l_list_utl_col           t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Difference table: Begin'
      );
      l_list_utl_col :=
            c_token_utl_coldef_hist
         || ','
         || CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     c_token_utl_coldef_source_db
                  || ','
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     c_token_utl_coldef_partition
                  || ','
            END;
      l_sql_create := dwhutl_ddls.c_template_create_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       , g_vc_col_def
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING '
         || CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_diff_subpartition
               ELSE
                  c_token_diff_partition
            END
         || CASE
               WHEN g_vc_tablespace_stage_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_data
            END
      );
      prc_set_utl_columns (l_sql_create);
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_diff
       , l_sql_create
      );

      BEGIN
         dwhutl_ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_diff
          , l_sql_create
          , p_b_drop_flag
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Difference Table: Error'
            );
            RAISE;
      END;

      l_sql_create := dwhutl_ddls.c_template_create_pk;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'pkName'
       , g_vc_nk_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColPk'
       , g_vc_col_pk
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING'
         || CASE
               WHEN g_vc_tablespace_stage_indx IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_stage_indx
            END
      );
      prc_store_ddl (
         'CONSTRAINT'
       , g_vc_nk_name_diff
       , l_sql_create
      );

      BEGIN
         dwhutl_ddls.prc_create_object (
            'CONSTRAINT'
          , g_vc_table_name_diff
          , l_sql_create
          , p_b_drop_flag
          , p_b_raise_flag
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'Difference table: Warning'
            );
            RAISE;
      END;

      IF g_n_parallel_degree > 1 THEN
         l_sql_create :=
               'ALTER TABLE '
            || g_vc_table_name_diff
            || ' PARALLEL '
            || g_n_parallel_degree;
         dwhutl_ddls.prc_execute (l_sql_create);
      END IF;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Difference table: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_error (
            l_vc_prc_name
          , l_vc_message
          , 'Difference table: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_diff_table;

   PROCEDURE prc_create_hist_table (
      p_b_drop_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag    BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name     t_object_name := 'prc_create_hist_table';
      l_vc_message      t_string
                           :=    'History Table '
                              || g_vc_table_name_hist;
      l_sql_create      t_string;
      l_list_utl_col    t_string;
      l_l_utl_columns   DBMS_SQL.varchar2s;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Diff Table: Begin'
      );
      -- Set anonymizad column lists
      l_vc_def_anonymized := '';
      l_vc_ini_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_coldefs;
      -- Generate table ddl
      l_list_utl_col :=
            c_token_utl_coldef_hist
         || ','
         || CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     c_token_utl_coldef_source_db
                  || ','
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     c_token_utl_coldef_partition
                  || ','
            END;
      l_sql_create := dwhutl_ddls.c_template_create_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_hist
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColUtl'
       , l_list_utl_col
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColumns'
       ,    g_vc_col_def
         || l_vc_def_anonymized
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING COMPRESS '
         || CASE
               WHEN g_vc_tablespace_hist_data IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_hist_data
            END
      );

      IF g_vc_partition_expr IS NOT NULL THEN
         l_sql_create :=
               l_sql_create
            || CHR (10)
            || c_token_partition;
      END IF;

      prc_set_utl_columns (l_sql_create);
      -- Execute table ddl
      prc_store_ddl (
         'TABLE'
       , g_vc_table_name_hist
       , l_sql_create
      );

      BEGIN
         -- Try to create table
         dwhutl_ddls.prc_create_object (
            'TABLE'
          , g_vc_table_name_hist
          , l_sql_create
          , FALSE
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_error (
               l_vc_prc_name
             , l_vc_message
             , 'History Table Create: Warning'
            );

            IF l_vc_def_anonymized IS NOT NULL THEN
               BEGIN
                  dwhutl_trac.log_sub_debug (
                     'Add new anonymized columns'
                   , 'History Table Add Anonymized'
                  );

                  -- Try to add newly anonymized columns
                  EXECUTE IMMEDIATE
                        'ALTER TABLE '
                     || g_vc_table_name_hist
                     || ' ADD ('
                     || LTRIM (
                           l_vc_def_anonymized
                         , ','
                        )
                     || ')';
               EXCEPTION
                  WHEN OTHERS THEN
                     dwhutl_trac.log_sub_warn (
                        l_vc_prc_name
                      , l_vc_message
                      , 'History Table Add Anonymized: Warning'
                     );

                     IF p_b_raise_flag THEN
                        RAISE;
                     END IF;
               END;
            END IF;

            IF l_vc_ini_anonymized IS NOT NULL THEN
               BEGIN
                  dwhutl_trac.log_sub_debug (
                     l_vc_prc_name
                   , l_vc_message
                   , 'Fill new anonymized columns - History Table Upd Anonymized'
                  );

                  -- Try to fill newly added anonymized columns
                  EXECUTE IMMEDIATE
                        'UPDATE '
                     || g_vc_table_name_hist
                     || ' SET '
                     || LTRIM (
                           l_vc_ini_anonymized
                         , ','
                        );

                  COMMIT;
               EXCEPTION
                  WHEN OTHERS THEN
                     dwhutl_trac.log_sub_warn (
                        l_vc_prc_name
                      , l_vc_message
                      , 'History Table Upd Anonymized: Warning'
                     );

                     IF p_b_raise_flag THEN
                        RAISE;
                     END IF;
               END;
            END IF;

            IF p_b_raise_flag THEN
               RAISE;
            END IF;
      END;

      IF g_n_parallel_degree > 1 THEN
         l_sql_create :=
               'ALTER TABLE '
            || g_vc_table_name_hist
            || ' PARALLEL '
            || g_n_parallel_degree;
         dwhutl_ddls.prc_execute (l_sql_create);
      END IF;

      IF g_vc_fb_archive IS NOT NULL
     AND g_n_fbda_flag = 1 THEN
         BEGIN
            EXECUTE IMMEDIATE
                  'ALTER TABLE '
               || g_vc_table_name_hist
               || ' FLASHBACK ARCHIVE '
               || g_vc_fb_archive;
         EXCEPTION
            WHEN OTHERS THEN
               dwhutl_trac.log_sub_debug (
                  l_vc_prc_name
                , l_vc_message
                , 'History Table: FLASHBACK'
               );
         END;
      END IF;

      BEGIN
         EXECUTE IMMEDIATE
               'ALTER TABLE '
            || g_vc_table_name_hist
            || ' COMPRESS FOR QUERY LOW';
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_warn (
               l_vc_prc_name
             , l_vc_message
             , 'FOR QUERY LOW option not available'
            );
      END;

      -- Generate NK ddl
      l_sql_create := dwhutl_ddls.c_template_create_pk;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'tableName'
       , g_vc_table_name_hist
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'pkName'
       , g_vc_nk_name_hist
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'listColPk'
       ,    dwhutl_stag_param.c_vc_column_valid_to
         || ','
         || g_vc_col_pk
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'storageClause'
       ,    'NOLOGGING '
         || CASE
               WHEN g_l_distr_code.COUNT > 1
                AND dwhutl_dict.fct_check_part (
                       NULL
                     , g_vc_owner_stg
                     , g_vc_table_name_hist
                    ) THEN
                  'LOCAL'
            END
         || CASE
               WHEN g_vc_tablespace_hist_indx IS NOT NULL THEN
                     ' TABLESPACE '
                  || g_vc_tablespace_hist_indx
            END
      );
      -- Execute NK ddl
      prc_store_ddl (
         'CONSTRAINT'
       , g_vc_nk_name_hist
       , l_sql_create
      );

      BEGIN
         dwhutl_ddls.prc_create_object (
            'CONSTRAINT'
          , g_vc_nk_name_hist
          , l_sql_create
          , FALSE
          , TRUE
         );
      EXCEPTION
         WHEN OTHERS THEN
            dwhutl_trac.log_sub_warn (
               l_vc_prc_name
             , l_vc_message
             , 'Hist table Natural Key: Warning'
            );

            IF p_b_raise_flag THEN
               RAISE;
            END IF;
      END;

      -- Create not null constraints
      l_l_utl_columns :=
         dwhutl_type.fct_string_to_list (
            c_token_utl_column_hist
          , ','
         );

      FOR i IN l_l_utl_columns.FIRST .. l_l_utl_columns.LAST LOOP
         l_sql_create := dwhutl_ddls.c_template_create_notnull;
         dwhutl_ddls.prc_set_text_param (
            l_sql_create
          , 'tableName'
          , g_vc_table_name_hist
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_create
          , 'columnName'
          , l_l_utl_columns (i)
         );
         -- Execute Check ddl
         prc_set_utl_columns (l_sql_create);
         prc_store_ddl (
            'CONSTRAINT'
          ,    SUBSTR (
                  g_vc_nk_name_hist
                , 1
                , 25
               )
            || '_NN'
            || TO_CHAR (
                  i
                , '00'
               )
          , l_sql_create
         );

         BEGIN
            dwhutl_ddls.prc_create_object (
               'CONSTRAINT'
             ,    SUBSTR (
                     g_vc_nk_name_hist
                   , 1
                   , 25
                  )
               || '_NN'
               || TO_CHAR (
                     i
                   , '00'
                  )
             , l_sql_create
             , FALSE
             , TRUE
            );
         EXCEPTION
            WHEN OTHERS THEN
               dwhutl_trac.log_warn (
                  SQLERRM
                , 'Hist Natural Key: Warning'
               );

               IF p_b_raise_flag THEN
                  RAISE;
               END IF;
         END;
      END LOOP;

      /*EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_table_name_hist
         || ' TO '
         || dwhutl_stag_param.c_vc_list_grantee;*/
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'History Table: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_warn (
            l_vc_prc_name
          , l_vc_message
          , 'History Table: Warning'
         );

         IF p_b_raise_flag THEN
            RAISE;
         END IF;
   END prc_create_hist_table;

   PROCEDURE prc_create_hist_view (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_create_hist_view';
      l_vc_message    t_string
                         :=    'View Hist '
                            || g_vc_view_name_hist;
      l_sql_create    t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: Begin'
      );
      l_vc_viw_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_viewcols;
      --
      l_sql_create :=
            'CREATE OR REPLACE FORCE VIEW '
         || g_vc_view_name_hist
         || ' AS SELECT '
         || NVL (
               LTRIM (
                  l_vc_viw_anonymized
                , ','
               )
             , '*'
            )
         || ' FROM '
         || g_vc_table_name_hist;
      prc_store_ddl (
         'VIEW'
       , g_vc_view_name_hist
       , l_sql_create
      );

      EXECUTE IMMEDIATE l_sql_create;

      EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_view_name_hist
         || ' TO '
         || dwhutl_stag_param.c_vc_list_grantee;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          , 'Hist View: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         ELSE
            NULL;
         END IF;
   END;

   PROCEDURE prc_create_hist_synonym (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_create_hist_synonym';
      l_vc_message    t_string
                         :=    'Synonym Hist '
                            || g_vc_view_name_hist;
      l_sql_create    t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist Synonym: Begin'
      );
      l_vc_viw_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_viewcols;
      --
      l_sql_create :=
            'CREATE OR REPLACE SYNONYM '
         || g_vc_view_name_hist
         || ' FOR '
         || g_vc_table_name_hist;
      prc_store_ddl (
         'SYNONYM'
       , g_vc_view_name_hist
       , l_sql_create
      );

      EXECUTE IMMEDIATE l_sql_create;

      EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_view_name_hist
         || ' TO '
         || dwhutl_stag_param.c_vc_list_grantee;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist Synonym: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_warn (
            l_vc_prc_name
          , l_vc_message
          , 'Hist Synonym: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         ELSE
            NULL;
         END IF;
   END;

   PROCEDURE prc_create_fbda_view (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_create_fbda_view';
      l_vc_message    t_string
                         :=    'View Hist '
                            || g_vc_view_name_hist;
      l_sql_create    t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: Begin'
      );
      l_vc_viw_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_viewcols;
      --
      l_sql_create :=
            'CREATE OR REPLACE FORCE VIEW '
         || g_vc_view_name_fbda
         || ' AS SELECT versions_starttime
     , versions_startscn
     , versions_endtime
     , versions_endscn
     , versions_xid
     , versions_operation
     '
         || l_vc_viw_anonymized
         || ' FROM '
         || g_vc_table_name_hist
         || ' VERSIONS BETWEEN TIMESTAMP MINVALUE AND MAXVALUE';
      prc_store_ddl (
         'VIEW'
       , g_vc_view_name_fbda
       , l_sql_create
      );

      EXECUTE IMMEDIATE l_sql_create;

      EXECUTE IMMEDIATE
            'GRANT SELECT ON '
         || g_vc_view_name_fbda
         || ' TO '
         || dwhutl_stag_param.c_vc_list_grantee;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Hist View: End'
      );
   EXCEPTION
      WHEN OTHERS THEN
         dwhutl_trac.log_sub_warn (
            l_vc_prc_name
          , l_vc_message
          , 'Hist View: Error'
         );

         IF p_b_raise_flag THEN
            RAISE;
         ELSE
            NULL;
         END IF;
   END;

   PROCEDURE prc_create_prc_trunc_stage (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_trunc_stage';
      l_vc_message       t_string
                            :=    'Procedure trunc stage '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- HEAD
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_trunc_stage
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      l_sql_prc_token := dwhutl_stmt.c_token_truncate_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_stage
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         l_sql_prc_token := dwhutl_stmt.c_token_truncate_table;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_trunc_stage
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_trunc_stage;

   PROCEDURE prc_create_prc_trunc_diff (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_trunc_diff';
      l_vc_message       t_string
                            :=    'Procedure trunc diff '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- HEAD
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_trunc_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      l_sql_prc_buffer := dwhutl_stmt.c_token_truncate_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'tableName'
       , g_vc_table_name_diff
      );
      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_trunc_diff
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_trunc_diff;

   PROCEDURE prc_create_prc_init (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name         t_object_name := 'prc_create_prc_init';
      l_vc_message          t_string
                               :=    'Procedure load init '
                                  || g_vc_package_main;
      l_sql_prc             CLOB;
      l_sql_prc_token       CLOB;
      l_sql_prc_buffer      CLOB;
      -- List of columns
      l_vc_col_all          t_string;
      l_list_utl_col        t_string;
      l_list_utl_val        t_string;
      l_list_utl_col_dupl   t_string;
      l_list_utl_val_dupl   t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_vc_col_anonymized := '';
      l_vc_fct_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_columns;
      --
      -- Set utl columns strings
      l_list_utl_col_dupl :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_column_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_column_partition
               || ','
         END;
      prc_set_utl_columns (l_list_utl_col_dupl);
      l_list_utl_col :=
            c_token_utl_column_hist
         || ','
         || l_list_utl_col_dupl;
      prc_set_utl_columns (l_list_utl_col);
      --
      -- Get lists of columns
      l_vc_col_all :=
         dwhutl_dict.fct_get_column_subset (
            g_vc_dblink
          , g_vc_owner_src
          , g_vc_table_name_source
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
          , p_vc_exclude_list   => l_list_utl_col
         );
      --
      -- HEAD
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_init
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Add token to check if hist table is empty
      l_sql_prc_token :=
            dwhutl_stmt.c_token_enable_parallel_dml
         || CHR (10)
         || c_token_check_table_isempty;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_hist
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Truncate duplicates table
         l_sql_prc_token := dwhutl_stmt.c_token_truncate_table;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Fill stage hist for each source db
      FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
         l_sql_prc_token := c_token_stage_insert;
         --
         -- Values for the utility columns
         l_list_utl_val_dupl :=
            CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     ''''
                  || g_l_distr_code (i)
                  || ''', '
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     fct_get_partition_expr
                  || ','
            END;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NOT NULL THEN
            l_vc_col_pk_notnull :=
               dwhutl_stag_meta.fct_get_column_list (
                  g_n_object_id
                , 'PK'
                , 'AND_NOTNULL'
               );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_dedupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'duplIdentifier'
             , g_vc_table_name_dupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'pkColumnList'
             , g_vc_col_pk_src
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'deduplRankClause'
             , g_vc_dedupl_rank_clause
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlColumnListForDupl'
             , l_list_utl_col_dupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlValueListForDupl'
             , l_list_utl_val_dupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'notNullClause'
             , l_vc_col_pk_notnull
            );
         ELSE
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_copy
            );
         END IF;

         l_list_utl_val :=
               c_token_utl_colval_hist
            || ','
            || l_list_utl_val_dupl;
         -- There is no optional incremental retrieval (this is an init procedure)
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'computeIncrementBound'
          , NULL
         );
         --
         --
         dwhutl_stmt.prc_set_text_param (
            l_sql_prc_token
          , 'targetIdentifier'
          , g_vc_table_name_hist
         );
         dwhutl_stmt.prc_set_text_param (
            l_sql_prc_token
          , 'sourceIdentifier'
          , g_vc_source_identifier
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourceColumnList'
          , l_vc_col_all
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetColumnList'
          , l_vc_col_all
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlColumnList'
          , l_list_utl_col
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlValueList'
          , l_list_utl_val
         );
         --
         --
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'filterClause'
          , CASE
               WHEN g_vc_filter_clause IS NOT NULL THEN
                     ' WHERE '
                  || g_vc_filter_clause
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , NULL
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      l_sql_prc_token := c_token_analyze;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'HSAN'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_hist
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'partition'
       , NULL
      );
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Truncate duplicates table
         l_sql_prc_token := c_token_analyze;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'statisticsType'
          , 'DUAN'
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'stgOwner'
          , g_vc_owner_stg
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , NULL
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceCode'
       , g_vc_source_code
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'objectName'
       , g_vc_object_name
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceTable'
       , g_vc_table_name_source
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_init
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_init;

   PROCEDURE prc_create_prc_load_stage (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_load_stage';
      l_vc_message       t_string
                            :=    'Procedure load stage '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
      l_list_utl_col     t_string;
      l_list_utl_val     t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- Set utl columns strings
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_column_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_column_partition
               || ','
         END;
      prc_set_utl_columns (l_list_utl_col);
      --
      -- HEAD
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_stage
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Truncate stage table
      l_sql_prc_token :=
            dwhutl_stmt.c_token_enable_parallel_dml
         || CHR (10)
         || dwhutl_stmt.c_token_truncate_table;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_stage
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Truncate duplicates table
         l_sql_prc_token := dwhutl_stmt.c_token_truncate_table;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Fill stage table for each source db
      -- Fill stage for each source db
      FOR i IN g_l_distr_code.FIRST .. g_l_distr_code.LAST LOOP
         l_sql_prc_token := c_token_stage_insert;
         --
         -- Values for the utility columns
         l_list_utl_val :=
            CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     ''''
                  || g_l_distr_code (i)
                  || ''', '
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     fct_get_partition_expr
                  || ', '
            END;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NOT NULL THEN
            l_vc_col_pk_notnull :=
               dwhutl_stag_meta.fct_get_column_list (
                  g_n_object_id
                , 'PK'
                , 'AND_NOTNULL'
               );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_dedupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'duplIdentifier'
             , g_vc_table_name_dupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'pkColumnList'
             , g_vc_col_pk_src
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'deduplRankClause'
             , g_vc_dedupl_rank_clause
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlColumnListForDupl'
             , l_list_utl_col
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlValueListForDupl'
             , l_list_utl_val
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'notNullClause'
             , l_vc_col_pk_notnull
            );
         ELSE
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_copy
            );
         END IF;

         -- Add optional increment retrieval statement
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'computeIncrementBound'
          , CASE
               WHEN g_vc_increment_column IS NOT NULL THEN
                  c_token_stage_get_incr_bound
            END
         );
         --
         --
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'insertStatement'
          , dwhutl_stmt.c_sql_insert_copy
         );
         dwhutl_stmt.prc_set_text_param (
            l_sql_prc_token
          , 'targetIdentifier'
          , g_vc_table_name_stage
         );
         dwhutl_stmt.prc_set_text_param (
            l_sql_prc_token
          , 'sourceIdentifier'
          , g_vc_source_identifier
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourceColumnList'
          , g_vc_col_all
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetColumnList'
          , g_vc_col_all
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlColumnList'
          , l_list_utl_col
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlValueList'
          , l_list_utl_val
         );
         --
         --
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'incrementColumn'
          , g_vc_increment_column
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'histTableName'
          , g_vc_table_name_hist
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'filterClause'
          ,    CASE
                  WHEN g_vc_filter_clause IS NOT NULL THEN
                        'WHERE '
                     || g_vc_filter_clause
               END
            || CASE
                  WHEN g_vc_increment_column IS NOT NULL THEN
                        CASE
                           WHEN g_vc_filter_clause IS NULL THEN
                              ' WHERE '
                           ELSE
                              ' AND '
                        END
                     || g_vc_increment_column
                     || ' > l_t_increment_bound - '
                     || NVL (g_n_increment_buffer, 0)
               END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || '_'
                  || g_l_distr_code (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , CASE
            WHEN g_vc_increment_column IS NOT NULL THEN
                  'l_t_increment_bound '
               || g_vc_increment_coldef
               || ';'
         END
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceCode'
       , g_vc_source_code
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'objectName'
       , g_vc_object_name
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'sourceTable'
       , g_vc_table_name_source
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_stage
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_stage;

   PROCEDURE prc_create_prc_load_stage_p (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_load_stage_p';
      l_vc_message       t_string
                            :=    'Procedure load stage partition '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
      l_n_iter_begin     NUMBER;
      l_n_iter_end       NUMBER;
      l_list_utl_col     t_string;
      l_list_utl_val     t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- Set utl columns strings
      l_list_utl_col :=
         CASE
            WHEN g_l_distr_code.COUNT > 1 THEN
                  c_token_utl_column_source_db
               || ','
            WHEN g_vc_partition_expr IS NOT NULL THEN
                  c_token_utl_column_partition
               || ','
         END;
      prc_set_utl_columns (l_list_utl_col);

      --
      -- HEAD
      --
      IF g_l_distr_code.COUNT > 1 THEN
         FOR i IN g_l_dblink.FIRST .. g_l_dblink.LAST LOOP
            -- Stage1 procedure head
            l_sql_prc := dwhutl_ddls.c_template_prc_head;
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc
             , 'prcName'
             ,    dwhutl_stag_param.c_vc_procedure_load_stage_p
               || '_'
               || g_l_distr_code (i)
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc
             , 'prcParameters'
             , c_token_prc_param
            );
            l_buffer_pkg_head :=
                  l_buffer_pkg_head
               || CHR (10)
               || l_sql_prc;
         END LOOP;
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         FOR i IN 0 .. 9 LOOP
            -- Stage1 procedure head
            l_sql_prc := dwhutl_ddls.c_template_prc_head;
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc
             , 'prcName'
             ,    dwhutl_stag_param.c_vc_procedure_load_stage_p
               || '_p'
               || i
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc
             , 'prcParameters'
             , c_token_prc_param
            );
            l_buffer_pkg_head :=
                  l_buffer_pkg_head
               || CHR (10)
               || l_sql_prc;
         END LOOP;
      END IF;

      --
      -- BODY
      --
      IF g_l_distr_code.COUNT > 1 THEN
         l_n_iter_begin := g_l_dblink.FIRST;
         l_n_iter_end := g_l_dblink.LAST;
      ELSIF g_vc_partition_expr IS NOT NULL THEN
         l_n_iter_begin := 0;
         l_n_iter_end := 9;
      END IF;

      FOR i IN l_n_iter_begin .. l_n_iter_end LOOP
         l_sql_prc_token := dwhutl_stmt.c_token_truncate_partition;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_stage
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || '_'
                  || g_l_distr_code (i)
                  || ')'
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         -- Fill stage table for each source db
         l_sql_prc_token :=
               l_sql_prc_token
            || CHR (10)
            || c_token_stage_insert;
         --
         -- Values for the utility columns
         l_list_utl_val :=
            CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     ''''
                  || g_l_distr_code (i)
                  || ''', '
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     fct_get_partition_expr
                  || ', '
            END;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NOT NULL THEN
            l_vc_col_pk_notnull :=
               dwhutl_stag_meta.fct_get_column_list (
                  g_n_object_id
                , 'PK'
                , 'AND_NOTNULL'
               );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_dedupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'duplIdentifier'
             , g_vc_table_name_dupl
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'pkColumnList'
             , g_vc_col_pk_src
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'deduplRankClause'
             , g_vc_dedupl_rank_clause
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlColumnListForDupl'
             , l_list_utl_col
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'utlValueListForDupl'
             , l_list_utl_val
            );
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'notNullClause'
             , l_vc_col_pk_notnull
            );
         ELSE
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_copy
            );
         END IF;

         -- Add optional increment retrieval statement
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'computeIncrementBound'
          , CASE
               WHEN g_vc_increment_column IS NOT NULL THEN
                  c_token_stage_get_incr_bound
            END
         );
         --
         --
         g_vc_source_identifier :=
            CASE
               WHEN g_l_dblink.COUNT = 1 THEN
                  CASE
                     WHEN g_l_dblink (1) IS NULL
                      AND g_l_owner_src (1) = g_vc_owner_stg THEN
                        g_vc_table_name_source
                     ELSE
                           CASE
                              WHEN g_l_owner_src (1) IS NOT NULL THEN
                                    g_l_owner_src (1)
                                 || '.'
                           END
                        || g_vc_table_name_source
                        || CASE
                              WHEN g_l_dblink (1) IS NOT NULL THEN
                                    '@'
                                 || g_l_dblink (1)
                           END
                  END
               ELSE
                  CASE
                     WHEN g_l_dblink (i) IS NULL
                      AND g_l_owner_src (i) = g_vc_owner_stg THEN
                        g_vc_table_name_source
                     ELSE
                        CASE
                           WHEN g_l_owner_src (i) IS NOT NULL THEN
                                 g_l_owner_src (i)
                              || '.'
                              || g_vc_table_name_source
                              || CASE
                                    WHEN g_l_dblink (i) IS NOT NULL THEN
                                          '@'
                                       || g_l_dblink (i)
                                 END
                        END
                  END
            END;
         --
         --
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'insertStatement'
          , dwhutl_stmt.c_sql_insert_copy
         );
         dwhutl_stmt.prc_set_text_param (
            l_sql_prc_token
          , 'targetIdentifier'
          , g_vc_table_name_stage
         );
         dwhutl_stmt.prc_set_text_param (
            l_sql_prc_token
          , 'sourceIdentifier'
          , g_vc_source_identifier
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourceColumnList'
          , g_vc_col_all
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetColumnList'
          , g_vc_col_all
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlColumnList'
          , l_list_utl_col
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'utlValueList'
          , l_list_utl_val
         );
         --
         --
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'incrementColumn'
          , g_vc_increment_column
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'filterClause'
          ,    CASE
                  WHEN g_vc_partition_expr IS NOT NULL THEN
                        ' WHERE '
                     || fct_get_partition_expr
                     || ' = '
                     || i
               END
            || CASE
                  WHEN g_vc_filter_clause IS NOT NULL THEN
                        CASE
                           WHEN g_vc_partition_expr IS NULL THEN
                              ' WHERE '
                           ELSE
                              ' AND '
                        END
                     || g_vc_filter_clause
               END
            || CASE
                  WHEN g_vc_increment_column IS NOT NULL THEN
                        CASE
                           WHEN g_vc_partition_expr IS NULL
                            AND g_vc_filter_clause IS NULL THEN
                              ' WHERE '
                           ELSE
                              ' AND '
                        END
                     || g_vc_increment_column
                     || ' > l_t_increment_bound'
               END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , CASE
               WHEN g_l_distr_code.COUNT > 1 THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || '_'
                  || g_l_distr_code (i)
                  || ')'
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_l_distr_code.COUNT > 1
                 OR g_vc_partition_expr IS NOT NULL THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         -- Put body in the generic prc template
         l_sql_prc := dwhutl_ddls.c_template_prc_body;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'prcParameters'
          , c_token_prc_param
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'varList'
          , CASE
               WHEN g_vc_increment_column IS NOT NULL THEN
                     'l_t_increment_bound '
                  || g_vc_increment_coldef
                  || ';'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'prcInitialize'
          , c_token_prc_initialize
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'prcFinalize'
          , c_token_prc_finalize
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'exceptionHandling'
          , c_token_prc_exception
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'prcBody'
          , l_sql_prc_token
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'sourceCode'
          , g_vc_source_code
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'objectName'
          , g_vc_object_name
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'sourceTable'
          , g_vc_table_name_source
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc
          , 'prcName'
          ,    dwhutl_stag_param.c_vc_procedure_load_stage_p
            || '_'
            || CASE
                  WHEN g_l_distr_code.COUNT > 1 THEN
                     g_l_distr_code (i)
                  ELSE
                        'p'
                     || i
               END
         );
         l_buffer_pkg_body :=
               l_buffer_pkg_body
            || CHR (10)
            || l_sql_prc;
      END LOOP;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_stage_p;

   PROCEDURE prc_create_prc_load_diff (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name         t_object_name := 'prc_create_prc_load_diff';
      l_vc_message          t_string
                               :=    'Procedure load diff '
                                  || g_vc_package_main;
      l_sql_prc             CLOB;
      l_sql_prc_token       CLOB;
      l_sql_prc_buffer      CLOB;
      --
      l_n_iter_begin        NUMBER;
      l_n_iter_end          NUMBER;
      -- List of columns
      l_vc_col_list         t_string;
      l_vc_col_pk_hist      t_string;
      l_vc_clause_on        t_string;
      l_vc_upd_clause_set   t_string;
      l_vc_clause_history   t_string;
      l_vc_clause_update    t_string;
      l_vc_col_nvl2         t_string;
      -- Utl columns
      l_list_utl_col        t_string;
      l_list_utl_val        t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- Set utl columns strings
      l_list_utl_col := c_token_utl_column_hist;
      -- Get list of pk columns of the History Table
      dwhutl_trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Get list of pk columns of the History Table'
      );
      l_vc_col_pk_hist :=
         dwhutl_dict.fct_get_column_list (
            NULL
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'PK'
          , 'LIST_SIMPLE'
          , p_vc_exclude_list   => dwhutl_stag_param.c_vc_column_valid_to
         );
      dwhutl_trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Got columns'
      );
      --
      -- HEAD
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      -- Hist incremental procedure head
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_diff_incr
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Get list of all columns
      dwhutl_trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Get list of all columns in common within stage and hist tables'
      );
      l_vc_col_list :=
         dwhutl_dict.fct_get_column_subset (
            NULL
          , g_vc_owner_stg
          , g_vc_table_name_stage
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
         );
      dwhutl_trac.log_sub_trace (
         l_vc_prc_name
       , l_vc_message
       , 'Got columns'
      );                                                                                                                                                                   -- In case the pk of stage 1 and History Tables is not the same, write a warning log

      IF g_vc_col_pk = l_vc_col_pk_hist
      OR (g_vc_col_pk IS NULL
      AND l_vc_col_pk_hist IS NULL) THEN
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          ,    'Source '
            || g_vc_source_code
            || ', Object '
            || g_vc_table_name_source
            || ' : Stage and hist table have the same Natural Keys'
         );
      ELSE
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , l_vc_message
          ,    'Source '
            || g_vc_source_code
            || ', Object '
            || g_vc_table_name_source
            || ' : Stage and hist table have different Natural Keys'
         );
      END IF;

      -- analyze stage table
      l_sql_prc_token := c_token_analyze;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'STAN'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_stage
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'partition'
       , NULL
      );
      l_sql_prc_buffer := l_sql_prc_token;

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NOT NULL THEN
         -- Analyse duplicates table
         l_sql_prc_token := c_token_analyze;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'statisticsType'
          , 'DUAN'
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'stgOwner'
          , g_vc_owner_stg
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'tableName'
          , g_vc_table_name_dupl
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partition'
          , NULL
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END IF;

      -- Check hist/stage nk differences and truncate diff table
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || c_token_diff_check;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'stgOwner'
       , g_vc_owner_stg
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'stageTableName'
       , g_vc_table_name_stage
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffTableName'
       , g_vc_table_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'histTableName'
       , g_vc_table_name_hist
      );

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NULL THEN
         -- If there is no natural key (tecnical PK) then use the alternate difference method
         l_vc_clause_on :=
            dwhutl_dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_ALL'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
            );
      ELSE
         -- If there is a natural key (tecnical PK) and the full outer join method is specified,
         -- then use the merge template
         -- Get list of conditions for the on clause of the merge
         l_vc_clause_on :=
            dwhutl_dict.fct_get_column_list (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'PK'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => dwhutl_stag_param.c_vc_column_valid_to
            );
         l_vc_col_nvl2 :=
            dwhutl_dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_ALL'
             , 'LIST_NVL2'
             , 'src'
             , 'trg'
            );
         l_vc_clause_history :=
            dwhutl_dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_NPK'
             , 'OR_DECODE'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => g_vc_col_update
            );
         l_vc_clause_update :=
            dwhutl_dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_NPK'
             , 'OR_DECODE'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => g_vc_col_hist
            );
      END IF;

      l_n_iter_begin := 0;

      IF g_vc_partition_expr IS NOT NULL THEN
         l_n_iter_end := 9;
      ELSE
         l_n_iter_end := 0;
      END IF;

      l_sql_prc_token := '';

      FOR i IN l_n_iter_begin .. l_n_iter_end LOOP
         l_sql_prc_token := c_token_diff_insert;

         IF g_n_source_nk_flag = 0
        AND g_vc_col_pk_src IS NULL THEN
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_diff_without_nk
            );
         ELSE
            dwhutl_ddls.prc_set_text_param (
               l_sql_prc_token
             , 'insertStatement'
             , dwhutl_stmt.c_sql_insert_diff_with_nk
            );
         END IF;

         dwhutl_dict.prc_set_text_param (
            l_sql_prc_token
          , 'enableParallelDML'
          , CASE
               WHEN l_vc_set_anonymized IS NOT NULL THEN
                  dwhutl_stmt.c_token_enable_parallel_dml
               ELSE
                  dwhutl_stmt.c_token_disable_parallel_dml
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'diffPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'sourcePartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      -- Set object identifiers
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffIdentifier'
       , g_vc_table_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceIdentifier'
       , g_vc_table_name_stage
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetIdentifier'
       , g_vc_table_name_hist
      );
      -- Set list of columns
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'nvl2ColumnList'
       , l_vc_col_nvl2
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetColumnList'
       , l_vc_col_list
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'utlColumnList'
       , l_list_utl_col
      );
      -- Set clauses
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'historyClause'
       , NVL (l_vc_clause_history, '1=0')
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'updateClause'
       , NVL (l_vc_clause_update, '1=0')
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'joinClause'
       , l_vc_clause_on
      );
      prc_set_utl_columns (l_sql_prc_buffer);
      -- Ad analyze token
      l_sql_prc_token := c_token_analyze;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'DFAN'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'partition'
       , NULL
      );
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || l_sql_prc_token;
      -- Put all other code parameters
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceCode'
       , g_vc_source_code
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'objectName'
       , g_vc_object_name
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceTable'
       , g_vc_table_name_source
      );
      --
      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'joinType'
       , 'FULL'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_diff
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      --
      -- Load Hist without deletes
      --
      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'joinType'
       , 'LEFT'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_diff_incr
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_diff;

   PROCEDURE prc_create_prc_load_hist (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name         t_object_name := 'prc_create_prc_load_hist';
      l_vc_message          t_string
                               :=    'Procedure load hist '
                                  || g_vc_package_main;
      l_sql_prc             CLOB;
      l_sql_prc_token       CLOB;
      l_sql_prc_buffer      CLOB;
      --
      l_n_iter_begin        NUMBER;
      l_n_iter_end          NUMBER;
      -- List of columns
      l_vc_col_simple       t_string;
      l_vc_clause_on        t_string;
      l_vc_upd_clause_set   t_string;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      -- Set anonymizad column lists
      l_vc_set_anonymized := '';
      l_vc_col_anonymized := '';
      l_vc_fct_anonymized := '';
      l_vc_ins_anonymized := '';
      -- ANONYMIZATION prc_set_anonymized_columns;
      --
      -- HEAD
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_hist
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY
      --
      -- Get list of all columns
      l_vc_col_simple :=
         dwhutl_dict.fct_get_column_subset (
            NULL
          , g_vc_owner_stg
          , g_vc_table_name_stage
          , g_vc_owner_stg
          , g_vc_table_name_hist
          , 'COMMON_ALL'
          , 'LIST_SIMPLE'
         );

      IF g_n_source_nk_flag = 0
     AND g_vc_col_pk_src IS NULL THEN
         -- If there is no natural key (tecnical PK) then use the alternate difference method
         l_vc_clause_on :=
            dwhutl_dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_ALL'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
            );
      ELSE
         -- If there is a natural key (tecnical PK) and the full outer join method is specified,
         -- then use the merge template
         -- Get list of conditions for the on clause of the merge
         l_vc_clause_on :=
            dwhutl_dict.fct_get_column_list (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'PK'
             , 'AND_ALIAS'
             , 'trg'
             , 'src'
             , p_vc_exclude_list   => dwhutl_stag_param.c_vc_column_valid_to
            );
         l_vc_upd_clause_set :=
            dwhutl_dict.fct_get_column_subset (
               NULL
             , g_vc_owner_stg
             , g_vc_table_name_stage
             , g_vc_owner_stg
             , g_vc_table_name_hist
             , 'COMMON_NPK'
             , 'SET_ALIAS'
             , 'trg'
             , 'src'
            );
      END IF;

      l_n_iter_begin := 0;

      IF g_vc_partition_expr IS NOT NULL THEN
         l_n_iter_end := 9;
      ELSE
         l_n_iter_end := 0;
      END IF;

      l_sql_prc_token := '';

      FOR i IN l_n_iter_begin .. l_n_iter_end LOOP
         l_sql_prc_token := c_token_hist_reconcile;
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'closeStatement'
          , dwhutl_stmt.c_sql_reconcile_close
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'updateStatement'
          , dwhutl_stmt.c_sql_reconcile_update
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'insertStatement'
          , dwhutl_stmt.c_sql_reconcile_insert
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'enableParallelDML'
          , CASE
               WHEN l_vc_set_anonymized IS NOT NULL THEN
                  dwhutl_stmt.c_token_enable_parallel_dml
               ELSE
                  dwhutl_stmt.c_token_disable_parallel_dml
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'diffPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'diffPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'targetPartition'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                     'PARTITION ('
                  || dwhutl_stag_param.c_vc_prefix_partition
                  || TO_CHAR (i)
                  || ')'
            END
         );
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_token
          , 'partitionId'
          , CASE
               WHEN g_vc_partition_expr IS NOT NULL THEN
                  TRIM (TO_CHAR (i))
               ELSE
                  'NULL'
            END
         );
         l_sql_prc_buffer :=
               l_sql_prc_buffer
            || CHR (10)
            || l_sql_prc_token;
      END LOOP;

      -- Set object identifiers
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffIdentifier'
       , g_vc_table_name_diff
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetIdentifier'
       , g_vc_table_name_hist
      );
      -- Set list of columns
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'diffColumnList'
       ,    l_vc_col_simple
         || CHR (10)
         || l_vc_ins_anonymized
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'targetColumnList'
       ,    l_vc_col_simple
         || CHR (10)
         || l_vc_col_anonymized
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'utlColumnList'
       , c_token_utl_column_hist
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'utlValueList'
       , c_token_utl_colval_hist
      );
      -- Set clauses
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'joinClause'
       , l_vc_clause_on
      );
      -- Set the matched clause of the merge statement. This exists only if there are non-NK columns to set
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'matchedClause'
       , CASE
            WHEN l_vc_upd_clause_set IS NOT NULL THEN
                  l_vc_upd_clause_set
               || CHR (10)
               || l_vc_set_anonymized
               || ', '
         END
      );
      prc_set_utl_columns (l_sql_prc_buffer);
      -- Analyze token
      l_sql_prc_token := c_token_analyze;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'statisticsType'
       , 'HSAN'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'stgOwner'
       , g_vc_owner_stg
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_token
       , 'tableName'
       , g_vc_table_name_hist
      );
      l_sql_prc_buffer :=
            l_sql_prc_buffer
         || CHR (10)
         || l_sql_prc_token;                                                                                                                                                                                                   -- Put all other code parameters
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'sourceCode'
       , g_vc_source_code
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'objectName'
       , g_vc_object_name
      );
      --
      -- Load Hist with table comparison
      --
      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , c_token_prc_initialize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , c_token_prc_finalize
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , c_token_prc_exception
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_load_hist
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_load_hist;

   PROCEDURE prc_create_prc_wrapper (
      p_b_tc_only_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name      t_object_name := 'prc_create_prc_wrapper';
      l_vc_message       t_string
                            :=    'Procedure wrapper '
                               || g_vc_package_main;
      l_sql_prc          CLOB;
      l_sql_prc_token    CLOB;
      l_sql_prc_buffer   CLOB;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      --
      -- HEAD for FULL load
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_wrapper
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY for FULL load
      --
      l_sql_prc_buffer := c_token_prc_wrapper;

      IF p_b_tc_only_flag THEN
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          , NULL
         );
      ELSE
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          ,    dwhutl_stag_param.c_vc_procedure_load_stage
            || ';'
         );
      END IF;

      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadDiff'
       ,    dwhutl_stag_param.c_vc_procedure_load_diff
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadHist'
       ,    dwhutl_stag_param.c_vc_procedure_load_hist
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncStage'
       ,    dwhutl_stag_param.c_vc_procedure_trunc_stage
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncDiff'
       ,    dwhutl_stag_param.c_vc_procedure_trunc_diff
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'tableName'
       , g_vc_table_name_hist
      );
      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_wrapper
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      --
      -- HEAD for INCREMENTAL load
      --
      l_sql_prc := dwhutl_ddls.c_template_prc_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_wrapper_incr
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      l_buffer_pkg_head :=
            l_buffer_pkg_head
         || CHR (10)
         || l_sql_prc;
      --
      -- BODY for DELTA load
      --
      l_sql_prc_buffer := c_token_prc_wrapper;

      IF p_b_tc_only_flag THEN
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          , NULL
         );
      ELSE
         dwhutl_ddls.prc_set_text_param (
            l_sql_prc_buffer
          , 'prcLoadStage'
          ,    dwhutl_stag_param.c_vc_procedure_load_stage
            || ';'
         );
      END IF;

      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadDiff'
       ,    dwhutl_stag_param.c_vc_procedure_load_diff
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcLoadHist'
       ,    dwhutl_stag_param.c_vc_procedure_load_diff_incr
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncStage'
       ,    dwhutl_stag_param.c_vc_procedure_trunc_stage
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'prcTruncDiff'
       ,    dwhutl_stag_param.c_vc_procedure_trunc_diff
         || ';'
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc_buffer
       , 'tableName'
       , g_vc_table_name_hist
      );
      -- Put body in the generic prc template
      l_sql_prc := dwhutl_ddls.c_template_prc_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcParameters'
       , c_token_prc_param
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'varList'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcInitialize'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcFinalize'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'exceptionHandling'
       , NULL
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcBody'
       , l_sql_prc_buffer
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_prc
       , 'prcName'
       , dwhutl_stag_param.c_vc_procedure_wrapper_incr
      );
      l_buffer_pkg_body :=
            l_buffer_pkg_body
         || CHR (10)
         || l_sql_prc;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_prc_wrapper;

   PROCEDURE prc_compile_package_main (p_b_raise_flag BOOLEAN DEFAULT FALSE)
   IS
      l_vc_prc_name   t_object_name := 'prc_compile_package_main';
      l_vc_message    t_string
                         :=    'Package compile '
                            || g_vc_package_main;
      l_sql_create    CLOB;
   BEGIN
      -- Package head
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package head: Begin'
      );
      l_sql_create := dwhutl_ddls.c_template_pkg_head;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'pkgName'
       , g_vc_package_main
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'varList'
       , ''
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'prcList'
       , l_buffer_pkg_head
      );
      -- Execute ddl for package head
      prc_store_ddl (
         'PACKAGE'
       , g_vc_package_main
       , l_sql_create
      );
      dwhutl_ddls.prc_create_object (
         'PACKAGE'
       , g_vc_package_main
       , l_sql_create
       , FALSE
       , p_b_raise_flag
      );
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package head: End'
      );
      -- Package body
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package body: Begin'
      );
      l_sql_create := dwhutl_ddls.c_template_pkg_body;
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'varList'
       , ''
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'prcList'
       , l_buffer_pkg_body
      );
      dwhutl_ddls.prc_set_text_param (
         l_sql_create
       , 'pkgName'
       , g_vc_package_main
      );
      -- Execute ddl for package body
      prc_store_ddl (
         'PACKAGE BODY'
       , g_vc_package_main
       , l_sql_create
      );
      dwhutl_ddls.prc_create_object (
         'PACKAGE BODY'
       , g_vc_package_main
       , l_sql_create
       , FALSE
       , p_b_raise_flag
      );
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Package body: End'
      );
   END prc_compile_package_main;

   PROCEDURE prc_create_package_main (
      p_b_hist_only_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag        BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name   t_object_name := 'prc_create_package_main';
      l_vc_message    t_string
                         :=    'Package create '
                            || g_vc_package_main;
      l_sql_create    CLOB;
   BEGIN
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'Begin'
      );
      l_buffer_pkg_head := '';
      l_buffer_pkg_body := '';

      IF NOT p_b_hist_only_flag THEN
         -- Get list of columns for the stage 1 and init procedures
         l_vc_col_src :=
            dwhutl_dict.fct_get_column_list (
               g_vc_dblink
             , g_vc_owner_src
             , g_vc_table_name_source
             , 'ALL'
             , 'LIST_SIMPLE'
            );
         l_vc_col_dupl :=
            dwhutl_dict.fct_get_column_subset (
               g_vc_dblink
             , g_vc_owner_src
             , g_vc_table_name_source
             , g_vc_owner_stg
             , g_vc_table_name_dupl
             , 'COMMON_ALL'
             , 'LIST_SIMPLE'
            );
      END IF;

      --
      -- Fill buffers with single procedures
      --
      -- Trunc Stage Table
      prc_create_prc_trunc_stage (p_b_raise_flag);
      --
      -- Trunc Diff table
      prc_create_prc_trunc_diff (p_b_raise_flag);

      IF NOT p_b_hist_only_flag THEN
         --
         -- Initial load
         prc_create_prc_init (p_b_raise_flag);
         --
         -- Stage 1 load
         prc_create_prc_load_stage (p_b_raise_flag);

         IF g_l_dblink.COUNT > 1
         OR g_vc_partition_expr IS NOT NULL THEN
            --
            -- Stage 1 load - single partitions
            prc_create_prc_load_stage_p (p_b_raise_flag);
         END IF;
      END IF;

      --
      -- Hist load
      prc_create_prc_load_diff (p_b_raise_flag);
      prc_create_prc_load_hist (p_b_raise_flag);
      --
      -- Wrapper
      prc_create_prc_wrapper (
         p_b_hist_only_flag
       , p_b_raise_flag
      );
      --
      -- Compile package
      prc_compile_package_main (p_b_raise_flag);
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , l_vc_message
       , 'End'
      );
   END prc_create_package_main;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_stag_ddl;
2014-11-28 13:53:25.785 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ddl/stag_ddl-impl.sql executed
2014-11-28 13:53:25.785 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_build/stag_build-def.sql delimiter 
2014-11-28 13:53:25.786 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stag_build
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
    * Build stage target objects
    */
   PROCEDURE prc_build_all (
      p_vc_source_code     VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name     VARCHAR2 DEFAULT 'ALL'
    , p_b_index_flag    BOOLEAN DEFAULT FALSE
    , p_b_drop_stage_flag    BOOLEAN DEFAULT TRUE
    , p_b_drop_hist_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   );

   /**
    * Build hist target objects
    */
   PROCEDURE prc_build_hist (
      p_vc_source_code     VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name     VARCHAR2 DEFAULT 'ALL'
    , p_b_drop_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   );

   /**
    * Upgrade hist table
    */
   PROCEDURE prc_upgrade_hist (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
   );
END p#frm#stag_build;
2014-11-28 13:53:25.786 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stag_build
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
    * Build stage target objects
    */
   PROCEDURE prc_build_all (
      p_vc_source_code     VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name     VARCHAR2 DEFAULT 'ALL'
    , p_b_index_flag    BOOLEAN DEFAULT FALSE
    , p_b_drop_stage_flag    BOOLEAN DEFAULT TRUE
    , p_b_drop_hist_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   );

   /**
    * Build hist target objects
    */
   PROCEDURE prc_build_hist (
      p_vc_source_code     VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name     VARCHAR2 DEFAULT 'ALL'
    , p_b_drop_flag    BOOLEAN DEFAULT FALSE
    , p_b_raise_flag       BOOLEAN DEFAULT FALSE
   );

   /**
    * Upgrade hist table
    */
   PROCEDURE prc_upgrade_hist (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
   );
END dwhutl_stag_build;
2014-11-28 13:53:25.821 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_build/stag_build-def.sql executed
2014-11-28 13:53:25.821 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_build/stag_build-impl.sql delimiter 
2014-11-28 13:53:25.823 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#stag_build
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   PROCEDURE prc_build_all (
      p_vc_source_code       VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name       VARCHAR2 DEFAULT 'ALL'
    , p_b_index_flag         BOOLEAN DEFAULT FALSE
    , p_b_drop_stage_flag    BOOLEAN DEFAULT TRUE
    , p_b_drop_hist_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag         BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name           t_object_name := 'prc_build_all';
      l_vc_stage_db_list      t_string;
      l_vc_stage_owner_list   t_string;
      l_vc_distr_code_list    t_string;
      l_vc_col_def            t_string;
      l_vc_col_all            t_string;
      l_vc_col_pk             t_string;
      l_vc_col_comm           t_string;
      --
      l_vc_col_hst            t_string;
      l_vc_col_upd            t_string;
   BEGIN
      --p#frm#trac.set_console_logging (FALSE);
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Start'
       , 'Build all db objects needed for a stage data flow'
      );
      p#frm#stag_meta.prc_set_object_properties;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Object properties'
       , 'Set names of db objects to be built'
      );
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Start building db objects'
      );

      -- Select all objects
      FOR r_obj IN (  SELECT s.stag_source_id
                           , s.stag_source_code
                           , s.stag_source_prefix
                           , d.stag_source_db_link
                           , d.stag_source_owner
                           , s.stag_owner
                           , s.stag_ts_stage_data
                           , s.stag_ts_stage_indx
                           , s.stag_ts_hist_data
                           , s.stag_ts_hist_indx
                           , s.stag_fb_archive
                           , o.stag_object_id
                           , o.stag_parallel_degree
                           , o.stag_source_nk_flag
                           , o.stag_object_name
                           , o.stag_object_comment
                           , o.stag_object_root
                           , o.stag_src_table_name
                           , o.stag_dupl_table_name
                           , o.stag_diff_table_name
                           , o.stag_diff_nk_name
                           , o.stag_stage_table_name
                           , o.stag_hist_table_name
                           , o.stag_hist_nk_name
                           , o.stag_hist_view_name
                           , o.stag_hist_fbda_name
                           , o.stag_package_name
                           , o.stag_filter_clause
                           , o.stag_partition_clause
                           , o.stag_hist_flag
                           , o.stag_fbda_flag
                           , o.stag_increment_buffer
                           , c.stag_increment_column
                           , c.stag_increment_coldef
                        FROM p#frm#stag_source_t s
                           , (SELECT stag_source_id
                                   , stag_source_db_link
                                   , stag_source_owner
                                FROM (SELECT stag_source_id
                                           , stag_source_db_link
                                           , stag_source_owner
                                           , ROW_NUMBER () OVER (PARTITION BY stag_source_id ORDER BY stag_source_db_id) AS source_db_order
                                        FROM p#frm#stag_source_db_t)
                               WHERE source_db_order = 1) d
                           , p#frm#stag_object_t o
                           , (SELECT stag_object_id
                                   , stag_column_name AS stag_increment_column
                                   , stag_column_def AS stag_increment_coldef
                                FROM (SELECT stag_object_id
                                           , stag_column_name
                                           , stag_column_def
                                           , ROW_NUMBER () OVER (PARTITION BY stag_object_id ORDER BY stag_column_pos) AS column_order
                                        FROM p#frm#stag_column_t
                                       WHERE stag_column_incr_flag > 0
                                         AND (stag_column_def LIKE 'DATE%'
                                           OR stag_column_def LIKE 'NUMBER%'))
                               WHERE column_order = 1) c
                       WHERE s.stag_source_id = d.stag_source_id
                         AND s.stag_source_id = o.stag_source_id
                         AND o.stag_object_id = c.stag_object_id(+)
                         AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                         AND p_vc_object_name IN (o.stag_object_name, 'ALL')
                    ORDER BY stag_object_id) LOOP
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Start building objects'
         );
         -- Reset list strings
         l_vc_stage_db_list := '';
         l_vc_stage_owner_list := '';
         l_vc_distr_code_list := '';
         l_vc_col_def := '';
         l_vc_col_all := '';
         l_vc_col_pk := '';
         l_vc_col_hst := '';
         l_vc_col_upd := '';

         -- Build list of values for objects with multiple sources
         FOR r_db IN (SELECT stag_source_db_link
                           , stag_source_owner
                           , stag_distribution_code
                        FROM p#frm#stag_source_db_t
                       WHERE stag_source_id = r_obj.stag_source_id) LOOP
            l_vc_stage_db_list :=
                  l_vc_stage_db_list
               || r_db.stag_source_db_link
               || ',';
            l_vc_stage_owner_list :=
                  l_vc_stage_owner_list
               || r_db.stag_source_owner
               || ',';
            l_vc_distr_code_list :=
                  l_vc_distr_code_list
               || r_db.stag_distribution_code
               || ',';
         END LOOP;

         l_vc_stage_db_list :=
            RTRIM (
               l_vc_stage_db_list
             , ','
            );
         l_vc_stage_owner_list :=
            RTRIM (
               l_vc_stage_owner_list
             , ','
            );
         l_vc_distr_code_list :=
            RTRIM (
               l_vc_distr_code_list
             , ','
            );

         -- Build list of columns
         FOR r_col IN (  SELECT NVL (stag_column_name_map, stag_column_name) AS stag_column_name
                              , stag_column_def
                              , stag_column_nk_pos
                              , stag_column_hist_flag
                           FROM p#frm#stag_column_t
                          WHERE stag_object_id = r_obj.stag_object_id
                            AND stag_column_edwh_flag = 1
                       ORDER BY stag_column_pos) LOOP
            l_vc_col_def :=
                  l_vc_col_def
               || CHR (10)
               || r_col.stag_column_name
               || ' '
               || r_col.stag_column_def
               || ',';
            l_vc_col_all :=
                  l_vc_col_all
               || CHR (10)
               || r_col.stag_column_name
               || ',';

            IF r_col.stag_column_nk_pos >= 0 THEN
               l_vc_col_pk :=
                     l_vc_col_pk
                  || CHR (10)
                  || r_col.stag_column_name
                  || ',';
            END IF;

            IF r_col.stag_column_hist_flag = 1
           AND r_obj.stag_hist_flag = 1 THEN
               l_vc_col_hst :=
                     l_vc_col_hst
                  || r_col.stag_column_name
                  || ',';
            ELSE
               l_vc_col_upd :=
                     l_vc_col_upd
                  || r_col.stag_column_name
                  || ',';
            END IF;
         END LOOP;

         l_vc_col_def :=
            RTRIM (
               l_vc_col_def
             , ','
            );
         l_vc_col_all :=
            RTRIM (
               l_vc_col_all
             , ','
            );
         l_vc_col_pk :=
            RTRIM (
               l_vc_col_pk
             , ','
            );
         l_vc_col_hst :=
            RTRIM (
               l_vc_col_hst
             , ','
            );
         l_vc_col_upd :=
            RTRIM (
               l_vc_col_upd
             , ','
            );
         --
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , 'List of column definitions'
          , l_vc_col_def
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , 'List of columns'
          , l_vc_col_all
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , 'List of pk columns'
          , l_vc_col_pk
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , 'List of columns to historicize'
          , l_vc_col_hst
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          , 'List of columns to update'
          , l_vc_col_upd
         );
         -- Set main properties for the given object
         p#frm#stag_ddl.g_n_object_id := r_obj.stag_object_id;
         p#frm#stag_ddl.g_n_parallel_degree := r_obj.stag_parallel_degree;
         p#frm#stag_ddl.g_n_source_nk_flag := r_obj.stag_source_nk_flag;
         p#frm#stag_ddl.g_n_fbda_flag := r_obj.stag_fbda_flag;
         p#frm#stag_ddl.g_vc_object_name := r_obj.stag_object_name;
         p#frm#stag_ddl.g_vc_table_comment := r_obj.stag_object_comment;
         p#frm#stag_ddl.g_vc_source_code := r_obj.stag_source_code;
         p#frm#stag_ddl.g_vc_prefix_src := r_obj.stag_source_prefix;
         p#frm#stag_ddl.g_vc_dblink := r_obj.stag_source_db_link;
         p#frm#stag_ddl.g_vc_owner_src := r_obj.stag_source_owner;
         p#frm#stag_ddl.g_vc_owner_stg := USER;
         p#frm#stag_ddl.g_vc_table_name_source :=
            CASE
               WHEN r_obj.stag_source_db_link IS NULL
                AND r_obj.stag_source_owner = r_obj.stag_owner THEN
                  r_obj.stag_src_table_name
               ELSE
                  r_obj.stag_object_name
            END;
         p#frm#stag_ddl.g_vc_source_identifier :=
            CASE
               WHEN r_obj.stag_source_db_link IS NULL
                AND r_obj.stag_source_owner = r_obj.stag_owner THEN
                  r_obj.stag_src_table_name
               ELSE
                     CASE
                        WHEN r_obj.stag_source_owner IS NOT NULL THEN
                              r_obj.stag_source_owner
                           || '.'
                     END
                  || r_obj.stag_object_name
                  || CASE
                        WHEN r_obj.stag_source_db_link IS NOT NULL THEN
                              '@'
                           || r_obj.stag_source_db_link
                     END
            END;
         --
         p#frm#stag_ddl.g_vc_dedupl_rank_clause :=
            CASE
               WHEN r_obj.stag_source_db_link IS NULL
                AND r_obj.stag_source_owner = r_obj.stag_owner THEN
                  'ORDER BY 1'
               ELSE
                  'ORDER BY rowid DESC'
            END;
         p#frm#stag_ddl.g_vc_filter_clause := r_obj.stag_filter_clause;
         p#frm#stag_ddl.g_vc_partition_expr := r_obj.stag_partition_clause;
         p#frm#stag_ddl.g_vc_increment_column := r_obj.stag_increment_column;
         p#frm#stag_ddl.g_vc_increment_coldef := r_obj.stag_increment_coldef;
         p#frm#stag_ddl.g_n_increment_buffer := r_obj.stag_increment_buffer;
         p#frm#stag_ddl.g_vc_table_name_dupl := r_obj.stag_dupl_table_name;
         p#frm#stag_ddl.g_vc_table_name_diff := r_obj.stag_diff_table_name;
         p#frm#stag_ddl.g_vc_table_name_stage := r_obj.stag_stage_table_name;
         p#frm#stag_ddl.g_vc_table_name_hist := r_obj.stag_hist_table_name;
         p#frm#stag_ddl.g_vc_nk_name_diff := r_obj.stag_diff_nk_name;
         p#frm#stag_ddl.g_vc_nk_name_hist := r_obj.stag_hist_nk_name;
         p#frm#stag_ddl.g_vc_view_name_hist := r_obj.stag_hist_view_name;
         p#frm#stag_ddl.g_vc_view_name_fbda := r_obj.stag_hist_fbda_name;
         p#frm#stag_ddl.g_vc_package_main := r_obj.stag_package_name;
         --
         p#frm#stag_ddl.g_vc_col_def := l_vc_col_def;
         p#frm#stag_ddl.g_vc_col_all := l_vc_col_all;
         p#frm#stag_ddl.g_vc_col_pk_src := l_vc_col_pk;
         --
         p#frm#stag_ddl.g_vc_col_hist := l_vc_col_hst;
         p#frm#stag_ddl.g_vc_col_update := l_vc_col_upd;
         --
         p#frm#stag_ddl.g_vc_tablespace_stage_data := r_obj.stag_ts_stage_data;
         p#frm#stag_ddl.g_vc_tablespace_stage_indx := r_obj.stag_ts_stage_indx;
         p#frm#stag_ddl.g_vc_tablespace_hist_data := r_obj.stag_ts_hist_data;
         p#frm#stag_ddl.g_vc_tablespace_hist_indx := r_obj.stag_ts_hist_indx;
         p#frm#stag_ddl.g_vc_fb_archive := r_obj.stag_fb_archive;
         --
         p#frm#stag_ddl.g_l_dblink :=
            p#frm#type.fct_string_to_list (
               l_vc_stage_db_list
             , ','
            );
         p#frm#stag_ddl.g_l_owner_src :=
            p#frm#type.fct_string_to_list (
               l_vc_stage_owner_list
             , ','
            );
         p#frm#stag_ddl.g_l_distr_code :=
            p#frm#type.fct_string_to_list (
               l_vc_distr_code_list
             , ','
            );
         p#frm#stag_ddl.g_vc_col_pk :=
               CASE
                  WHEN l_vc_col_pk IS NOT NULL
                   AND p#frm#stag_ddl.g_l_dblink.COUNT > 1 THEN
                        ' '
                     || p#frm#stag_param.c_vc_column_source_db
                     || ',  '
               END
            || l_vc_col_pk;
         -- Create target objects
         p#frm#stag_ddl.prc_create_stage_table (
            p_b_drop_stage_flag
          , p_b_raise_flag
         );
         p#frm#stag_ddl.prc_create_hist_table (
            p_b_drop_hist_flag
          , p_b_raise_flag
         );

         -- Create view or synonym (depending on the environment)
         /*IF param.c_vc_db_name_actual IN (param.c_vc_db_name_dev, param.c_vc_db_name_tst)
         THEN
            p#frm#stag_ddl.prc_create_stage2_view (p_b_raise_flag);
         ELSE
            p#frm#stag_ddl.prc_create_stage2_synonym (p_b_raise_flag);
         END IF;*/
         IF p#frm#stag_ddl.g_vc_fb_archive IS NOT NULL
        AND p#frm#stag_ddl.g_n_fbda_flag = 1 THEN
            p#frm#stag_ddl.prc_create_fbda_view (p_b_raise_flag);
         END IF;

         IF l_vc_col_pk IS NOT NULL
        AND r_obj.stag_source_nk_flag = 0 THEN
            p#frm#stag_ddl.prc_create_duplicate_table (
               TRUE
             , p_b_raise_flag
            );
         END IF;

         p#frm#stag_ddl.prc_create_diff_table (
            TRUE
          , p_b_raise_flag
         );
         p#frm#stag_ddl.prc_create_package_main (
            FALSE
          , TRUE
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Finish building db objects'
         );
      END LOOP;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Finished building db objects'
      );
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Finish'
       , 'Build complete'
      );
   END prc_build_all;

   PROCEDURE prc_build_hist (
      p_vc_source_code    VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name    VARCHAR2 DEFAULT 'ALL'
    , p_b_drop_flag       BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name           t_object_name := 'prc_build_hist';
      l_vc_stage_db_list      t_string;
      l_vc_stage_owner_list   t_string;
      l_vc_distr_code_list    t_string;
      --
      l_vc_col_def            t_string;
      l_vc_col_all            t_string;
      l_vc_col_pk             t_string;
      l_vc_col_comm           t_string;
      --
      l_vc_col_hst            t_string;
      l_vc_col_upd            t_string;
   BEGIN
      --p#frm#trac.set_console_logging (FALSE);
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Start'
       , 'Build db objects needed for the hist part of a stage data flow'
      );
      p#frm#stag_meta.prc_set_object_properties;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Object properties'
       , 'Set names of db objects to be built'
      );
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Start building db objects'
      );

      -- Select all objects
      FOR r_obj IN (  SELECT s.stag_source_id
                           , s.stag_source_code
                           , s.stag_source_prefix
                           , d.stag_source_db_link
                           , d.stag_source_owner
                           , s.stag_owner
                           , s.stag_ts_stage_data
                           , s.stag_ts_stage_indx
                           , s.stag_ts_hist_data
                           , s.stag_ts_hist_indx
                           , s.stag_fb_archive
                           , o.stag_object_id
                           , o.stag_parallel_degree
                           , o.stag_source_nk_flag
                           , o.stag_object_name
                           , o.stag_object_comment
                           , o.stag_object_root
                           , o.stag_src_table_name
                           , o.stag_dupl_table_name
                           , o.stag_diff_table_name
                           , o.stag_diff_nk_name
                           , o.stag_stage_table_name
                           , o.stag_hist_table_name
                           , o.stag_hist_nk_name
                           , o.stag_hist_view_name
                           , o.stag_hist_fbda_name
                           , o.stag_package_name
                           , o.stag_filter_clause
                           , o.stag_partition_clause
                           , o.stag_fbda_flag
                        FROM p#frm#stag_source_t s
                           , (SELECT stag_source_id
                                   , stag_source_db_link
                                   , stag_source_owner
                                FROM (SELECT stag_source_id
                                           , stag_source_db_link
                                           , stag_source_owner
                                           , ROW_NUMBER () OVER (PARTITION BY stag_source_id ORDER BY stag_source_db_id) AS source_db_order
                                        FROM p#frm#stag_source_db_t)
                               WHERE source_db_order = 1) d
                           , p#frm#stag_object_t o
                       WHERE s.stag_source_id = d.stag_source_id(+)
                         AND s.stag_source_id = o.stag_source_id
                         AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                         AND p_vc_object_name IN (o.stag_object_name, 'ALL')
                    ORDER BY stag_object_id) LOOP
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Start building objects'
         );
         -- Reset list strings
         l_vc_col_def := '';
         l_vc_col_all := '';
         l_vc_col_pk := '';

         -- Build list of columns
         FOR r_col IN (  SELECT NVL (stag_column_name_map, stag_column_name) AS stag_column_name
                              , stag_column_def
                              , stag_column_nk_pos
                              , stag_column_hist_flag
                           FROM p#frm#stag_column_t
                          WHERE stag_object_id = r_obj.stag_object_id
                            AND stag_column_edwh_flag = 1
                       ORDER BY stag_column_pos) LOOP
            l_vc_col_def :=
                  l_vc_col_def
               || CHR (10)
               || r_col.stag_column_name
               || ' '
               || r_col.stag_column_def
               || ',';
            l_vc_col_all :=
                  l_vc_col_all
               || CHR (10)
               || r_col.stag_column_name
               || ',';

            IF r_col.stag_column_nk_pos >= 0 THEN
               l_vc_col_pk :=
                     l_vc_col_pk
                  || CHR (10)
                  || r_col.stag_column_name
                  || ',';
            END IF;

            IF r_col.stag_column_hist_flag = 1 THEN
               l_vc_col_hst :=
                     l_vc_col_hst
                  || r_col.stag_column_name
                  || ',';
            ELSE
               l_vc_col_upd :=
                     l_vc_col_upd
                  || r_col.stag_column_name
                  || ',';
            END IF;
         END LOOP;

         l_vc_col_def :=
            RTRIM (
               l_vc_col_def
             , ','
            );
         l_vc_col_all :=
            RTRIM (
               l_vc_col_all
             , ','
            );
         l_vc_col_pk :=
            RTRIM (
               l_vc_col_pk
             , ','
            );
         l_vc_col_hst :=
            RTRIM (
               l_vc_col_hst
             , ','
            );
         l_vc_col_upd :=
            RTRIM (
               l_vc_col_upd
             , ','
            );
         -- Set main properties for the given object
         p#frm#stag_ddl.g_n_object_id := r_obj.stag_object_id;
         p#frm#stag_ddl.g_n_parallel_degree := r_obj.stag_parallel_degree;
         p#frm#stag_ddl.g_n_source_nk_flag := r_obj.stag_source_nk_flag;
         p#frm#stag_ddl.g_vc_object_name := r_obj.stag_object_name;
         p#frm#stag_ddl.g_vc_table_comment := r_obj.stag_object_comment;
         p#frm#stag_ddl.g_vc_source_code := r_obj.stag_source_code;
         p#frm#stag_ddl.g_vc_prefix_src := r_obj.stag_source_prefix;
         p#frm#stag_ddl.g_vc_owner_stg := USER;
         p#frm#stag_ddl.g_vc_filter_clause := r_obj.stag_filter_clause;
         p#frm#stag_ddl.g_vc_partition_expr := r_obj.stag_partition_clause;
         p#frm#stag_ddl.g_vc_table_name_diff := r_obj.stag_diff_table_name;
         p#frm#stag_ddl.g_vc_table_name_stage := r_obj.stag_stage_table_name;
         p#frm#stag_ddl.g_vc_table_name_hist := r_obj.stag_hist_table_name;
         p#frm#stag_ddl.g_vc_nk_name_diff := r_obj.stag_diff_nk_name;
         p#frm#stag_ddl.g_vc_nk_name_hist := r_obj.stag_hist_nk_name;
         p#frm#stag_ddl.g_vc_view_name_hist := r_obj.stag_hist_view_name;
         p#frm#stag_ddl.g_vc_view_name_fbda := r_obj.stag_hist_fbda_name;
         p#frm#stag_ddl.g_vc_package_main := r_obj.stag_package_name;
         --
         p#frm#stag_ddl.g_vc_col_def := l_vc_col_def;
         p#frm#stag_ddl.g_vc_col_all := l_vc_col_all;
         p#frm#stag_ddl.g_vc_col_pk_src := l_vc_col_pk;
         --
         p#frm#stag_ddl.g_vc_tablespace_hist_data := r_obj.stag_ts_hist_data;
         p#frm#stag_ddl.g_vc_tablespace_hist_indx := r_obj.stag_ts_hist_indx;
         p#frm#stag_ddl.g_vc_fb_archive := r_obj.stag_fb_archive;
         p#frm#stag_ddl.g_n_fbda_flag := r_obj.stag_fbda_flag;
         --
         p#frm#stag_ddl.g_vc_col_pk :=
               CASE
                  WHEN l_vc_col_pk IS NOT NULL
                   AND p#frm#stag_ddl.g_l_distr_code.COUNT > 1 THEN
                        ' '
                     || p#frm#stag_param.c_vc_column_source_db
                     || ',  '
               END
            || l_vc_col_pk;
         -- Create target objects
         p#frm#stag_ddl.prc_create_hist_table (
            p_b_drop_flag
          , p_b_raise_flag
         );

         -- Create view or synonym (depending on the environment)
         /*IF param.c_vc_db_name_actual IN (param.c_vc_db_name_dev, param.c_vc_db_name_tst)
         THEN
            p#frm#stag_ddl.prc_create_stage2_view (p_b_raise_flag);
         ELSE
            p#frm#stag_ddl.prc_create_stage2_synonym (p_b_raise_flag);
         END IF;*/
         IF l_vc_col_pk IS NOT NULL
        AND r_obj.stag_source_nk_flag = 0 THEN
            p#frm#stag_ddl.prc_create_duplicate_table (
               TRUE
             , p_b_raise_flag
            );
         END IF;

         p#frm#stag_ddl.prc_create_diff_table (
            TRUE
          , p_b_raise_flag
         );
         p#frm#stag_ddl.prc_create_package_main (
            TRUE
          , TRUE
         );
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Finish building db objects'
         );
      END LOOP;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Finished building db objects'
      );
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Finish'
       , 'Build complete'
      );
   END prc_build_hist;

   PROCEDURE prc_upgrade_hist (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
   IS
      l_vc_prc_name          t_object_name := 'prc_upgrade_hist';
      l_vc_stage_db_list     t_string;
      l_vc_distr_code_list   t_string;
      l_vc_col_def           t_string;
      l_vc_col_pk            t_string;
      l_vc_table_name_bkp    t_object_name;
      --
      l_vc_sql_statement     t_string;
      --
      l_n_cnt                NUMBER;
   BEGIN
      --p#frm#trac.set_console_logging (FALSE);
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Start'
       , 'Upgrade hist table with newly added columns'
      );
      p#frm#stag_meta.prc_set_object_properties;
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Object properties'
       , 'Set names of db objects to be built'
      );
      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Start building db objects'
      );
      p#frm#stag_ddl.g_vc_owner_stg := USER;

      --
      -- Select all objects
      FOR r_obj IN (  SELECT s.stag_source_id
                           , s.stag_source_code
                           --, s.stag_owner
                           , d.stag_source_db_link
                           , s.stag_ts_hist_data
                           , s.stag_ts_hist_indx
                           , o.stag_object_id
                           , stag_object_name
                           , o.stag_parallel_degree
                           , o.stag_hist_table_name
                           , o.stag_hist_view_name
                           , o.stag_hist_nk_name
                           , o.stag_partition_clause
                        FROM p#frm#stag_source_t s
                           , (SELECT stag_source_id
                                   , stag_source_db_link
                                   , stag_source_owner
                                FROM (SELECT stag_source_id
                                           , stag_source_db_link
                                           , stag_source_owner
                                           , ROW_NUMBER () OVER (PARTITION BY stag_source_id ORDER BY stag_source_db_id) AS source_db_order
                                        FROM p#frm#stag_source_db_t)
                               WHERE source_db_order = 1) d
                           , p#frm#stag_object_t o
                       WHERE s.stag_source_id = d.stag_source_id
                         AND s.stag_source_id = o.stag_source_id
                         AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                         AND p_vc_object_name IN (o.stag_object_name, 'ALL')
                    ORDER BY stag_object_id) LOOP
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          ,    'Table:'
            || p#frm#stag_ddl.g_vc_owner_stg
            || '.'
            || r_obj.stag_hist_table_name
          , 'Start building objects'
         );
         -- Set name of the backup table
         l_vc_table_name_bkp :=
            SUBSTR (
                  r_obj.stag_hist_table_name
               || '_BKP'
             , 1
             , 30
            );

         SELECT COUNT (0)
           INTO l_n_cnt
           FROM all_tables
          WHERE owner = p#frm#stag_ddl.g_vc_owner_stg
            AND table_name = l_vc_table_name_bkp;

         IF l_n_cnt > 0 THEN
            raise_application_error (
               -20000
             , 'Backup table already present'
            );
         END IF;

         -- Reset list strings
         l_vc_stage_db_list := '';
         l_vc_distr_code_list := '';
         l_vc_col_def := '';
         l_vc_col_pk := '';

         -- Build list of values for objects with multiple sources
         FOR r_db IN (SELECT stag_source_db_link
                           , stag_source_owner
                           , stag_distribution_code
                        FROM p#frm#stag_source_db_t
                       WHERE stag_source_id = r_obj.stag_source_id) LOOP
            l_vc_stage_db_list :=
                  l_vc_stage_db_list
               || r_db.stag_source_db_link
               || ',';
            l_vc_distr_code_list :=
                  l_vc_distr_code_list
               || r_db.stag_distribution_code
               || ',';
         END LOOP;

         l_vc_stage_db_list :=
            RTRIM (
               l_vc_stage_db_list
             , ','
            );
         l_vc_distr_code_list :=
            RTRIM (
               l_vc_distr_code_list
             , ','
            );

         -- Build list of columns
         FOR r_col IN (  SELECT NVL (stag_column_name_map, stag_column_name) AS stag_column_name
                              , stag_column_def
                              , stag_column_nk_pos
                           FROM p#frm#stag_column_t
                          WHERE stag_object_id = r_obj.stag_object_id
                            AND stag_column_edwh_flag = 1
                       ORDER BY stag_column_pos) LOOP
            l_vc_col_def :=
                  l_vc_col_def
               || CHR (10)
               || r_col.stag_column_name
               || ' '
               || r_col.stag_column_def
               || ',';

            IF r_col.stag_column_nk_pos IS NOT NULL THEN
               l_vc_col_pk :=
                     l_vc_col_pk
                  || CHR (10)
                  || r_col.stag_column_name
                  || ',';
            END IF;
         END LOOP;

         l_vc_col_def :=
            RTRIM (
               l_vc_col_def
             , ','
            );
         l_vc_col_pk :=
            RTRIM (
               l_vc_col_pk
             , ','
            );
         -- Set main properties for the given object
         p#frm#stag_ddl.g_n_parallel_degree := r_obj.stag_parallel_degree;
         p#frm#stag_ddl.g_vc_partition_expr := r_obj.stag_partition_clause;
         p#frm#stag_ddl.g_vc_table_name_hist := r_obj.stag_hist_table_name;
         p#frm#stag_ddl.g_vc_view_name_hist := r_obj.stag_hist_view_name;
         p#frm#stag_ddl.g_vc_nk_name_hist := r_obj.stag_hist_nk_name;
         --
         p#frm#stag_ddl.g_vc_col_def := l_vc_col_def;
         --
         p#frm#stag_ddl.g_vc_tablespace_hist_data := r_obj.stag_ts_hist_data;
         p#frm#stag_ddl.g_vc_tablespace_hist_indx := r_obj.stag_ts_hist_indx;
         --
         p#frm#stag_ddl.g_l_dblink :=
            p#frm#type.fct_string_to_list (
               l_vc_stage_db_list
             , ','
            );
         p#frm#stag_ddl.g_l_distr_code :=
            p#frm#type.fct_string_to_list (
               l_vc_distr_code_list
             , ','
            );
         p#frm#stag_ddl.g_vc_col_pk :=
               CASE
                  WHEN p#frm#stag_ddl.g_l_dblink.COUNT > 1 THEN
                        ' '
                     || p#frm#stag_param.c_vc_column_source_db
                     || ',  '
               END
            || l_vc_col_pk;

         -- Drop PK and indexes
         FOR r_cst IN (SELECT constraint_name
                         FROM all_constraints
                        WHERE owner = p#frm#stag_ddl.g_vc_owner_stg
                          AND table_name = r_obj.stag_hist_table_name) LOOP
            --
            l_vc_sql_statement :=
                  'ALTER TABLE '
               || p#frm#stag_ddl.g_vc_owner_stg
               || '.'
               || r_obj.stag_hist_table_name
               || ' DROP CONSTRAINT '
               || r_cst.constraint_name;
            --
            p#frm#trac.log_sub_debug (
               l_vc_prc_name
             , 'Drop constraint'
             , l_vc_sql_statement
            );

            --
            EXECUTE IMMEDIATE l_vc_sql_statement;
         --
         END LOOP;

         FOR r_idx IN (SELECT index_name
                         FROM all_indexes
                        WHERE owner = p#frm#stag_ddl.g_vc_owner_stg
                          AND table_name = r_obj.stag_hist_table_name) LOOP
            --
            l_vc_sql_statement :=
                  'DROP INDEX '
               || p#frm#stag_ddl.g_vc_owner_stg
               || '.'
               || r_idx.index_name;
            --
            p#frm#trac.log_sub_debug (
               l_vc_prc_name
             , 'Drop index'
             , l_vc_sql_statement
            );

            --
            EXECUTE IMMEDIATE l_vc_sql_statement;
         --
         END LOOP;

         EXECUTE IMMEDIATE
               'RENAME '
            || r_obj.stag_hist_table_name
            || ' TO '
            || l_vc_table_name_bkp;

         -- Create target object
         p#frm#stag_ddl.prc_create_hist_table (
            FALSE
          , TRUE
         );
         -- Migrate data
         p#frm#ddls.prc_migrate_table (
            r_obj.stag_hist_table_name
          , l_vc_table_name_bkp
         );
         -- Create view or synonym (depending on the environment)
         /*IF param.c_vc_db_name_actual IN (param.c_vc_db_name_dev, param.c_vc_db_name_tst)
         THEN
            p#frm#stag_ddl.prc_create_stage2_view (TRUE);
         ELSE
            p#frm#stag_ddl.prc_create_stage2_synonym (TRUE);
         END IF;*/
         p#frm#trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Finish building db objects'
         );
      END LOOP;

      p#frm#trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Finished building db objects'
      );
      p#frm#trac.log_sub_info (
         l_vc_prc_name
       , 'Finish'
       , 'Build complete'
      );
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#stag_build;
2014-11-28 13:53:25.824 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_stag_build
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   PROCEDURE prc_build_all (
      p_vc_source_code       VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name       VARCHAR2 DEFAULT 'ALL'
    , p_b_index_flag         BOOLEAN DEFAULT FALSE
    , p_b_drop_stage_flag    BOOLEAN DEFAULT TRUE
    , p_b_drop_hist_flag     BOOLEAN DEFAULT FALSE
    , p_b_raise_flag         BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name           t_object_name := 'prc_build_all';
      l_vc_stage_db_list      t_string;
      l_vc_stage_owner_list   t_string;
      l_vc_distr_code_list    t_string;
      l_vc_col_def            t_string;
      l_vc_col_all            t_string;
      l_vc_col_pk             t_string;
      l_vc_col_comm           t_string;
      --
      l_vc_col_hst            t_string;
      l_vc_col_upd            t_string;
   BEGIN
      --dwhutl_trac.set_console_logging (FALSE);
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Start'
       , 'Build all db objects needed for a stage data flow'
      );
      dwhutl_stag_meta.prc_set_object_properties;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Object properties'
       , 'Set names of db objects to be built'
      );
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Start building db objects'
      );

      -- Select all objects
      FOR r_obj IN (  SELECT s.stag_source_id
                           , s.stag_source_code
                           , s.stag_source_prefix
                           , d.stag_source_db_link
                           , d.stag_source_owner
                           , s.stag_owner
                           , s.stag_ts_stage_data
                           , s.stag_ts_stage_indx
                           , s.stag_ts_hist_data
                           , s.stag_ts_hist_indx
                           , s.stag_fb_archive
                           , o.stag_object_id
                           , o.stag_parallel_degree
                           , o.stag_source_nk_flag
                           , o.stag_object_name
                           , o.stag_object_comment
                           , o.stag_object_root
                           , o.stag_src_table_name
                           , o.stag_dupl_table_name
                           , o.stag_diff_table_name
                           , o.stag_diff_nk_name
                           , o.stag_stage_table_name
                           , o.stag_hist_table_name
                           , o.stag_hist_nk_name
                           , o.stag_hist_view_name
                           , o.stag_hist_fbda_name
                           , o.stag_package_name
                           , o.stag_filter_clause
                           , o.stag_partition_clause
                           , o.stag_hist_flag
                           , o.stag_fbda_flag
                           , o.stag_increment_buffer
                           , c.stag_increment_column
                           , c.stag_increment_coldef
                        FROM dwhutl_stag_source_t s
                           , (SELECT stag_source_id
                                   , stag_source_db_link
                                   , stag_source_owner
                                FROM (SELECT stag_source_id
                                           , stag_source_db_link
                                           , stag_source_owner
                                           , ROW_NUMBER () OVER (PARTITION BY stag_source_id ORDER BY stag_source_db_id) AS source_db_order
                                        FROM dwhutl_stag_source_db_t)
                               WHERE source_db_order = 1) d
                           , dwhutl_stag_object_t o
                           , (SELECT stag_object_id
                                   , stag_column_name AS stag_increment_column
                                   , stag_column_def AS stag_increment_coldef
                                FROM (SELECT stag_object_id
                                           , stag_column_name
                                           , stag_column_def
                                           , ROW_NUMBER () OVER (PARTITION BY stag_object_id ORDER BY stag_column_pos) AS column_order
                                        FROM dwhutl_stag_column_t
                                       WHERE stag_column_incr_flag > 0
                                         AND (stag_column_def LIKE 'DATE%'
                                           OR stag_column_def LIKE 'NUMBER%'))
                               WHERE column_order = 1) c
                       WHERE s.stag_source_id = d.stag_source_id
                         AND s.stag_source_id = o.stag_source_id
                         AND o.stag_object_id = c.stag_object_id(+)
                         AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                         AND p_vc_object_name IN (o.stag_object_name, 'ALL')
                    ORDER BY stag_object_id) LOOP
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Start building objects'
         );
         -- Reset list strings
         l_vc_stage_db_list := '';
         l_vc_stage_owner_list := '';
         l_vc_distr_code_list := '';
         l_vc_col_def := '';
         l_vc_col_all := '';
         l_vc_col_pk := '';
         l_vc_col_hst := '';
         l_vc_col_upd := '';

         -- Build list of values for objects with multiple sources
         FOR r_db IN (SELECT stag_source_db_link
                           , stag_source_owner
                           , stag_distribution_code
                        FROM dwhutl_stag_source_db_t
                       WHERE stag_source_id = r_obj.stag_source_id) LOOP
            l_vc_stage_db_list :=
                  l_vc_stage_db_list
               || r_db.stag_source_db_link
               || ',';
            l_vc_stage_owner_list :=
                  l_vc_stage_owner_list
               || r_db.stag_source_owner
               || ',';
            l_vc_distr_code_list :=
                  l_vc_distr_code_list
               || r_db.stag_distribution_code
               || ',';
         END LOOP;

         l_vc_stage_db_list :=
            RTRIM (
               l_vc_stage_db_list
             , ','
            );
         l_vc_stage_owner_list :=
            RTRIM (
               l_vc_stage_owner_list
             , ','
            );
         l_vc_distr_code_list :=
            RTRIM (
               l_vc_distr_code_list
             , ','
            );

         -- Build list of columns
         FOR r_col IN (  SELECT NVL (stag_column_name_map, stag_column_name) AS stag_column_name
                              , stag_column_def
                              , stag_column_nk_pos
                              , stag_column_hist_flag
                           FROM dwhutl_stag_column_t
                          WHERE stag_object_id = r_obj.stag_object_id
                            AND stag_column_edwh_flag = 1
                       ORDER BY stag_column_pos) LOOP
            l_vc_col_def :=
                  l_vc_col_def
               || CHR (10)
               || r_col.stag_column_name
               || ' '
               || r_col.stag_column_def
               || ',';
            l_vc_col_all :=
                  l_vc_col_all
               || CHR (10)
               || r_col.stag_column_name
               || ',';

            IF r_col.stag_column_nk_pos >= 0 THEN
               l_vc_col_pk :=
                     l_vc_col_pk
                  || CHR (10)
                  || r_col.stag_column_name
                  || ',';
            END IF;

            IF r_col.stag_column_hist_flag = 1
           AND r_obj.stag_hist_flag = 1 THEN
               l_vc_col_hst :=
                     l_vc_col_hst
                  || r_col.stag_column_name
                  || ',';
            ELSE
               l_vc_col_upd :=
                     l_vc_col_upd
                  || r_col.stag_column_name
                  || ',';
            END IF;
         END LOOP;

         l_vc_col_def :=
            RTRIM (
               l_vc_col_def
             , ','
            );
         l_vc_col_all :=
            RTRIM (
               l_vc_col_all
             , ','
            );
         l_vc_col_pk :=
            RTRIM (
               l_vc_col_pk
             , ','
            );
         l_vc_col_hst :=
            RTRIM (
               l_vc_col_hst
             , ','
            );
         l_vc_col_upd :=
            RTRIM (
               l_vc_col_upd
             , ','
            );
         --
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , 'List of column definitions'
          , l_vc_col_def
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , 'List of columns'
          , l_vc_col_all
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , 'List of pk columns'
          , l_vc_col_pk
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , 'List of columns to historicize'
          , l_vc_col_hst
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          , 'List of columns to update'
          , l_vc_col_upd
         );
         -- Set main properties for the given object
         dwhutl_stag_ddl.g_n_object_id := r_obj.stag_object_id;
         dwhutl_stag_ddl.g_n_parallel_degree := r_obj.stag_parallel_degree;
         dwhutl_stag_ddl.g_n_source_nk_flag := r_obj.stag_source_nk_flag;
         dwhutl_stag_ddl.g_n_fbda_flag := r_obj.stag_fbda_flag;
         dwhutl_stag_ddl.g_vc_object_name := r_obj.stag_object_name;
         dwhutl_stag_ddl.g_vc_table_comment := r_obj.stag_object_comment;
         dwhutl_stag_ddl.g_vc_source_code := r_obj.stag_source_code;
         dwhutl_stag_ddl.g_vc_prefix_src := r_obj.stag_source_prefix;
         dwhutl_stag_ddl.g_vc_dblink := r_obj.stag_source_db_link;
         dwhutl_stag_ddl.g_vc_owner_src := r_obj.stag_source_owner;
         dwhutl_stag_ddl.g_vc_owner_stg := USER;
         dwhutl_stag_ddl.g_vc_table_name_source :=
            CASE
               WHEN r_obj.stag_source_db_link IS NULL
                AND r_obj.stag_source_owner = r_obj.stag_owner THEN
                  r_obj.stag_src_table_name
               ELSE
                  r_obj.stag_object_name
            END;
         dwhutl_stag_ddl.g_vc_source_identifier :=
            CASE
               WHEN r_obj.stag_source_db_link IS NULL
                AND r_obj.stag_source_owner = r_obj.stag_owner THEN
                  r_obj.stag_src_table_name
               ELSE
                     CASE
                        WHEN r_obj.stag_source_owner IS NOT NULL THEN
                              r_obj.stag_source_owner
                           || '.'
                     END
                  || r_obj.stag_object_name
                  || CASE
                        WHEN r_obj.stag_source_db_link IS NOT NULL THEN
                              '@'
                           || r_obj.stag_source_db_link
                     END
            END;
         --
         dwhutl_stag_ddl.g_vc_dedupl_rank_clause :=
            CASE
               WHEN r_obj.stag_source_db_link IS NULL
                AND r_obj.stag_source_owner = r_obj.stag_owner THEN
                  'ORDER BY 1'
               ELSE
                  'ORDER BY rowid DESC'
            END;
         dwhutl_stag_ddl.g_vc_filter_clause := r_obj.stag_filter_clause;
         dwhutl_stag_ddl.g_vc_partition_expr := r_obj.stag_partition_clause;
         dwhutl_stag_ddl.g_vc_increment_column := r_obj.stag_increment_column;
         dwhutl_stag_ddl.g_vc_increment_coldef := r_obj.stag_increment_coldef;
         dwhutl_stag_ddl.g_n_increment_buffer := r_obj.stag_increment_buffer;
         dwhutl_stag_ddl.g_vc_table_name_dupl := r_obj.stag_dupl_table_name;
         dwhutl_stag_ddl.g_vc_table_name_diff := r_obj.stag_diff_table_name;
         dwhutl_stag_ddl.g_vc_table_name_stage := r_obj.stag_stage_table_name;
         dwhutl_stag_ddl.g_vc_table_name_hist := r_obj.stag_hist_table_name;
         dwhutl_stag_ddl.g_vc_nk_name_diff := r_obj.stag_diff_nk_name;
         dwhutl_stag_ddl.g_vc_nk_name_hist := r_obj.stag_hist_nk_name;
         dwhutl_stag_ddl.g_vc_view_name_hist := r_obj.stag_hist_view_name;
         dwhutl_stag_ddl.g_vc_view_name_fbda := r_obj.stag_hist_fbda_name;
         dwhutl_stag_ddl.g_vc_package_main := r_obj.stag_package_name;
         --
         dwhutl_stag_ddl.g_vc_col_def := l_vc_col_def;
         dwhutl_stag_ddl.g_vc_col_all := l_vc_col_all;
         dwhutl_stag_ddl.g_vc_col_pk_src := l_vc_col_pk;
         --
         dwhutl_stag_ddl.g_vc_col_hist := l_vc_col_hst;
         dwhutl_stag_ddl.g_vc_col_update := l_vc_col_upd;
         --
         dwhutl_stag_ddl.g_vc_tablespace_stage_data := r_obj.stag_ts_stage_data;
         dwhutl_stag_ddl.g_vc_tablespace_stage_indx := r_obj.stag_ts_stage_indx;
         dwhutl_stag_ddl.g_vc_tablespace_hist_data := r_obj.stag_ts_hist_data;
         dwhutl_stag_ddl.g_vc_tablespace_hist_indx := r_obj.stag_ts_hist_indx;
         dwhutl_stag_ddl.g_vc_fb_archive := r_obj.stag_fb_archive;
         --
         dwhutl_stag_ddl.g_l_dblink :=
            dwhutl_type.fct_string_to_list (
               l_vc_stage_db_list
             , ','
            );
         dwhutl_stag_ddl.g_l_owner_src :=
            dwhutl_type.fct_string_to_list (
               l_vc_stage_owner_list
             , ','
            );
         dwhutl_stag_ddl.g_l_distr_code :=
            dwhutl_type.fct_string_to_list (
               l_vc_distr_code_list
             , ','
            );
         dwhutl_stag_ddl.g_vc_col_pk :=
               CASE
                  WHEN l_vc_col_pk IS NOT NULL
                   AND dwhutl_stag_ddl.g_l_dblink.COUNT > 1 THEN
                        ' '
                     || dwhutl_stag_param.c_vc_column_source_db
                     || ',  '
               END
            || l_vc_col_pk;
         -- Create target objects
         dwhutl_stag_ddl.prc_create_stage_table (
            p_b_drop_stage_flag
          , p_b_raise_flag
         );
         dwhutl_stag_ddl.prc_create_hist_table (
            p_b_drop_hist_flag
          , p_b_raise_flag
         );

         -- Create view or synonym (depending on the environment)
         /*IF param.c_vc_db_name_actual IN (param.c_vc_db_name_dev, param.c_vc_db_name_tst)
         THEN
            dwhutl_stag_ddl.prc_create_stage2_view (p_b_raise_flag);
         ELSE
            dwhutl_stag_ddl.prc_create_stage2_synonym (p_b_raise_flag);
         END IF;*/
         IF dwhutl_stag_ddl.g_vc_fb_archive IS NOT NULL
        AND dwhutl_stag_ddl.g_n_fbda_flag = 1 THEN
            dwhutl_stag_ddl.prc_create_fbda_view (p_b_raise_flag);
         END IF;

         IF l_vc_col_pk IS NOT NULL
        AND r_obj.stag_source_nk_flag = 0 THEN
            dwhutl_stag_ddl.prc_create_duplicate_table (
               TRUE
             , p_b_raise_flag
            );
         END IF;

         dwhutl_stag_ddl.prc_create_diff_table (
            TRUE
          , p_b_raise_flag
         );
         dwhutl_stag_ddl.prc_create_package_main (
            FALSE
          , TRUE
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Finish building db objects'
         );
      END LOOP;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Finished building db objects'
      );
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Finish'
       , 'Build complete'
      );
   END prc_build_all;

   PROCEDURE prc_build_hist (
      p_vc_source_code    VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name    VARCHAR2 DEFAULT 'ALL'
    , p_b_drop_flag       BOOLEAN DEFAULT FALSE
    , p_b_raise_flag      BOOLEAN DEFAULT FALSE
   )
   IS
      l_vc_prc_name           t_object_name := 'prc_build_hist';
      l_vc_stage_db_list      t_string;
      l_vc_stage_owner_list   t_string;
      l_vc_distr_code_list    t_string;
      --
      l_vc_col_def            t_string;
      l_vc_col_all            t_string;
      l_vc_col_pk             t_string;
      l_vc_col_comm           t_string;
      --
      l_vc_col_hst            t_string;
      l_vc_col_upd            t_string;
   BEGIN
      --dwhutl_trac.set_console_logging (FALSE);
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Start'
       , 'Build db objects needed for the hist part of a stage data flow'
      );
      dwhutl_stag_meta.prc_set_object_properties;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Object properties'
       , 'Set names of db objects to be built'
      );
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Start building db objects'
      );

      -- Select all objects
      FOR r_obj IN (  SELECT s.stag_source_id
                           , s.stag_source_code
                           , s.stag_source_prefix
                           , d.stag_source_db_link
                           , d.stag_source_owner
                           , s.stag_owner
                           , s.stag_ts_stage_data
                           , s.stag_ts_stage_indx
                           , s.stag_ts_hist_data
                           , s.stag_ts_hist_indx
                           , s.stag_fb_archive
                           , o.stag_object_id
                           , o.stag_parallel_degree
                           , o.stag_source_nk_flag
                           , o.stag_object_name
                           , o.stag_object_comment
                           , o.stag_object_root
                           , o.stag_src_table_name
                           , o.stag_dupl_table_name
                           , o.stag_diff_table_name
                           , o.stag_diff_nk_name
                           , o.stag_stage_table_name
                           , o.stag_hist_table_name
                           , o.stag_hist_nk_name
                           , o.stag_hist_view_name
                           , o.stag_hist_fbda_name
                           , o.stag_package_name
                           , o.stag_filter_clause
                           , o.stag_partition_clause
                           , o.stag_fbda_flag
                        FROM dwhutl_stag_source_t s
                           , (SELECT stag_source_id
                                   , stag_source_db_link
                                   , stag_source_owner
                                FROM (SELECT stag_source_id
                                           , stag_source_db_link
                                           , stag_source_owner
                                           , ROW_NUMBER () OVER (PARTITION BY stag_source_id ORDER BY stag_source_db_id) AS source_db_order
                                        FROM dwhutl_stag_source_db_t)
                               WHERE source_db_order = 1) d
                           , dwhutl_stag_object_t o
                       WHERE s.stag_source_id = d.stag_source_id(+)
                         AND s.stag_source_id = o.stag_source_id
                         AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                         AND p_vc_object_name IN (o.stag_object_name, 'ALL')
                    ORDER BY stag_object_id) LOOP
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Start building objects'
         );
         -- Reset list strings
         l_vc_col_def := '';
         l_vc_col_all := '';
         l_vc_col_pk := '';

         -- Build list of columns
         FOR r_col IN (  SELECT NVL (stag_column_name_map, stag_column_name) AS stag_column_name
                              , stag_column_def
                              , stag_column_nk_pos
                              , stag_column_hist_flag
                           FROM dwhutl_stag_column_t
                          WHERE stag_object_id = r_obj.stag_object_id
                            AND stag_column_edwh_flag = 1
                       ORDER BY stag_column_pos) LOOP
            l_vc_col_def :=
                  l_vc_col_def
               || CHR (10)
               || r_col.stag_column_name
               || ' '
               || r_col.stag_column_def
               || ',';
            l_vc_col_all :=
                  l_vc_col_all
               || CHR (10)
               || r_col.stag_column_name
               || ',';

            IF r_col.stag_column_nk_pos >= 0 THEN
               l_vc_col_pk :=
                     l_vc_col_pk
                  || CHR (10)
                  || r_col.stag_column_name
                  || ',';
            END IF;

            IF r_col.stag_column_hist_flag = 1 THEN
               l_vc_col_hst :=
                     l_vc_col_hst
                  || r_col.stag_column_name
                  || ',';
            ELSE
               l_vc_col_upd :=
                     l_vc_col_upd
                  || r_col.stag_column_name
                  || ',';
            END IF;
         END LOOP;

         l_vc_col_def :=
            RTRIM (
               l_vc_col_def
             , ','
            );
         l_vc_col_all :=
            RTRIM (
               l_vc_col_all
             , ','
            );
         l_vc_col_pk :=
            RTRIM (
               l_vc_col_pk
             , ','
            );
         l_vc_col_hst :=
            RTRIM (
               l_vc_col_hst
             , ','
            );
         l_vc_col_upd :=
            RTRIM (
               l_vc_col_upd
             , ','
            );
         -- Set main properties for the given object
         dwhutl_stag_ddl.g_n_object_id := r_obj.stag_object_id;
         dwhutl_stag_ddl.g_n_parallel_degree := r_obj.stag_parallel_degree;
         dwhutl_stag_ddl.g_n_source_nk_flag := r_obj.stag_source_nk_flag;
         dwhutl_stag_ddl.g_vc_object_name := r_obj.stag_object_name;
         dwhutl_stag_ddl.g_vc_table_comment := r_obj.stag_object_comment;
         dwhutl_stag_ddl.g_vc_source_code := r_obj.stag_source_code;
         dwhutl_stag_ddl.g_vc_prefix_src := r_obj.stag_source_prefix;
         dwhutl_stag_ddl.g_vc_owner_stg := USER;
         dwhutl_stag_ddl.g_vc_filter_clause := r_obj.stag_filter_clause;
         dwhutl_stag_ddl.g_vc_partition_expr := r_obj.stag_partition_clause;
         dwhutl_stag_ddl.g_vc_table_name_diff := r_obj.stag_diff_table_name;
         dwhutl_stag_ddl.g_vc_table_name_stage := r_obj.stag_stage_table_name;
         dwhutl_stag_ddl.g_vc_table_name_hist := r_obj.stag_hist_table_name;
         dwhutl_stag_ddl.g_vc_nk_name_diff := r_obj.stag_diff_nk_name;
         dwhutl_stag_ddl.g_vc_nk_name_hist := r_obj.stag_hist_nk_name;
         dwhutl_stag_ddl.g_vc_view_name_hist := r_obj.stag_hist_view_name;
         dwhutl_stag_ddl.g_vc_view_name_fbda := r_obj.stag_hist_fbda_name;
         dwhutl_stag_ddl.g_vc_package_main := r_obj.stag_package_name;
         --
         dwhutl_stag_ddl.g_vc_col_def := l_vc_col_def;
         dwhutl_stag_ddl.g_vc_col_all := l_vc_col_all;
         dwhutl_stag_ddl.g_vc_col_pk_src := l_vc_col_pk;
         --
         dwhutl_stag_ddl.g_vc_tablespace_hist_data := r_obj.stag_ts_hist_data;
         dwhutl_stag_ddl.g_vc_tablespace_hist_indx := r_obj.stag_ts_hist_indx;
         dwhutl_stag_ddl.g_vc_fb_archive := r_obj.stag_fb_archive;
         dwhutl_stag_ddl.g_n_fbda_flag := r_obj.stag_fbda_flag;
         --
         dwhutl_stag_ddl.g_vc_col_pk :=
               CASE
                  WHEN l_vc_col_pk IS NOT NULL
                   AND dwhutl_stag_ddl.g_l_distr_code.COUNT > 1 THEN
                        ' '
                     || dwhutl_stag_param.c_vc_column_source_db
                     || ',  '
               END
            || l_vc_col_pk;
         -- Create target objects
         dwhutl_stag_ddl.prc_create_hist_table (
            p_b_drop_flag
          , p_b_raise_flag
         );

         -- Create view or synonym (depending on the environment)
         /*IF param.c_vc_db_name_actual IN (param.c_vc_db_name_dev, param.c_vc_db_name_tst)
         THEN
            dwhutl_stag_ddl.prc_create_stage2_view (p_b_raise_flag);
         ELSE
            dwhutl_stag_ddl.prc_create_stage2_synonym (p_b_raise_flag);
         END IF;*/
         IF l_vc_col_pk IS NOT NULL
        AND r_obj.stag_source_nk_flag = 0 THEN
            dwhutl_stag_ddl.prc_create_duplicate_table (
               TRUE
             , p_b_raise_flag
            );
         END IF;

         dwhutl_stag_ddl.prc_create_diff_table (
            TRUE
          , p_b_raise_flag
         );
         dwhutl_stag_ddl.prc_create_package_main (
            TRUE
          , TRUE
         );
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Finish building db objects'
         );
      END LOOP;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Finished building db objects'
      );
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Finish'
       , 'Build complete'
      );
   END prc_build_hist;

   PROCEDURE prc_upgrade_hist (
      p_vc_source_code    VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
   IS
      l_vc_prc_name          t_object_name := 'prc_upgrade_hist';
      l_vc_stage_db_list     t_string;
      l_vc_distr_code_list   t_string;
      l_vc_col_def           t_string;
      l_vc_col_pk            t_string;
      l_vc_table_name_bkp    t_object_name;
      --
      l_vc_sql_statement     t_string;
      --
      l_n_cnt                NUMBER;
   BEGIN
      --dwhutl_trac.set_console_logging (FALSE);
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Start'
       , 'Upgrade hist table with newly added columns'
      );
      dwhutl_stag_meta.prc_set_object_properties;
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Object properties'
       , 'Set names of db objects to be built'
      );
      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Start building db objects'
      );
      dwhutl_stag_ddl.g_vc_owner_stg := USER;

      --
      -- Select all objects
      FOR r_obj IN (  SELECT s.stag_source_id
                           , s.stag_source_code
                           --, s.stag_owner
                           , d.stag_source_db_link
                           , s.stag_ts_hist_data
                           , s.stag_ts_hist_indx
                           , o.stag_object_id
                           , stag_object_name
                           , o.stag_parallel_degree
                           , o.stag_hist_table_name
                           , o.stag_hist_view_name
                           , o.stag_hist_nk_name
                           , o.stag_partition_clause
                        FROM dwhutl_stag_source_t s
                           , (SELECT stag_source_id
                                   , stag_source_db_link
                                   , stag_source_owner
                                FROM (SELECT stag_source_id
                                           , stag_source_db_link
                                           , stag_source_owner
                                           , ROW_NUMBER () OVER (PARTITION BY stag_source_id ORDER BY stag_source_db_id) AS source_db_order
                                        FROM dwhutl_stag_source_db_t)
                               WHERE source_db_order = 1) d
                           , dwhutl_stag_object_t o
                       WHERE s.stag_source_id = d.stag_source_id
                         AND s.stag_source_id = o.stag_source_id
                         AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                         AND p_vc_object_name IN (o.stag_object_name, 'ALL')
                    ORDER BY stag_object_id) LOOP
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          ,    'Table:'
            || dwhutl_stag_ddl.g_vc_owner_stg
            || '.'
            || r_obj.stag_hist_table_name
          , 'Start building objects'
         );
         -- Set name of the backup table
         l_vc_table_name_bkp :=
            SUBSTR (
                  r_obj.stag_hist_table_name
               || '_BKP'
             , 1
             , 30
            );

         SELECT COUNT (0)
           INTO l_n_cnt
           FROM all_tables
          WHERE owner = dwhutl_stag_ddl.g_vc_owner_stg
            AND table_name = l_vc_table_name_bkp;

         IF l_n_cnt > 0 THEN
            raise_application_error (
               -20000
             , 'Backup table already present'
            );
         END IF;

         -- Reset list strings
         l_vc_stage_db_list := '';
         l_vc_distr_code_list := '';
         l_vc_col_def := '';
         l_vc_col_pk := '';

         -- Build list of values for objects with multiple sources
         FOR r_db IN (SELECT stag_source_db_link
                           , stag_source_owner
                           , stag_distribution_code
                        FROM dwhutl_stag_source_db_t
                       WHERE stag_source_id = r_obj.stag_source_id) LOOP
            l_vc_stage_db_list :=
                  l_vc_stage_db_list
               || r_db.stag_source_db_link
               || ',';
            l_vc_distr_code_list :=
                  l_vc_distr_code_list
               || r_db.stag_distribution_code
               || ',';
         END LOOP;

         l_vc_stage_db_list :=
            RTRIM (
               l_vc_stage_db_list
             , ','
            );
         l_vc_distr_code_list :=
            RTRIM (
               l_vc_distr_code_list
             , ','
            );

         -- Build list of columns
         FOR r_col IN (  SELECT NVL (stag_column_name_map, stag_column_name) AS stag_column_name
                              , stag_column_def
                              , stag_column_nk_pos
                           FROM dwhutl_stag_column_t
                          WHERE stag_object_id = r_obj.stag_object_id
                            AND stag_column_edwh_flag = 1
                       ORDER BY stag_column_pos) LOOP
            l_vc_col_def :=
                  l_vc_col_def
               || CHR (10)
               || r_col.stag_column_name
               || ' '
               || r_col.stag_column_def
               || ',';

            IF r_col.stag_column_nk_pos IS NOT NULL THEN
               l_vc_col_pk :=
                     l_vc_col_pk
                  || CHR (10)
                  || r_col.stag_column_name
                  || ',';
            END IF;
         END LOOP;

         l_vc_col_def :=
            RTRIM (
               l_vc_col_def
             , ','
            );
         l_vc_col_pk :=
            RTRIM (
               l_vc_col_pk
             , ','
            );
         -- Set main properties for the given object
         dwhutl_stag_ddl.g_n_parallel_degree := r_obj.stag_parallel_degree;
         dwhutl_stag_ddl.g_vc_partition_expr := r_obj.stag_partition_clause;
         dwhutl_stag_ddl.g_vc_table_name_hist := r_obj.stag_hist_table_name;
         dwhutl_stag_ddl.g_vc_view_name_hist := r_obj.stag_hist_view_name;
         dwhutl_stag_ddl.g_vc_nk_name_hist := r_obj.stag_hist_nk_name;
         --
         dwhutl_stag_ddl.g_vc_col_def := l_vc_col_def;
         --
         dwhutl_stag_ddl.g_vc_tablespace_hist_data := r_obj.stag_ts_hist_data;
         dwhutl_stag_ddl.g_vc_tablespace_hist_indx := r_obj.stag_ts_hist_indx;
         --
         dwhutl_stag_ddl.g_l_dblink :=
            dwhutl_type.fct_string_to_list (
               l_vc_stage_db_list
             , ','
            );
         dwhutl_stag_ddl.g_l_distr_code :=
            dwhutl_type.fct_string_to_list (
               l_vc_distr_code_list
             , ','
            );
         dwhutl_stag_ddl.g_vc_col_pk :=
               CASE
                  WHEN dwhutl_stag_ddl.g_l_dblink.COUNT > 1 THEN
                        ' '
                     || dwhutl_stag_param.c_vc_column_source_db
                     || ',  '
               END
            || l_vc_col_pk;

         -- Drop PK and indexes
         FOR r_cst IN (SELECT constraint_name
                         FROM all_constraints
                        WHERE owner = dwhutl_stag_ddl.g_vc_owner_stg
                          AND table_name = r_obj.stag_hist_table_name) LOOP
            --
            l_vc_sql_statement :=
                  'ALTER TABLE '
               || dwhutl_stag_ddl.g_vc_owner_stg
               || '.'
               || r_obj.stag_hist_table_name
               || ' DROP CONSTRAINT '
               || r_cst.constraint_name;
            --
            dwhutl_trac.log_sub_debug (
               l_vc_prc_name
             , 'Drop constraint'
             , l_vc_sql_statement
            );

            --
            EXECUTE IMMEDIATE l_vc_sql_statement;
         --
         END LOOP;

         FOR r_idx IN (SELECT index_name
                         FROM all_indexes
                        WHERE owner = dwhutl_stag_ddl.g_vc_owner_stg
                          AND table_name = r_obj.stag_hist_table_name) LOOP
            --
            l_vc_sql_statement :=
                  'DROP INDEX '
               || dwhutl_stag_ddl.g_vc_owner_stg
               || '.'
               || r_idx.index_name;
            --
            dwhutl_trac.log_sub_debug (
               l_vc_prc_name
             , 'Drop index'
             , l_vc_sql_statement
            );

            --
            EXECUTE IMMEDIATE l_vc_sql_statement;
         --
         END LOOP;

         EXECUTE IMMEDIATE
               'RENAME '
            || r_obj.stag_hist_table_name
            || ' TO '
            || l_vc_table_name_bkp;

         -- Create target object
         dwhutl_stag_ddl.prc_create_hist_table (
            FALSE
          , TRUE
         );
         -- Migrate data
         dwhutl_ddls.prc_migrate_table (
            r_obj.stag_hist_table_name
          , l_vc_table_name_bkp
         );
         -- Create view or synonym (depending on the environment)
         /*IF param.c_vc_db_name_actual IN (param.c_vc_db_name_dev, param.c_vc_db_name_tst)
         THEN
            dwhutl_stag_ddl.prc_create_stage2_view (TRUE);
         ELSE
            dwhutl_stag_ddl.prc_create_stage2_synonym (TRUE);
         END IF;*/
         dwhutl_trac.log_sub_debug (
            l_vc_prc_name
          ,    'Object '
            || r_obj.stag_object_name
          , 'Finish building db objects'
         );
      END LOOP;

      dwhutl_trac.log_sub_debug (
         l_vc_prc_name
       , 'Build objects'
       , 'Finished building db objects'
      );
      dwhutl_trac.log_sub_info (
         l_vc_prc_name
       , 'Finish'
       , 'Build complete'
      );
   END;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_stag_build;
2014-11-28 13:53:26.119 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_build/stag_build-impl.sql executed
2014-11-28 13:53:26.120 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ctl/stag_ctl-def.sql delimiter 
2014-11-28 13:53:26.122 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stag_ctl
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_queue_ins (
      p_vc_queue_code    VARCHAR2
    , p_vc_queue_name    VARCHAR2
   );

   FUNCTION fct_queue_finished (p_n_queue_id NUMBER)
      RETURN BOOLEAN;

   FUNCTION fct_step_available (p_n_queue_id NUMBER)
      RETURN BOOLEAN;

   PROCEDURE prc_enqueue_object (
      p_vc_queue_code     VARCHAR2
    , p_vc_source_code    VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name    VARCHAR2 DEFAULT 'ALL'
   );

   PROCEDURE prc_enqueue_source (
      p_vc_source_code          VARCHAR2
    , p_n_threshold_tot_rows    NUMBER
   );

   PROCEDURE prc_execute_step (p_n_queue_id NUMBER);

   PROCEDURE prc_execute_queue (p_vc_queue_code VARCHAR2);

   PROCEDURE prc_initialize_queue (p_vc_queue_code VARCHAR2);

   PROCEDURE prc_truncate_stage (p_vc_source_code VARCHAR2);
END p#frm#stag_ctl;
2014-11-28 13:53:26.122 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stag_ctl
   AUTHID CURRENT_USER
AS
   /**
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   PROCEDURE prc_queue_ins (
      p_vc_queue_code    VARCHAR2
    , p_vc_queue_name    VARCHAR2
   );

   FUNCTION fct_queue_finished (p_n_queue_id NUMBER)
      RETURN BOOLEAN;

   FUNCTION fct_step_available (p_n_queue_id NUMBER)
      RETURN BOOLEAN;

   PROCEDURE prc_enqueue_object (
      p_vc_queue_code     VARCHAR2
    , p_vc_source_code    VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name    VARCHAR2 DEFAULT 'ALL'
   );

   PROCEDURE prc_enqueue_source (
      p_vc_source_code          VARCHAR2
    , p_n_threshold_tot_rows    NUMBER
   );

   PROCEDURE prc_execute_step (p_n_queue_id NUMBER);

   PROCEDURE prc_execute_queue (p_vc_queue_code VARCHAR2);

   PROCEDURE prc_initialize_queue (p_vc_queue_code VARCHAR2);

   PROCEDURE prc_truncate_stage (p_vc_source_code VARCHAR2);
END dwhutl_stag_ctl;
2014-11-28 13:53:26.185 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ctl/stag_ctl-def.sql executed
2014-11-28 13:53:26.185 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ctl/stag_ctl-impl.sql delimiter 
2014-11-28 13:53:26.186 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#stag_ctl
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   PROCEDURE prc_queue_ins (
      p_vc_queue_code    VARCHAR2
    , p_vc_queue_name    VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO p#frm#stag_queue_t trg
           USING (SELECT p_vc_queue_code AS queue_code
                       , p_vc_queue_name AS queue_name
                    FROM DUAL) src
              ON (trg.stag_queue_code = src.queue_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_queue_name = src.queue_name
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_queue_code
                     , trg.stag_queue_name
                    )
             VALUES (
                       src.queue_code
                     , src.queue_name
                    );

      COMMIT;
   END prc_queue_ins;

   FUNCTION fct_queue_finished (p_n_queue_id NUMBER)
      RETURN BOOLEAN
   IS
      l_n_step_status_min   NUMBER;
   BEGIN
      SELECT MIN (etl_step_status)
        INTO l_n_step_status_min
        FROM p#frm#stag_queue_object_t
       WHERE stag_queue_id = p_n_queue_id;

      IF l_n_step_status_min > 0 THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_queue_finished;

   FUNCTION fct_step_available (p_n_queue_id NUMBER)
      RETURN BOOLEAN
   IS
      l_n_step_cnt   NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_n_step_cnt
        FROM p#frm#stag_queue_object_t
       WHERE etl_step_status = 0
         AND stag_queue_id = p_n_queue_id;

      IF l_n_step_cnt > 0 THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_step_available;

   PROCEDURE prc_enqueue_object (
      p_vc_queue_code     VARCHAR2
    , p_vc_source_code    VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name    VARCHAR2 DEFAULT 'ALL'
   )
   IS
      l_n_result    NUMBER;
      l_n_di_gui    NUMBER;
      l_n_step_no   NUMBER;
   BEGIN
      p#frm#trac.log_info (
         'Enqueue all objects'
       , 'Enqueue Begin'
      );

      DELETE p#frm#stag_queue_object_t
       WHERE stag_queue_id IN (SELECT stag_queue_id
                                 FROM p#frm#stag_queue_t
                                WHERE stag_queue_code = p_vc_queue_code)
         AND stag_object_id IN (SELECT o.stag_object_id
                                  FROM p#frm#stag_object_t o
                                     , p#frm#stag_source_t s
                                 WHERE o.stag_source_id = s.stag_source_id
                                   AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                                   AND p_vc_object_name IN (o.stag_object_name, 'ALL'));

      INSERT INTO p#frm#stag_queue_object_t (
                     stag_queue_id
                   , stag_object_id
                   , etl_step_status
                  )
         SELECT q.stag_queue_id
              , o.stag_object_id
              , 0
           FROM p#frm#stag_object_t o
              , p#frm#stag_source_t s
              , p#frm#stag_queue_t q
          WHERE o.stag_source_id = s.stag_source_id
            AND q.stag_queue_code = p_vc_queue_code
            AND p_vc_source_code IN (s.stag_source_code, 'ALL')
            AND p_vc_object_name IN (o.stag_object_name, 'ALL');

      COMMIT;
      p#frm#trac.log_info (
         'Enqueue all objects'
       , 'Enqueue End'
      );
   END prc_enqueue_object;

   PROCEDURE prc_enqueue_source (
      p_vc_source_code          VARCHAR2
    , p_n_threshold_tot_rows    NUMBER
   )
   IS
      l_n_tot_rows                 NUMBER := 0;
      l_n_tot_rows_next_theshold   NUMBER := 0;
      l_n_queue_order              NUMBER := 0;
      l_vc_queue_code              VARCHAR2 (10);
   BEGIN
      l_n_tot_rows_next_theshold := p_n_threshold_tot_rows;

      SELECT NVL (
                  MAX (LTRIM (
                          stag_queue_code
                        , p_vc_source_code
                       ))
                + 1
              , 0
             )
        INTO l_n_queue_order
        FROM p#frm#stag_queue_t
       WHERE stag_queue_code LIKE
                   p_vc_source_code
                || '%';

      l_vc_queue_code :=
            p_vc_source_code
         || TRIM (TO_CHAR (
                     l_n_queue_order
                   , '000'
                  ));
      prc_queue_ins (
         l_vc_queue_code
       , l_vc_queue_code
      );

      -- Order objects according to size in rows
      FOR r_obj IN (  SELECT o.stag_object_name
                           , t.num_rows
                        FROM p#frm#stag_object_v o
                           , user_tables t
                       WHERE o.stag_hist_table_name = t.table_name
                         AND stag_source_code = p_vc_source_code
                    ORDER BY t.num_rows) LOOP
         l_n_tot_rows :=
              l_n_tot_rows
            + r_obj.num_rows;

         -- If the threshold size is overtaken, then set next threshold and next queue
         IF l_n_tot_rows >= l_n_tot_rows_next_theshold THEN
            l_n_tot_rows_next_theshold :=
                 l_n_tot_rows_next_theshold
               + p_n_threshold_tot_rows;
            l_n_queue_order :=
                 l_n_queue_order
               + 1;
            l_vc_queue_code :=
                  p_vc_source_code
               || TRIM (TO_CHAR (
                           l_n_queue_order
                         , '000'
                        ));
            prc_queue_ins (
               l_vc_queue_code
             , l_vc_queue_code
            );
         END IF;

         prc_enqueue_object (
            l_vc_queue_code
          , p_vc_source_code
          , r_obj.stag_object_name
         );
      END LOOP;
   END prc_enqueue_source;

   PROCEDURE prc_execute_step (p_n_queue_id NUMBER)
   IS
      l_vc_prc_name         t_object_name := 'prc_execute_step';
      l_n_object_id         NUMBER;
      l_vc_owner            t_object_name;
      l_vc_object           t_object_name;
      l_vc_package          t_object_name;
      l_vc_std_load_modus   t_object_name;
   BEGIN
      p#frm#trac.log_info (
            'Queue '
         || p_n_queue_id
         || ': Step Begin'
       ,    'Stream '
         || p_n_queue_id
         || ': Step Begin'
      );

      EXECUTE IMMEDIATE 'LOCK TABLE stag_queue_object_t IN EXCLUSIVE MODE WAIT 10';

         UPDATE p#frm#stag_queue_object_t
            SET etl_step_status = 1
              , etl_step_session_id =
                   SYS_CONTEXT (
                      'USERENV'
                    , 'SESSIONID'
                   )
              , etl_step_begin_date = SYSDATE
          WHERE stag_queue_object_id = (SELECT MIN (stag_queue_object_id)
                                          FROM p#frm#stag_queue_object_t
                                         WHERE etl_step_status = 0
                                           AND stag_queue_id = p_n_queue_id)
      RETURNING stag_object_id
           INTO l_n_object_id;

      COMMIT;

      IF l_n_object_id IS NULL THEN
         p#frm#trac.log_info (
               'Queue '
            || p_n_queue_id
            || ': No steps available in queue'
          ,    'Queue '
            || p_n_queue_id
            || ': Nothing to do'
         );
      ELSE
         SELECT s.stag_owner
              , o.stag_object_name
              , o.stag_package_name
           INTO l_vc_owner
              , l_vc_object
              , l_vc_package
           FROM p#frm#stag_source_t s
              , p#frm#stag_object_t o
          WHERE s.stag_source_id = o.stag_source_id
            AND o.stag_object_id = l_n_object_id;

         p#frm#trac.log_info (
            'Execute procedure '
          ,    'Stream '
            || p_n_queue_id
            || ': '
         );
         l_vc_prc_name :=
               l_vc_package
            || CASE
                  WHEN l_vc_std_load_modus = 'D' THEN
                        '.'
                     || p#frm#stag_param.c_vc_procedure_wrapper_incr
                  ELSE
                        '.'
                     || p#frm#stag_param.c_vc_procedure_wrapper
               END;
         p#frm#trac.log_info (
               'o='
            || l_n_object_id
            || ' prc='
            || l_vc_prc_name
          ,    'Queue '
            || p_n_queue_id
         );

         BEGIN
            EXECUTE IMMEDIATE
                  'BEGIN '
               || l_vc_prc_name
               || '; END;';

            p#frm#trac.log_info (
                  'Queue '
               || p_n_queue_id
               || ': Step executed'
             ,    'Queue '
               || p_n_queue_id
               || ': Step executed'
            );

            UPDATE p#frm#stag_queue_object_t
               SET etl_step_status = 2
                 , etl_step_end_date = SYSDATE
             WHERE stag_object_id = l_n_object_id;
         EXCEPTION
            WHEN OTHERS THEN
               p#frm#trac.log_info (
                     'Queue '
                  || p_n_queue_id
                  || ': Error'
                ,    'Queue '
                  || p_n_queue_id
                  || ': Error'
               );

               UPDATE p#frm#stag_queue_object_t
                  SET etl_step_status = 3
                    , etl_step_end_date = SYSDATE
                WHERE stag_object_id = l_n_object_id;
         END;

         COMMIT;
         p#frm#trac.log_info (
               'Queue '
            || p_n_queue_id
            || ': End'
          ,    'Queue '
            || p_n_queue_id
            || ': End'
         );
      END IF;
   END prc_execute_step;

   PROCEDURE prc_execute_queue (p_vc_queue_code VARCHAR2)
   IS
      l_n_out        NUMBER;
      l_n_di_gui     NUMBER;
      l_n_step_no    NUMBER;
      l_n_queue_id   NUMBER;
   BEGIN
      --p#frm#stag_stat.prc_set_load_id;
      SELECT MAX (stag_queue_id)
        INTO l_n_queue_id
        FROM p#frm#stag_queue_t
       WHERE stag_queue_code = p_vc_queue_code;

      IF l_n_queue_id IS NOT NULL THEN
         p#frm#trac.log_info (
            'Execute single steps'
          , 'Queue Begin'
         );

         WHILE fct_queue_finished (l_n_queue_id) = FALSE LOOP
            IF fct_step_available (l_n_queue_id) = TRUE THEN
               p#frm#trac.log_info (
                  'Execute next available step'
                , 'Step Begin'
               );
               prc_execute_step (l_n_queue_id);
               p#frm#trac.log_info (
                  'Step executed'
                , 'Step End'
               );
            END IF;
         END LOOP;

         p#frm#trac.log_info (
            'No more steps to execute'
          , 'Stream End'
         );
      ELSE
         p#frm#trac.log_info (
               'Queue '
            || p_vc_queue_code
            || ' doesn''t exist'
          , 'Queue End'
         );
      END IF;
   END prc_execute_queue;

   PROCEDURE prc_truncate_stage (p_vc_source_code VARCHAR2)
   IS
   BEGIN
      FOR r_obj IN (SELECT stag_package_name
                      FROM p#frm#stag_object_v
                     WHERE stag_source_code = p_vc_source_code) LOOP
         EXECUTE IMMEDIATE
               'BEGIN '
            || r_obj.stag_package_name
            || '.prc_trunc_stage1; END;';
      END LOOP;
   END;

   PROCEDURE prc_initialize_queue (p_vc_queue_code VARCHAR2)
   IS
   BEGIN
      UPDATE p#frm#stag_queue_object_t
         SET etl_step_status = 0
           , etl_step_session_id = NULL
           , etl_step_begin_date = NULL
           , etl_step_end_date = NULL
       WHERE stag_queue_id IN (SELECT stag_queue_id
                                 FROM p#frm#stag_queue_t
                                WHERE stag_queue_code = p_vc_queue_code);

      COMMIT;
   END prc_initialize_queue;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#stag_ctl;
2014-11-28 13:53:26.187 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_stag_ctl
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   PROCEDURE prc_queue_ins (
      p_vc_queue_code    VARCHAR2
    , p_vc_queue_name    VARCHAR2
   )
   IS
   BEGIN
      MERGE INTO dwhutl_stag_queue_t trg
           USING (SELECT p_vc_queue_code AS queue_code
                       , p_vc_queue_name AS queue_name
                    FROM DUAL) src
              ON (trg.stag_queue_code = src.queue_code)
      WHEN MATCHED THEN
         UPDATE SET trg.stag_queue_name = src.queue_name
      WHEN NOT MATCHED THEN
         INSERT     (
                       trg.stag_queue_code
                     , trg.stag_queue_name
                    )
             VALUES (
                       src.queue_code
                     , src.queue_name
                    );

      COMMIT;
   END prc_queue_ins;

   FUNCTION fct_queue_finished (p_n_queue_id NUMBER)
      RETURN BOOLEAN
   IS
      l_n_step_status_min   NUMBER;
   BEGIN
      SELECT MIN (etl_step_status)
        INTO l_n_step_status_min
        FROM dwhutl_stag_queue_object_t
       WHERE stag_queue_id = p_n_queue_id;

      IF l_n_step_status_min > 0 THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_queue_finished;

   FUNCTION fct_step_available (p_n_queue_id NUMBER)
      RETURN BOOLEAN
   IS
      l_n_step_cnt   NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO l_n_step_cnt
        FROM dwhutl_stag_queue_object_t
       WHERE etl_step_status = 0
         AND stag_queue_id = p_n_queue_id;

      IF l_n_step_cnt > 0 THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_step_available;

   PROCEDURE prc_enqueue_object (
      p_vc_queue_code     VARCHAR2
    , p_vc_source_code    VARCHAR2 DEFAULT 'ALL'
    , p_vc_object_name    VARCHAR2 DEFAULT 'ALL'
   )
   IS
      l_n_result    NUMBER;
      l_n_di_gui    NUMBER;
      l_n_step_no   NUMBER;
   BEGIN
      dwhutl_trac.log_info (
         'Enqueue all objects'
       , 'Enqueue Begin'
      );

      DELETE dwhutl_stag_queue_object_t
       WHERE stag_queue_id IN (SELECT stag_queue_id
                                 FROM dwhutl_stag_queue_t
                                WHERE stag_queue_code = p_vc_queue_code)
         AND stag_object_id IN (SELECT o.stag_object_id
                                  FROM dwhutl_stag_object_t o
                                     , dwhutl_stag_source_t s
                                 WHERE o.stag_source_id = s.stag_source_id
                                   AND p_vc_source_code IN (s.stag_source_code, 'ALL')
                                   AND p_vc_object_name IN (o.stag_object_name, 'ALL'));

      INSERT INTO dwhutl_stag_queue_object_t (
                     stag_queue_id
                   , stag_object_id
                   , etl_step_status
                  )
         SELECT q.stag_queue_id
              , o.stag_object_id
              , 0
           FROM dwhutl_stag_object_t o
              , dwhutl_stag_source_t s
              , dwhutl_stag_queue_t q
          WHERE o.stag_source_id = s.stag_source_id
            AND q.stag_queue_code = p_vc_queue_code
            AND p_vc_source_code IN (s.stag_source_code, 'ALL')
            AND p_vc_object_name IN (o.stag_object_name, 'ALL');

      COMMIT;
      dwhutl_trac.log_info (
         'Enqueue all objects'
       , 'Enqueue End'
      );
   END prc_enqueue_object;

   PROCEDURE prc_enqueue_source (
      p_vc_source_code          VARCHAR2
    , p_n_threshold_tot_rows    NUMBER
   )
   IS
      l_n_tot_rows                 NUMBER := 0;
      l_n_tot_rows_next_theshold   NUMBER := 0;
      l_n_queue_order              NUMBER := 0;
      l_vc_queue_code              VARCHAR2 (10);
   BEGIN
      l_n_tot_rows_next_theshold := p_n_threshold_tot_rows;

      SELECT NVL (
                  MAX (LTRIM (
                          stag_queue_code
                        , p_vc_source_code
                       ))
                + 1
              , 0
             )
        INTO l_n_queue_order
        FROM dwhutl_stag_queue_t
       WHERE stag_queue_code LIKE
                   p_vc_source_code
                || '%';

      l_vc_queue_code :=
            p_vc_source_code
         || TRIM (TO_CHAR (
                     l_n_queue_order
                   , '000'
                  ));
      prc_queue_ins (
         l_vc_queue_code
       , l_vc_queue_code
      );

      -- Order objects according to size in rows
      FOR r_obj IN (  SELECT o.stag_object_name
                           , t.num_rows
                        FROM dwhutl_stag_object_v o
                           , user_tables t
                       WHERE o.stag_hist_table_name = t.table_name
                         AND stag_source_code = p_vc_source_code
                    ORDER BY t.num_rows) LOOP
         l_n_tot_rows :=
              l_n_tot_rows
            + r_obj.num_rows;

         -- If the threshold size is overtaken, then set next threshold and next queue
         IF l_n_tot_rows >= l_n_tot_rows_next_theshold THEN
            l_n_tot_rows_next_theshold :=
                 l_n_tot_rows_next_theshold
               + p_n_threshold_tot_rows;
            l_n_queue_order :=
                 l_n_queue_order
               + 1;
            l_vc_queue_code :=
                  p_vc_source_code
               || TRIM (TO_CHAR (
                           l_n_queue_order
                         , '000'
                        ));
            prc_queue_ins (
               l_vc_queue_code
             , l_vc_queue_code
            );
         END IF;

         prc_enqueue_object (
            l_vc_queue_code
          , p_vc_source_code
          , r_obj.stag_object_name
         );
      END LOOP;
   END prc_enqueue_source;

   PROCEDURE prc_execute_step (p_n_queue_id NUMBER)
   IS
      l_vc_prc_name         t_object_name := 'prc_execute_step';
      l_n_object_id         NUMBER;
      l_vc_owner            t_object_name;
      l_vc_object           t_object_name;
      l_vc_package          t_object_name;
      l_vc_std_load_modus   t_object_name;
   BEGIN
      dwhutl_trac.log_info (
            'Queue '
         || p_n_queue_id
         || ': Step Begin'
       ,    'Stream '
         || p_n_queue_id
         || ': Step Begin'
      );

      EXECUTE IMMEDIATE 'LOCK TABLE stag_queue_object_t IN EXCLUSIVE MODE WAIT 10';

         UPDATE dwhutl_stag_queue_object_t
            SET etl_step_status = 1
              , etl_step_session_id =
                   SYS_CONTEXT (
                      'USERENV'
                    , 'SESSIONID'
                   )
              , etl_step_begin_date = SYSDATE
          WHERE stag_queue_object_id = (SELECT MIN (stag_queue_object_id)
                                          FROM dwhutl_stag_queue_object_t
                                         WHERE etl_step_status = 0
                                           AND stag_queue_id = p_n_queue_id)
      RETURNING stag_object_id
           INTO l_n_object_id;

      COMMIT;

      IF l_n_object_id IS NULL THEN
         dwhutl_trac.log_info (
               'Queue '
            || p_n_queue_id
            || ': No steps available in queue'
          ,    'Queue '
            || p_n_queue_id
            || ': Nothing to do'
         );
      ELSE
         SELECT s.stag_owner
              , o.stag_object_name
              , o.stag_package_name
           INTO l_vc_owner
              , l_vc_object
              , l_vc_package
           FROM dwhutl_stag_source_t s
              , dwhutl_stag_object_t o
          WHERE s.stag_source_id = o.stag_source_id
            AND o.stag_object_id = l_n_object_id;

         dwhutl_trac.log_info (
            'Execute procedure '
          ,    'Stream '
            || p_n_queue_id
            || ': '
         );
         l_vc_prc_name :=
               l_vc_package
            || CASE
                  WHEN l_vc_std_load_modus = 'D' THEN
                        '.'
                     || dwhutl_stag_param.c_vc_procedure_wrapper_incr
                  ELSE
                        '.'
                     || dwhutl_stag_param.c_vc_procedure_wrapper
               END;
         dwhutl_trac.log_info (
               'o='
            || l_n_object_id
            || ' prc='
            || l_vc_prc_name
          ,    'Queue '
            || p_n_queue_id
         );

         BEGIN
            EXECUTE IMMEDIATE
                  'BEGIN '
               || l_vc_prc_name
               || '; END;';

            dwhutl_trac.log_info (
                  'Queue '
               || p_n_queue_id
               || ': Step executed'
             ,    'Queue '
               || p_n_queue_id
               || ': Step executed'
            );

            UPDATE dwhutl_stag_queue_object_t
               SET etl_step_status = 2
                 , etl_step_end_date = SYSDATE
             WHERE stag_object_id = l_n_object_id;
         EXCEPTION
            WHEN OTHERS THEN
               dwhutl_trac.log_info (
                     'Queue '
                  || p_n_queue_id
                  || ': Error'
                ,    'Queue '
                  || p_n_queue_id
                  || ': Error'
               );

               UPDATE dwhutl_stag_queue_object_t
                  SET etl_step_status = 3
                    , etl_step_end_date = SYSDATE
                WHERE stag_object_id = l_n_object_id;
         END;

         COMMIT;
         dwhutl_trac.log_info (
               'Queue '
            || p_n_queue_id
            || ': End'
          ,    'Queue '
            || p_n_queue_id
            || ': End'
         );
      END IF;
   END prc_execute_step;

   PROCEDURE prc_execute_queue (p_vc_queue_code VARCHAR2)
   IS
      l_n_out        NUMBER;
      l_n_di_gui     NUMBER;
      l_n_step_no    NUMBER;
      l_n_queue_id   NUMBER;
   BEGIN
      --dwhutl_stag_stat.prc_set_load_id;
      SELECT MAX (stag_queue_id)
        INTO l_n_queue_id
        FROM dwhutl_stag_queue_t
       WHERE stag_queue_code = p_vc_queue_code;

      IF l_n_queue_id IS NOT NULL THEN
         dwhutl_trac.log_info (
            'Execute single steps'
          , 'Queue Begin'
         );

         WHILE fct_queue_finished (l_n_queue_id) = FALSE LOOP
            IF fct_step_available (l_n_queue_id) = TRUE THEN
               dwhutl_trac.log_info (
                  'Execute next available step'
                , 'Step Begin'
               );
               prc_execute_step (l_n_queue_id);
               dwhutl_trac.log_info (
                  'Step executed'
                , 'Step End'
               );
            END IF;
         END LOOP;

         dwhutl_trac.log_info (
            'No more steps to execute'
          , 'Stream End'
         );
      ELSE
         dwhutl_trac.log_info (
               'Queue '
            || p_vc_queue_code
            || ' doesn''t exist'
          , 'Queue End'
         );
      END IF;
   END prc_execute_queue;

   PROCEDURE prc_truncate_stage (p_vc_source_code VARCHAR2)
   IS
   BEGIN
      FOR r_obj IN (SELECT stag_package_name
                      FROM dwhutl_stag_object_v
                     WHERE stag_source_code = p_vc_source_code) LOOP
         EXECUTE IMMEDIATE
               'BEGIN '
            || r_obj.stag_package_name
            || '.prc_trunc_stage1; END;';
      END LOOP;
   END;

   PROCEDURE prc_initialize_queue (p_vc_queue_code VARCHAR2)
   IS
   BEGIN
      UPDATE dwhutl_stag_queue_object_t
         SET etl_step_status = 0
           , etl_step_session_id = NULL
           , etl_step_begin_date = NULL
           , etl_step_end_date = NULL
       WHERE stag_queue_id IN (SELECT stag_queue_id
                                 FROM dwhutl_stag_queue_t
                                WHERE stag_queue_code = p_vc_queue_code);

      COMMIT;
   END prc_initialize_queue;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_stag_ctl;
2014-11-28 13:53:26.369 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stag_ctl/stag_ctl-impl.sql executed
2014-11-28 13:53:26.370 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_stat_type_data.sql delimiter 
2014-11-28 13:53:26.372 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
BEGIN
	p#frm#stag_meta.prc_stat_type_ins ( 'STIN', 'INSERT STAGE', 'Extract rows from source into stage table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'STAN', 'ANALYZE', 'Analyze stage table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'DUIN', 'INSERT DIFFERENCE', 'Get Source-Target difference into the diff table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'DUAN', 'ANALYZE', 'Analyze diff table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'DFIN', 'INSERT DIFFERENCE', 'Get Source-Target difference into the diff table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'DFAN', 'ANALYZE', 'Analyze diff table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'HSCL', 'CLOSE HISTORY', 'Close validity of old and deleted records') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'HSUP', 'UPDATE HISTORY', 'Update hist table with rows from the diff table') ;
	p#frm#stag_meta.prc_stat_type_ins ( 'HSIN', 'INSERT HISTORY', 'Insert in hist table with new rows from the diff table') ;
    p#frm#stag_meta.prc_stat_type_ins ( 'HSAN', 'ANALYZE', 'Analyze hist table') ;
END;
2014-11-28 13:53:26.372 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
BEGIN
	dwhutl_stag_meta.prc_stat_type_ins ( 'STIN', 'INSERT STAGE', 'Extract rows from source into stage table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'STAN', 'ANALYZE', 'Analyze stage table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'DUIN', 'INSERT DIFFERENCE', 'Get Source-Target difference into the diff table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'DUAN', 'ANALYZE', 'Analyze diff table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'DFIN', 'INSERT DIFFERENCE', 'Get Source-Target difference into the diff table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'DFAN', 'ANALYZE', 'Analyze diff table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'HSCL', 'CLOSE HISTORY', 'Close validity of old and deleted records') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'HSUP', 'UPDATE HISTORY', 'Update hist table with rows from the diff table') ;
	dwhutl_stag_meta.prc_stat_type_ins ( 'HSIN', 'INSERT HISTORY', 'Insert in hist table with new rows from the diff table') ;
    dwhutl_stag_meta.prc_stat_type_ins ( 'HSAN', 'ANALYZE', 'Analyze hist table') ;
END;
2014-11-28 13:53:26.456 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script tables/stag_stat_type_data.sql executed
2014-11-28 13:53:26.456 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Module all installed
2014-11-28 13:53:26.456 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Closing connection
2014-11-28 13:53:26.463 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Closed connection
2014-11-28 13:53:26.463 [main] INFO  org.openbusinessintelligence.cli.Main - Framework installed
2014-11-28 13:53:26.463 [main] INFO  org.openbusinessintelligence.cli.Main - FINISH
2014-11-28 13:53:26.463 [main] INFO  org.openbusinessintelligence.cli.Main - ###################################################################
2014-11-28 13:56:56.642 [main] INFO  org.openbusinessintelligence.cli.Main - ###################################################################
2014-11-28 13:56:56.644 [main] INFO  org.openbusinessintelligence.cli.Main - START
2014-11-28 13:56:56.644 [main] INFO  org.openbusinessintelligence.cli.Main - Configure command line options
2014-11-28 13:56:56.673 [main] INFO  org.openbusinessintelligence.cli.Main - Options configured
2014-11-28 13:56:56.678 [main] INFO  org.openbusinessintelligence.cli.Main - Install framework
2014-11-28 13:56:56.685 [main] DEBUG org.openbusinessintelligence.cli.Main - dbconnkeywordfile: No such option
2014-11-28 13:56:56.685 [main] DEBUG org.openbusinessintelligence.cli.Main - dbdriverclass: No such option
2014-11-28 13:56:56.685 [main] DEBUG org.openbusinessintelligence.cli.Main - dbconnectionurl: No such option
2014-11-28 13:56:56.685 [main] DEBUG org.openbusinessintelligence.cli.Main - dbusername: No such option
2014-11-28 13:56:56.686 [main] DEBUG org.openbusinessintelligence.cli.Main - dbpassword: No such option
2014-11-28 13:56:56.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Opening connection...
2014-11-28 13:56:56.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Using property file localhost_oracle_dwhdev_dwhadmin_test
2014-11-28 13:56:56.687 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - databaseDriver = oracle.jdbc.OracleDriver
2014-11-28 13:56:56.687 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - connectionURL = jdbc:oracle:thin:@//localhost:1521/dwhdev
2014-11-28 13:56:56.779 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - driver loaded
2014-11-28 13:56:57.490 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Connected to database jdbc:oracle:thin:@//localhost:1521/dwhdev
2014-11-28 13:56:57.491 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Opened connection
2014-11-28 13:56:57.491 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Product: Oracle
2014-11-28 13:56:57.500 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Getting keywords...
2014-11-28 13:56:57.500 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Keywords: ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,ARRAY,AS,ASENSITIVE,ASYMMETRIC,AT,ATOMIC,AUTHORIZATION,BEGIN,BETWEEN,BIGINT,BINARY,BLOB,BOOLEAN,BOTH,BY,CALL,CALLED,CASCADED,CASE,CAST,CHAR,CHARACTER,CHECK,CLOB,CLOSE,COLLATE,COLUMN,COMMIT,CONDITION,CONNECT,CONSTRAINT,CONTINUE,CORRESPONDING,CREATE,CROSS,CUBE,CURRENT,CURRENT_DATE,CURRENT_DEFAULT_TRANSFORM_GROUP,CURRENT_PATH,CURRENT_ROLE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_TRANSFORM_GROUP_FOR_TYPE,CURRENT_USER,CURSOR,CYCLE,DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DELETE,DEREF,DESCRIBE,DETERMINISTIC,DISCONNECT,DISTINCT,DO,DOUBLE,DROP,DYNAMIC,EACH,ELEMENT,ELSE,ELSEIF,END,ESCAPE,EXCEPT,EXEC,EXECUTE,EXISTS,EXIT,EXTERNAL,FETCH,FILTER,FLOAT,FOR,FOREIGN,FREE,FROM,FULL,FUNCTION,GET,GLOBAL,GRANT,GROUP,GROUPING,HANDLER,HAVING,HOLD,HOUR,IDENTITY,IF,IMMEDIATE,IN,INDICATOR,INNER,INOUT,INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ITERATE,JOIN,LANGUAGE,LARGE,LATERAL,LEADING,LEAVE,LEFT,LIKE,LOCAL,LOCALTIME,LOCALTIMESTAMP,LOOP,MATCH,MEMBER,MERGE,METHOD,MINUTE,MODIFIES,MODULE,MONTH,MULTISET,NATIONAL,NATURAL,NCHAR,NCLOB,NEW,NO,NONE,NOT,NULL,NUMERIC,OF,OLD,ON,ONLY,OPEN,OR,ORDER,OUT,OUTER,OUTPUT,OVER,OVERLAPS,PARAMETER,PARTITION,PRECISION,PREPARE,PRIMARY,PROCEDURE,RANGE,READS,REAL,RECURSIVE,REF,REFERENCES,REFERENCING,RELEASE,REPEAT,RESIGNAL,RESULT,RETURN,RETURNS,REVOKE,RIGHT,ROLLBACK,ROLLUP,ROW,ROWS,SAVEPOINT,SCOPE,SCROLL,SEARCH,SECOND,SELECT,SENSITIVE,SESSION_USER,SET,SIGNAL,SIMILAR,SMALLINT,SOME,SPECIFIC,SPECIFICTYPE,SQL,SQLEXCEPTION,SQLSTATE,SQLWARNING,START,STATIC,SUBMULTISET,SYMMETRIC,SYSTEM,SYSTEM_USER,TABLE,TABLESAMPLE,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,TO,TRAILING,TRANSLATION,TREAT,TRIGGER,UNDO,UNION,UNIQUE,UNKNOWN,UNNEST,UNTIL,UPDATE,USER,USING,VALUE,VALUES,VARCHAR,VARYING,WHEN,WHENEVER,WHERE,WHILE,WINDOW,WITH,WITHIN,WITHOUT,YEAR,FALSE,TRUEACCESS, ADD, ALTER, AUDIT, CLUSTER, COLUMN, COMMENT, COMPRESS, CONNECT, DATE, DROP, EXCLUSIVE, FILE, IDENTIFIED, IMMEDIATE, INCREMENT, INDEX, INITIAL, INTERSECT, LEVEL, LOCK, LONG, MAXEXTENTS, MINUS, MODE, NOAUDIT, NOCOMPRESS, NOWAIT, NUMBER, OFFLINE, ONLINE, PCTFREE, PRIOR, all_PL_SQL_reserved_ words
2014-11-28 13:56:57.500 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Getting quote string...
2014-11-28 13:56:57.500 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Quote string: "
2014-11-28 13:56:57.500 [main] DEBUG org.openbusinessintelligence.core.db.ConnectionBean - Getting max row size...
2014-11-28 13:56:57.501 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Max row size: 0
2014-11-28 13:56:57.501 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ########################################
2014-11-28 13:56:57.501 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Found catalogs:
2014-11-28 13:56:57.635 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ########################################
2014-11-28 13:56:57.636 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Found schemas:
2014-11-28 13:56:57.643 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ANONYMOUS
2014-11-28 13:56:57.643 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - APEX_040200
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - APEX_PUBLIC_USER
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - APPQOSSYS
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - AUDSYS
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - COGNOSDM
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - CTXSYS
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DBSNMP
2014-11-28 13:56:57.644 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DIP
2014-11-28 13:56:57.645 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DVF
2014-11-28 13:56:57.650 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DVSYS
2014-11-28 13:56:57.650 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DWHADMIN
2014-11-28 13:56:57.650 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DWHADMIN_TEST
2014-11-28 13:56:57.650 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DWHREPORT
2014-11-28 13:56:57.650 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DWHSTAGE
2014-11-28 13:56:57.651 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - FLOWS_FILES
2014-11-28 13:56:57.651 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - GSMADMIN_INTERNAL
2014-11-28 13:56:57.651 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - GSMCATUSER
2014-11-28 13:56:57.651 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - GSMUSER
2014-11-28 13:56:57.651 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - LBACSYS
2014-11-28 13:56:57.655 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - MDDATA
2014-11-28 13:56:57.655 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - MDSYS
2014-11-28 13:56:57.656 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - OJVMSYS
2014-11-28 13:56:57.656 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - OLAPSYS
2014-11-28 13:56:57.656 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ORACLE_OCM
2014-11-28 13:56:57.656 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ORDDATA
2014-11-28 13:56:57.656 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ORDPLUGINS
2014-11-28 13:56:57.656 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ORDSYS
2014-11-28 13:56:57.658 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - OUTLN
2014-11-28 13:56:57.659 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SCOTT
2014-11-28 13:56:57.662 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SI_INFORMTN_SCHEMA
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SPATIAL_CSW_ADMIN_USR
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SPATIAL_WFS_ADMIN_USR
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SUGARCRM
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SYS
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SYSBACKUP
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SYSDG
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SYSKM
2014-11-28 13:56:57.663 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - SYSTEM
2014-11-28 13:56:57.664 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - TEST
2014-11-28 13:56:57.667 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - UNIT_TESTS
2014-11-28 13:56:57.668 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - WMSYS
2014-11-28 13:56:57.668 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - XDB
2014-11-28 13:56:57.668 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - XS$NULL
2014-11-28 13:56:57.668 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ########################################
2014-11-28 13:56:57.668 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - Found types:
2014-11-28 13:56:57.685 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - INTERVALDS null
2014-11-28 13:56:57.685 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - INTERVALYM null
2014-11-28 13:56:57.685 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - TIMESTAMP WITH LOCAL TIME ZONE null
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - TIMESTAMP WITH TIME ZONE null
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NCHAR null
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NVARCHAR2 null
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NUMBER (1)
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NUMBER (3)
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NUMBER null
2014-11-28 13:56:57.686 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - LONG RAW null
2014-11-28 13:56:57.693 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - RAW null
2014-11-28 13:56:57.693 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - LONG null
2014-11-28 13:56:57.693 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - CHAR null
2014-11-28 13:56:57.693 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NUMBER null
2014-11-28 13:56:57.694 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NUMBER (10)
2014-11-28 13:56:57.694 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NUMBER (5)
2014-11-28 13:56:57.694 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - FLOAT null
2014-11-28 13:56:57.694 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - REAL null
2014-11-28 13:56:57.694 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - VARCHAR2 null
2014-11-28 13:56:57.694 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DATE null
2014-11-28 13:56:57.698 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - DATE null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - TIMESTAMP null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - STRUCT null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - ARRAY null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - BLOB null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - CLOB null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - REF null
2014-11-28 13:56:57.699 [main] INFO  org.openbusinessintelligence.core.db.ConnectionBean - NCLOB null
2014-11-28 13:56:57.700 [main] DEBUG org.openbusinessintelligence.cli.Main - dbcatalog: No such option
2014-11-28 13:56:57.708 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Found 5 modules
2014-11-28 13:56:57.709 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Found module "tool"
2014-11-28 13:56:57.709 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Installing all module
2014-11-28 13:56:57.709 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/type/type-def.sql delimiter 
2014-11-28 13:56:57.714 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#type
AS
   /**
   * Package containing standard types and type conversion functions
   *
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Dummy test procedure to fix package state issue
   */
   PROCEDURE prc_check_state;

   /**
   * Boolean to Y/N flag
   *
   * @param p_bool     Boolean value
   * @return           'Y' or 'N'
   */
   FUNCTION fct_bool_to_flag (p_bool BOOLEAN)
      RETURN CHAR;

   /**
   * Y/N to boolean
   *
   * @param p_char     'Y' or 'N'
   * @return           Boolean value
   */
   FUNCTION fct_flag_to_bool (p_char CHAR)
      RETURN BOOLEAN;

   /**
   * Boolean to Y/N flag
   *
   * @param p_bool     Boolean value
   * @return           Input value as string
   */
   FUNCTION fct_bool_to_string (p_bool BOOLEAN)
      RETURN VARCHAR2;

   /**
   * Y/N to boolean
   *
   * @param p_str      'TRUE' or 'FALSE' as a string
   * @return           Boolean value
   */
   FUNCTION fct_string_to_bool (p_str VARCHAR2)
      RETURN BOOLEAN;

   /**
   * Convert a VARCHAR2S text list to a clob
   *
   * @param p_str_list   List of strings
   * @return             Clob containing the formatted list
   */
   FUNCTION fct_list_to_clob (
      p_str_list      DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN CLOB;

   /**
   * Convert a CLOB text to a VARCHAR2S array, use line breaks to separate the rows
   *
   * @param p_cclob       Input clob
   * @param p_vc_separer  Separer string
   * @return              list containing the formatted content of the clob
   */
   FUNCTION fct_clob_to_list (
      p_cclob         CLOB
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s;

   /**
   * Convert a VARCHAR text to a VARCHAR2S array, use line breaks to separate the rows
   *
   * @param p_vcstring   Input string
   * @param p_vc_separer  Separer string
   * @return             List containing the formatted list
   */
   FUNCTION fct_string_to_list (
      p_vcstring      VARCHAR2
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s;

   /**
   * Convert a VARCHAR2S array to a VARCHAR2 string, use line breaks to separate the rows
   *
   * @param p_vcstring   Input list
   * @param p_vc_separer  Separer string
   * @return             String containing the formatted list
   */
   FUNCTION fct_list_to_string (
      p_vc2string     DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2;

   /**
   * Format VARCHAR2S for debug output
   *
   * @param p_str_array  Array of strings
   * @return             String containing the formatted list
   */
   FUNCTION fct_format_str_array (p_str_array DBMS_SQL.varchar2s)
      RETURN VARCHAR2;

   /**
   * Get max line length
   *
   * @param p_vcstring       String to check
   * @return                 Line length
   */
   FUNCTION fct_get_max_line_length (p_vcstring VARCHAR2)
      RETURN INTEGER;
END p#frm#type;
2014-11-28 13:56:57.715 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_type
AS
   /**
   * Package containing standard types and type conversion functions
   *
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Dummy test procedure to fix package state issue
   */
   PROCEDURE prc_check_state;

   /**
   * Boolean to Y/N flag
   *
   * @param p_bool     Boolean value
   * @return           'Y' or 'N'
   */
   FUNCTION fct_bool_to_flag (p_bool BOOLEAN)
      RETURN CHAR;

   /**
   * Y/N to boolean
   *
   * @param p_char     'Y' or 'N'
   * @return           Boolean value
   */
   FUNCTION fct_flag_to_bool (p_char CHAR)
      RETURN BOOLEAN;

   /**
   * Boolean to Y/N flag
   *
   * @param p_bool     Boolean value
   * @return           Input value as string
   */
   FUNCTION fct_bool_to_string (p_bool BOOLEAN)
      RETURN VARCHAR2;

   /**
   * Y/N to boolean
   *
   * @param p_str      'TRUE' or 'FALSE' as a string
   * @return           Boolean value
   */
   FUNCTION fct_string_to_bool (p_str VARCHAR2)
      RETURN BOOLEAN;

   /**
   * Convert a VARCHAR2S text list to a clob
   *
   * @param p_str_list   List of strings
   * @return             Clob containing the formatted list
   */
   FUNCTION fct_list_to_clob (
      p_str_list      DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN CLOB;

   /**
   * Convert a CLOB text to a VARCHAR2S array, use line breaks to separate the rows
   *
   * @param p_cclob       Input clob
   * @param p_vc_separer  Separer string
   * @return              list containing the formatted content of the clob
   */
   FUNCTION fct_clob_to_list (
      p_cclob         CLOB
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s;

   /**
   * Convert a VARCHAR text to a VARCHAR2S array, use line breaks to separate the rows
   *
   * @param p_vcstring   Input string
   * @param p_vc_separer  Separer string
   * @return             List containing the formatted list
   */
   FUNCTION fct_string_to_list (
      p_vcstring      VARCHAR2
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s;

   /**
   * Convert a VARCHAR2S array to a VARCHAR2 string, use line breaks to separate the rows
   *
   * @param p_vcstring   Input list
   * @param p_vc_separer  Separer string
   * @return             String containing the formatted list
   */
   FUNCTION fct_list_to_string (
      p_vc2string     DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2;

   /**
   * Format VARCHAR2S for debug output
   *
   * @param p_str_array  Array of strings
   * @return             String containing the formatted list
   */
   FUNCTION fct_format_str_array (p_str_array DBMS_SQL.varchar2s)
      RETURN VARCHAR2;

   /**
   * Get max line length
   *
   * @param p_vcstring       String to check
   * @return                 Line length
   */
   FUNCTION fct_get_max_line_length (p_vcstring VARCHAR2)
      RETURN INTEGER;
END dwhutl_type;
2014-11-28 13:56:57.982 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/type/type-def.sql executed
2014-11-28 13:56:57.982 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/type/type-impl.sql delimiter 
2014-11-28 13:56:57.984 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#type
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Max length of a pl/sql code block
   */
   c_i_max_plsql_length   CONSTANT INTEGER := 32000;
   /**
   * Length of a varchar2s row
   */
   c_i_max_vc2s_length    CONSTANT INTEGER := 255;

   /**
   * String type for PL/SQL statements
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   PROCEDURE prc_check_state
   IS
   BEGIN
      NULL;
   END prc_check_state;

   FUNCTION fct_bool_to_flag (p_bool BOOLEAN)
      RETURN CHAR
   IS
      v_yn   CHAR;
   BEGIN
      v_yn :=
         CASE p_bool
            WHEN TRUE THEN
               'Y'
            WHEN FALSE THEN
               'N'
            ELSE
               NULL
         END;
      RETURN v_yn;
   END fct_bool_to_flag;

   FUNCTION fct_flag_to_bool (p_char CHAR)
      RETURN BOOLEAN
   IS
      v_bool   BOOLEAN;
   BEGIN
      v_bool :=
         CASE p_char
            WHEN 'Y' THEN
               TRUE
            WHEN 'N' THEN
               FALSE
            ELSE
               NULL
         END;
      RETURN v_bool;
   END fct_flag_to_bool;

   FUNCTION fct_bool_to_string (p_bool BOOLEAN)
      RETURN VARCHAR2
   IS
      v_str   VARCHAR2 (5);
   BEGIN
      v_str :=
         CASE p_bool
            WHEN TRUE THEN
               'TRUE'
            WHEN FALSE THEN
               'FALSE'
            ELSE
               NULL
         END;
      RETURN v_str;
   END fct_bool_to_string;

   FUNCTION fct_string_to_bool (p_str VARCHAR2)
      RETURN BOOLEAN
   IS
      v_bool   BOOLEAN;
   BEGIN
      v_bool :=
         CASE p_str
            WHEN 'TRUE' THEN
               TRUE
            WHEN 'FALSE' THEN
               FALSE
            ELSE
               NULL
         END;
      RETURN v_bool;
   END fct_string_to_bool;

   FUNCTION fct_list_to_clob (
      p_str_list      DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN CLOB
   IS
      v_out_clob   CLOB;
   BEGIN
      IF p_str_list.COUNT > 0 THEN
         FOR i IN p_str_list.FIRST .. p_str_list.LAST LOOP
            IF i > 1 THEN
               v_out_clob :=
                     v_out_clob
                  || p_vc_separer;
            END IF;

            v_out_clob :=
                  v_out_clob
               || p_str_list (i);
         END LOOP;
      END IF;

      RETURN v_out_clob;
   END fct_list_to_clob;

   FUNCTION fct_clob_to_list (
      p_cclob         CLOB
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s
   IS
      v_cclob      CLOB;
      v_vcline     t_string;
      v_ilf        INTEGER;
      v_out_list   DBMS_SQL.varchar2s;
   BEGIN
      -- eliminate CHAR(13) chars, keep only CHAR(10)
      v_cclob :=
         REPLACE (
            p_cclob
          , CHR (13)
         );

      LOOP
         v_ilf :=
            NVL (
               INSTR (
                  v_cclob
                , p_vc_separer
               )
             , 0
            );

         IF v_ilf = 0 THEN
            v_vcline := v_cclob;
         ELSE
            v_vcline :=
               SUBSTR (
                  v_cclob
                , 1
                ,   v_ilf
                  - 1
               );
            v_cclob :=
               SUBSTR (
                  v_cclob
                ,   v_ilf
                  + 1
               );
         END IF;

         -- write new line to
         v_out_list (NVL (
                          v_out_list.LAST
                        + 1
                      , 1
                     )) :=
            v_vcline;
         EXIT WHEN v_ilf = 0;
      END LOOP;

      RETURN v_out_list;
   END fct_clob_to_list;

   FUNCTION fct_string_to_list (
      p_vcstring      VARCHAR2
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s
   IS
      v_vcstring   t_string;
      v_vcline     t_string;
      v_ilf        INTEGER;
      v_out_list   DBMS_SQL.varchar2s;
   BEGIN
      -- eliminate CHAR(13) chars, keep only CHAR(10)
      v_vcstring :=
         REPLACE (
            p_vcstring
          , CHR (13)
         );

      LOOP
         v_ilf :=
            NVL (
               INSTR (
                  v_vcstring
                , p_vc_separer
               )
             , 0
            );

         IF v_ilf = 0 THEN
            v_vcline := v_vcstring;
         ELSE
            v_vcline :=
               SUBSTR (
                  v_vcstring
                , 1
                ,   v_ilf
                  - 1
               );
            v_vcstring :=
               SUBSTR (
                  v_vcstring
                ,   v_ilf
                  + 1
               );
         END IF;

         v_out_list (NVL (
                          v_out_list.LAST
                        + 1
                      , 1
                     )) :=
            v_vcline;
         EXIT WHEN v_ilf = 0;
      END LOOP;

      RETURN v_out_list;
   END fct_string_to_list;

   FUNCTION fct_list_to_string (
      p_vc2string     DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2
   IS
      v_max_cnt   INTEGER := 0;
      v_str       t_string;
   BEGIN
      v_max_cnt :=
         FLOOR (  c_i_max_plsql_length
                / (  c_i_max_vc2s_length
                   + 1));

      IF p_vc2string.COUNT > 0 THEN
      FOR idx IN p_vc2string.FIRST .. LEAST(p_vc2string.COUNT
                                           ,v_max_cnt) LOOP
        IF idx > 1 THEN
          v_str := v_str || p_vc_separer;
        END IF;

        v_str := v_str || p_vc2string(idx);
      END LOOP;
      END IF;

      RETURN v_str;
   END fct_list_to_string;

   FUNCTION fct_format_str_array (p_str_array DBMS_SQL.varchar2s)
      RETURN VARCHAR2
   IS
      v_max_cnt   INTEGER := 0;
      v_str       t_string;
   BEGIN
      v_max_cnt :=
         FLOOR (  c_i_max_plsql_length
                / (  c_i_max_vc2s_length
                   + 1));

      IF p_str_array.COUNT > 0 THEN
      FOR idx IN p_str_array.FIRST .. LEAST(p_str_array.COUNT
                                           ,v_max_cnt) LOOP
        v_str := v_str || p_str_array(idx) || CHR(10);
      END LOOP;
      END IF;

      RETURN v_str;
   END fct_format_str_array;

   -- get max line length
   FUNCTION fct_get_max_line_length (p_vcstring VARCHAR2)
      RETURN INTEGER
   IS
      v_vcstring   t_string;
      v_vcline     t_string;
      v_ilf        INTEGER;
      v_imaxlen    INTEGER := 0;
   BEGIN
      -- eliminate CHAR(13) chars, keep only CHAR(10)
      v_vcstring :=
         REPLACE (
            p_vcstring
          , CHR (13)
         );

      LOOP
         v_ilf :=
            NVL (
               INSTR (
                  v_vcstring
                , CHR (10)
               )
             , 0
            );

         IF v_ilf = 0 THEN
            v_vcline := v_vcstring;
         ELSE
            v_vcline :=
               SUBSTR (
                  v_vcstring
                , 1
                ,   v_ilf
                  - 1
               );
            v_vcstring :=
               SUBSTR (
                  v_vcstring
                ,   v_ilf
                  + 1
               );
         END IF;

         -- preserve the maximum line length
         v_imaxlen :=
            GREATEST (
               v_imaxlen
             , NVL (LENGTH (v_vcline), 0)
            );
         EXIT WHEN v_ilf = 0;
      END LOOP;

      RETURN v_imaxlen;
   END fct_get_max_line_length;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#type;
2014-11-28 13:56:57.985 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_type
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Max length of a pl/sql code block
   */
   c_i_max_plsql_length   CONSTANT INTEGER := 32000;
   /**
   * Length of a varchar2s row
   */
   c_i_max_vc2s_length    CONSTANT INTEGER := 255;

   /**
   * String type for PL/SQL statements
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   PROCEDURE prc_check_state
   IS
   BEGIN
      NULL;
   END prc_check_state;

   FUNCTION fct_bool_to_flag (p_bool BOOLEAN)
      RETURN CHAR
   IS
      v_yn   CHAR;
   BEGIN
      v_yn :=
         CASE p_bool
            WHEN TRUE THEN
               'Y'
            WHEN FALSE THEN
               'N'
            ELSE
               NULL
         END;
      RETURN v_yn;
   END fct_bool_to_flag;

   FUNCTION fct_flag_to_bool (p_char CHAR)
      RETURN BOOLEAN
   IS
      v_bool   BOOLEAN;
   BEGIN
      v_bool :=
         CASE p_char
            WHEN 'Y' THEN
               TRUE
            WHEN 'N' THEN
               FALSE
            ELSE
               NULL
         END;
      RETURN v_bool;
   END fct_flag_to_bool;

   FUNCTION fct_bool_to_string (p_bool BOOLEAN)
      RETURN VARCHAR2
   IS
      v_str   VARCHAR2 (5);
   BEGIN
      v_str :=
         CASE p_bool
            WHEN TRUE THEN
               'TRUE'
            WHEN FALSE THEN
               'FALSE'
            ELSE
               NULL
         END;
      RETURN v_str;
   END fct_bool_to_string;

   FUNCTION fct_string_to_bool (p_str VARCHAR2)
      RETURN BOOLEAN
   IS
      v_bool   BOOLEAN;
   BEGIN
      v_bool :=
         CASE p_str
            WHEN 'TRUE' THEN
               TRUE
            WHEN 'FALSE' THEN
               FALSE
            ELSE
               NULL
         END;
      RETURN v_bool;
   END fct_string_to_bool;

   FUNCTION fct_list_to_clob (
      p_str_list      DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN CLOB
   IS
      v_out_clob   CLOB;
   BEGIN
      IF p_str_list.COUNT > 0 THEN
         FOR i IN p_str_list.FIRST .. p_str_list.LAST LOOP
            IF i > 1 THEN
               v_out_clob :=
                     v_out_clob
                  || p_vc_separer;
            END IF;

            v_out_clob :=
                  v_out_clob
               || p_str_list (i);
         END LOOP;
      END IF;

      RETURN v_out_clob;
   END fct_list_to_clob;

   FUNCTION fct_clob_to_list (
      p_cclob         CLOB
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s
   IS
      v_cclob      CLOB;
      v_vcline     t_string;
      v_ilf        INTEGER;
      v_out_list   DBMS_SQL.varchar2s;
   BEGIN
      -- eliminate CHAR(13) chars, keep only CHAR(10)
      v_cclob :=
         REPLACE (
            p_cclob
          , CHR (13)
         );

      LOOP
         v_ilf :=
            NVL (
               INSTR (
                  v_cclob
                , p_vc_separer
               )
             , 0
            );

         IF v_ilf = 0 THEN
            v_vcline := v_cclob;
         ELSE
            v_vcline :=
               SUBSTR (
                  v_cclob
                , 1
                ,   v_ilf
                  - 1
               );
            v_cclob :=
               SUBSTR (
                  v_cclob
                ,   v_ilf
                  + 1
               );
         END IF;

         -- write new line to
         v_out_list (NVL (
                          v_out_list.LAST
                        + 1
                      , 1
                     )) :=
            v_vcline;
         EXIT WHEN v_ilf = 0;
      END LOOP;

      RETURN v_out_list;
   END fct_clob_to_list;

   FUNCTION fct_string_to_list (
      p_vcstring      VARCHAR2
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN DBMS_SQL.varchar2s
   IS
      v_vcstring   t_string;
      v_vcline     t_string;
      v_ilf        INTEGER;
      v_out_list   DBMS_SQL.varchar2s;
   BEGIN
      -- eliminate CHAR(13) chars, keep only CHAR(10)
      v_vcstring :=
         REPLACE (
            p_vcstring
          , CHR (13)
         );

      LOOP
         v_ilf :=
            NVL (
               INSTR (
                  v_vcstring
                , p_vc_separer
               )
             , 0
            );

         IF v_ilf = 0 THEN
            v_vcline := v_vcstring;
         ELSE
            v_vcline :=
               SUBSTR (
                  v_vcstring
                , 1
                ,   v_ilf
                  - 1
               );
            v_vcstring :=
               SUBSTR (
                  v_vcstring
                ,   v_ilf
                  + 1
               );
         END IF;

         v_out_list (NVL (
                          v_out_list.LAST
                        + 1
                      , 1
                     )) :=
            v_vcline;
         EXIT WHEN v_ilf = 0;
      END LOOP;

      RETURN v_out_list;
   END fct_string_to_list;

   FUNCTION fct_list_to_string (
      p_vc2string     DBMS_SQL.varchar2s
    , p_vc_separer    VARCHAR2 DEFAULT ','
   )
      RETURN VARCHAR2
   IS
      v_max_cnt   INTEGER := 0;
      v_str       t_string;
   BEGIN
      v_max_cnt :=
         FLOOR (  c_i_max_plsql_length
                / (  c_i_max_vc2s_length
                   + 1));

      IF p_vc2string.COUNT > 0 THEN
      FOR idx IN p_vc2string.FIRST .. LEAST(p_vc2string.COUNT
                                           ,v_max_cnt) LOOP
        IF idx > 1 THEN
          v_str := v_str || p_vc_separer;
        END IF;

        v_str := v_str || p_vc2string(idx);
      END LOOP;
      END IF;

      RETURN v_str;
   END fct_list_to_string;

   FUNCTION fct_format_str_array (p_str_array DBMS_SQL.varchar2s)
      RETURN VARCHAR2
   IS
      v_max_cnt   INTEGER := 0;
      v_str       t_string;
   BEGIN
      v_max_cnt :=
         FLOOR (  c_i_max_plsql_length
                / (  c_i_max_vc2s_length
                   + 1));

      IF p_str_array.COUNT > 0 THEN
      FOR idx IN p_str_array.FIRST .. LEAST(p_str_array.COUNT
                                           ,v_max_cnt) LOOP
        v_str := v_str || p_str_array(idx) || CHR(10);
      END LOOP;
      END IF;

      RETURN v_str;
   END fct_format_str_array;

   -- get max line length
   FUNCTION fct_get_max_line_length (p_vcstring VARCHAR2)
      RETURN INTEGER
   IS
      v_vcstring   t_string;
      v_vcline     t_string;
      v_ilf        INTEGER;
      v_imaxlen    INTEGER := 0;
   BEGIN
      -- eliminate CHAR(13) chars, keep only CHAR(10)
      v_vcstring :=
         REPLACE (
            p_vcstring
          , CHR (13)
         );

      LOOP
         v_ilf :=
            NVL (
               INSTR (
                  v_vcstring
                , CHR (10)
               )
             , 0
            );

         IF v_ilf = 0 THEN
            v_vcline := v_vcstring;
         ELSE
            v_vcline :=
               SUBSTR (
                  v_vcstring
                , 1
                ,   v_ilf
                  - 1
               );
            v_vcstring :=
               SUBSTR (
                  v_vcstring
                ,   v_ilf
                  + 1
               );
         END IF;

         -- preserve the maximum line length
         v_imaxlen :=
            GREATEST (
               v_imaxlen
             , NVL (LENGTH (v_vcline), 0)
            );
         EXIT WHEN v_ilf = 0;
      END LOOP;

      RETURN v_imaxlen;
   END fct_get_max_line_length;
/**
 * Package initialization
 */
BEGIN
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_type;
2014-11-28 13:56:58.071 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/type/type-impl.sql executed
2014-11-28 13:56:58.071 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-def.sql delimiter 
2014-11-28 13:56:58.073 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#dict
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   g_vc_src_obj_owner        t_object_name;
   g_vc_src_obj_dblink       t_object_name;
   /**
   * Generic metadata retrieval statements
   */
   -- PL/SQL block to store metadata in a tmp table.
   c_sql_import_metadata     t_string := 'BEGIN
		DELETE #targetObject#;
			
		INSERT INTO #targetObject# #targetColumns#
					#sourceSelect#;
		COMMIT;
	END;';
   c_sql_tab_part            t_string := 'SELECT COUNT (*)
  FROM all_tab_partitions#dblink#
 WHERE table_owner = :ow
   AND table_name = :tb';
   -- Code token to retrieve all columns of an object and their position inside the pk.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_obj_col_all         t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:p))
     AND table_name = TRIM(UPPER(:p))';
   -- Code token to retrieve pk columns of an object and their position inside the pk.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_obj_col_pk          t_string := 'SELECT tb.object_owner
					 , tb.object_name
					 , cc.column_name
					 , cc.position
				 FROM (SELECT object_owner
								, object_name
								, table_owner
								, table_name
							FROM (SELECT o.owner AS object_owner
										  , o.object_name
										  , CASE
												 WHEN o.object_type = ''VIEW''
													 THEN d.referenced_owner
												 ELSE o.owner
											 END AS table_owner
										  , CASE
												 WHEN o.object_type = ''VIEW''
													 THEN d.referenced_name
												 ELSE o.object_name
											 END AS table_name
										  , COUNT (*) over (PARTITION BY o.owner, o.object_name) AS referenced_cnt
									  FROM all_objects#dblink# o
										  , all_dependencies#dblink# d
									 WHERE o.owner = d.owner(+)
										AND o.object_name = d.name(+)
										AND d.referenced_type(+) = ''TABLE''
										AND o.object_type in (''TABLE'',''VIEW'',''MATERIALIZED VIEW''))
						  WHERE referenced_cnt = 1) tb
					 , all_constraints#dblink# co
					 , all_cons_columns#dblink# cc
				WHERE co.owner = tb.table_owner
				  AND co.table_name = tb.table_name
				  AND co.owner = cc.owner
				  AND co.table_name = cc.table_name
				  AND co.constraint_name = cc.constraint_name
				  AND co.constraint_type = ''P''';
   -- Code token to retrieve pk columns of an object and their position inside the pk.
   -- If the object is a view, it doesn't try to detect PK from dependencies.
   -- Works for both remote and local tables.
   c_sql_obj_col_pk_nodep    t_string := 'SELECT co.owner AS object_owner
                       , co.table_name AS object_name
                       , cc.column_name
                       , cc.position
                    FROM all_constraints#dblink# co
                       , all_cons_columns#dblink# cc
                   WHERE co.owner = cc.owner
                     AND co.table_name = cc.table_name
                     AND co.constraint_name = cc.constraint_name
                     AND co.constraint_type = ''P''';
   -- Get column properties for an object.
   -- Works for both remote and local tables.
   c_sql_col_def             t_string := 'SELECT tc.column_id
	   , tc.column_name
	   , cm.comments
       , tc.data_type
       , tc.data_length
       , tc.data_precision
       , tc.data_scale
       , tc.data_type ||
         CASE
            WHEN tc.data_type IN (''NUMBER'')
             AND tc.data_precision IS NOT NULL
             AND tc.data_scale IS NOT NULL
               THEN '' ('' || tc.data_precision || '','' || tc.data_scale || '')''
            WHEN tc.data_type LIKE (''%CHAR%'')
               THEN '' ('' || tc.char_length || '')''
         END AS column_def
		 , cs.position AS pk_position
    FROM all_tab_columns#dblink# tc
       , all_col_comments#dblink# cm 
	   , (#sql_obj_pk#) cs
   WHERE tc.owner = cm.owner(+)
     AND tc.table_name = cm.table_name(+)
     AND tc.column_name = cm.column_name(+)
	 AND tc.owner = cs.object_owner(+)
     AND tc.table_name = cs.object_name(+)
     AND tc.column_name = cs.column_name(+)
	 AND tc.owner = TRIM(UPPER(:ow))
     AND tc.table_name = TRIM(UPPER(:tb))
ORDER BY tc.column_id';
   -- Get all columns for a given obejct.
   -- Works for both remote and local tables.
   c_sql_col_all             t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))
ORDER BY column_id';
   -- Get all pk columns for a given obejct.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_col_pk              t_string := 'SELECT column_name
    FROM (#sql_obj_pk#)
	WHERE object_owner = TRIM(UPPER(:ow))
     AND object_name = TRIM(UPPER(:tb))
ORDER BY position';
   -- Get all non pk columns for a given obejct.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_col_npk             t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))
  MINUS
  SELECT column_name
    FROM (#sql_obj_pk#)
	WHERE object_owner = TRIM(UPPER(:ow))
     AND object_name = TRIM(UPPER(:tb))';
   -- Get all columns 2 given obejcts have in common.
   c_sql_col_common_all      t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:p))
     AND table_name = TRIM(UPPER(:p))
  INTERSECT
  SELECT column_name
    FROM all_tab_columns
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))';
   -- Get all non-pk columns 2 given obejcts have in common.
   c_sql_col_common_npk      t_string := '(SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow1))
     AND table_name = TRIM(UPPER(:tb1))
  MINUS
  SELECT column_name
    FROM (#sql_obj_pk#)
   WHERE object_owner = TRIM(UPPER(:ow1))
     AND object_name = TRIM(UPPER(:tb1)))
  INTERSECT
 (SELECT column_name
    FROM all_tab_columns
   WHERE owner = TRIM(UPPER(:ow2))
     AND table_name = TRIM(UPPER(:tb2))
  MINUS
  SELECT cc.column_name
    FROM all_constraints co
	   , all_cons_columns cc
   WHERE co.owner = cc.owner
     AND co.table_name = cc.table_name
     AND co.constraint_name = cc.constraint_name
     AND co.constraint_type = ''P''
     AND co.owner = TRIM(UPPER(:ow2))
     AND co.table_name = TRIM(UPPER(:tb2))
  MINUS
  SELECT column_name
	FROM all_part_key_columns
   WHERE owner = TRIM(UPPER(:ow2))
     AND name = TRIM(UPPER(:tb2)))';
   -- Get table comments
   c_sql_tab_comm            t_string := 'SELECT comments
  FROM all_tab_comments#dblink#
 WHERE owner = TRIM(UPPER(:ow))
   AND table_name = TRIM(UPPER(:tb))';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );

   /**
   * Substitute standard source parameters #owner# and #dblink# with the content
   * of the global variables g_vc_src_obj_owner and g_vc_src_obj_dblink
   *
   * @param p_vc_code_string     Parameterized string
   */
   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB);

   /**
   * Import metadata for table and table columns
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   * @param p_vc_target_object     target object for storing metadata
   * @param p_vc_target_columns    target columns for storing metadata
   */
   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   );

   /**
   * Build a list of columns belonging to a given object
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   *
   * @return table comment
   */
   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2;

   /**
   * Build a list of columns belonging to a given object
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   * @param p_vc_column_type       Type of the column to list (PK, non-PK, ALL)
   * @param p_vc_list_type         Type of list (comma separated, assignment, use of alias)
   * @param p_vc_alias1            First alias
   * @param p_vc_alias2            Second alias
   * @param p_vc_exclude_list      List of colums to exclude
   *
   * @return List of columns
   */
   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   /**
   * Build a list of columns belonging to a combination of 2 given objects
   * For example, columns in common between the 2 objects
   *
   * @param p_vc_dblink1           object 1 db link
   * @param p_vc_owner1            object 1 owner
   * @param p_vc_object1_name      object 1 name
   * @param p_vc_owner2            object 2 owner
   * @param p_vc_object2_name      object 2 name
   * @param p_vc_column_type       Type of the column to list (Common PK, Common non-PK, ALL)
   * @param p_vc_list_type         Type of list (comma separated, assignment, use of alias)
   * @param p_vc_alias1            First alias
   * @param p_vc_alias2            Second alias
   * @param p_vc_exclude_list      List of colums to exclude
   *
   * @return List of columns
   */
   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   /**
   * check if a table is partitioned
   *
   * @param p_vc_dblink       Db link for object
   * @param p_vc_owner        Owner of object
   * @param p_vc_object_name  Name of object
   */
   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN;

   /**
   * check if 2 objects have the same columns
   *
   * @param p_vc_dblink1       Db link for object 1
   * @param p_vc_owner1        Owner of object 1
   * @param p_vc_object1_name  Name of object 1
   * @param p_vc_owner2        Owner of object 2
   * @param p_vc_object2_name  Name of object 2
   */
   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN;

   /**
   * check if 2 objects have the same pk-columns
   *
   * @param p_vc_dblink1       Db link for object 1
   * @param p_vc_owner1        Owner of object 1
   * @param p_vc_object1_name  Name of object 1
   * @param p_vc_owner2        Owner of object 2
   * @param p_vc_object2_name  Name of object 2
   */
   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN;
END p#frm#dict;
2014-11-28 13:56:58.075 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_dict
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version   CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url       CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version            VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                VARCHAR2 (1024);

   /**
   * Object name type
   */
   SUBTYPE t_object_name IS VARCHAR2 (50);

   /**
   * String type
   */
   SUBTYPE t_string IS VARCHAR2 (32767);

   g_vc_src_obj_owner        t_object_name;
   g_vc_src_obj_dblink       t_object_name;
   /**
   * Generic metadata retrieval statements
   */
   -- PL/SQL block to store metadata in a tmp table.
   c_sql_import_metadata     t_string := 'BEGIN
		DELETE #targetObject#;
			
		INSERT INTO #targetObject# #targetColumns#
					#sourceSelect#;
		COMMIT;
	END;';
   c_sql_tab_part            t_string := 'SELECT COUNT (*)
  FROM all_tab_partitions#dblink#
 WHERE table_owner = :ow
   AND table_name = :tb';
   -- Code token to retrieve all columns of an object and their position inside the pk.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_obj_col_all         t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:p))
     AND table_name = TRIM(UPPER(:p))';
   -- Code token to retrieve pk columns of an object and their position inside the pk.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_obj_col_pk          t_string := 'SELECT tb.object_owner
					 , tb.object_name
					 , cc.column_name
					 , cc.position
				 FROM (SELECT object_owner
								, object_name
								, table_owner
								, table_name
							FROM (SELECT o.owner AS object_owner
										  , o.object_name
										  , CASE
												 WHEN o.object_type = ''VIEW''
													 THEN d.referenced_owner
												 ELSE o.owner
											 END AS table_owner
										  , CASE
												 WHEN o.object_type = ''VIEW''
													 THEN d.referenced_name
												 ELSE o.object_name
											 END AS table_name
										  , COUNT (*) over (PARTITION BY o.owner, o.object_name) AS referenced_cnt
									  FROM all_objects#dblink# o
										  , all_dependencies#dblink# d
									 WHERE o.owner = d.owner(+)
										AND o.object_name = d.name(+)
										AND d.referenced_type(+) = ''TABLE''
										AND o.object_type in (''TABLE'',''VIEW'',''MATERIALIZED VIEW''))
						  WHERE referenced_cnt = 1) tb
					 , all_constraints#dblink# co
					 , all_cons_columns#dblink# cc
				WHERE co.owner = tb.table_owner
				  AND co.table_name = tb.table_name
				  AND co.owner = cc.owner
				  AND co.table_name = cc.table_name
				  AND co.constraint_name = cc.constraint_name
				  AND co.constraint_type = ''P''';
   -- Code token to retrieve pk columns of an object and their position inside the pk.
   -- If the object is a view, it doesn't try to detect PK from dependencies.
   -- Works for both remote and local tables.
   c_sql_obj_col_pk_nodep    t_string := 'SELECT co.owner AS object_owner
                       , co.table_name AS object_name
                       , cc.column_name
                       , cc.position
                    FROM all_constraints#dblink# co
                       , all_cons_columns#dblink# cc
                   WHERE co.owner = cc.owner
                     AND co.table_name = cc.table_name
                     AND co.constraint_name = cc.constraint_name
                     AND co.constraint_type = ''P''';
   -- Get column properties for an object.
   -- Works for both remote and local tables.
   c_sql_col_def             t_string := 'SELECT tc.column_id
	   , tc.column_name
	   , cm.comments
       , tc.data_type
       , tc.data_length
       , tc.data_precision
       , tc.data_scale
       , tc.data_type ||
         CASE
            WHEN tc.data_type IN (''NUMBER'')
             AND tc.data_precision IS NOT NULL
             AND tc.data_scale IS NOT NULL
               THEN '' ('' || tc.data_precision || '','' || tc.data_scale || '')''
            WHEN tc.data_type LIKE (''%CHAR%'')
               THEN '' ('' || tc.char_length || '')''
         END AS column_def
		 , cs.position AS pk_position
    FROM all_tab_columns#dblink# tc
       , all_col_comments#dblink# cm 
	   , (#sql_obj_pk#) cs
   WHERE tc.owner = cm.owner(+)
     AND tc.table_name = cm.table_name(+)
     AND tc.column_name = cm.column_name(+)
	 AND tc.owner = cs.object_owner(+)
     AND tc.table_name = cs.object_name(+)
     AND tc.column_name = cs.column_name(+)
	 AND tc.owner = TRIM(UPPER(:ow))
     AND tc.table_name = TRIM(UPPER(:tb))
ORDER BY tc.column_id';
   -- Get all columns for a given obejct.
   -- Works for both remote and local tables.
   c_sql_col_all             t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))
ORDER BY column_id';
   -- Get all pk columns for a given obejct.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_col_pk              t_string := 'SELECT column_name
    FROM (#sql_obj_pk#)
	WHERE object_owner = TRIM(UPPER(:ow))
     AND object_name = TRIM(UPPER(:tb))
ORDER BY position';
   -- Get all non pk columns for a given obejct.
   -- If the object is a view, try to detect PK information from an underlying table.
   -- Works for both remote and local tables.
   c_sql_col_npk             t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))
  MINUS
  SELECT column_name
    FROM (#sql_obj_pk#)
	WHERE object_owner = TRIM(UPPER(:ow))
     AND object_name = TRIM(UPPER(:tb))';
   -- Get all columns 2 given obejcts have in common.
   c_sql_col_common_all      t_string := 'SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:p))
     AND table_name = TRIM(UPPER(:p))
  INTERSECT
  SELECT column_name
    FROM all_tab_columns
   WHERE owner = TRIM(UPPER(:ow))
     AND table_name = TRIM(UPPER(:tb))';
   -- Get all non-pk columns 2 given obejcts have in common.
   c_sql_col_common_npk      t_string := '(SELECT column_name
    FROM all_tab_columns#dblink#
   WHERE owner = TRIM(UPPER(:ow1))
     AND table_name = TRIM(UPPER(:tb1))
  MINUS
  SELECT column_name
    FROM (#sql_obj_pk#)
   WHERE object_owner = TRIM(UPPER(:ow1))
     AND object_name = TRIM(UPPER(:tb1)))
  INTERSECT
 (SELECT column_name
    FROM all_tab_columns
   WHERE owner = TRIM(UPPER(:ow2))
     AND table_name = TRIM(UPPER(:tb2))
  MINUS
  SELECT cc.column_name
    FROM all_constraints co
	   , all_cons_columns cc
   WHERE co.owner = cc.owner
     AND co.table_name = cc.table_name
     AND co.constraint_name = cc.constraint_name
     AND co.constraint_type = ''P''
     AND co.owner = TRIM(UPPER(:ow2))
     AND co.table_name = TRIM(UPPER(:tb2))
  MINUS
  SELECT column_name
	FROM all_part_key_columns
   WHERE owner = TRIM(UPPER(:ow2))
     AND name = TRIM(UPPER(:tb2)))';
   -- Get table comments
   c_sql_tab_comm            t_string := 'SELECT comments
  FROM all_tab_comments#dblink#
 WHERE owner = TRIM(UPPER(:ow))
   AND table_name = TRIM(UPPER(:tb))';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );

   /**
   * Substitute standard source parameters #owner# and #dblink# with the content
   * of the global variables g_vc_src_obj_owner and g_vc_src_obj_dblink
   *
   * @param p_vc_code_string     Parameterized string
   */
   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB);

   /**
   * Import metadata for table and table columns
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   * @param p_vc_target_object     target object for storing metadata
   * @param p_vc_target_columns    target columns for storing metadata
   */
   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   );

   /**
   * Build a list of columns belonging to a given object
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   *
   * @return table comment
   */
   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2;

   /**
   * Build a list of columns belonging to a given object
   *
   * @param p_vc_dblink            object db link
   * @param p_vc_owner             object owner
   * @param p_vc_object_name       object name
   * @param p_vc_column_type       Type of the column to list (PK, non-PK, ALL)
   * @param p_vc_list_type         Type of list (comma separated, assignment, use of alias)
   * @param p_vc_alias1            First alias
   * @param p_vc_alias2            Second alias
   * @param p_vc_exclude_list      List of colums to exclude
   *
   * @return List of columns
   */
   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   /**
   * Build a list of columns belonging to a combination of 2 given objects
   * For example, columns in common between the 2 objects
   *
   * @param p_vc_dblink1           object 1 db link
   * @param p_vc_owner1            object 1 owner
   * @param p_vc_object1_name      object 1 name
   * @param p_vc_owner2            object 2 owner
   * @param p_vc_object2_name      object 2 name
   * @param p_vc_column_type       Type of the column to list (Common PK, Common non-PK, ALL)
   * @param p_vc_list_type         Type of list (comma separated, assignment, use of alias)
   * @param p_vc_alias1            First alias
   * @param p_vc_alias2            Second alias
   * @param p_vc_exclude_list      List of colums to exclude
   *
   * @return List of columns
   */
   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2;

   /**
   * check if a table is partitioned
   *
   * @param p_vc_dblink       Db link for object
   * @param p_vc_owner        Owner of object
   * @param p_vc_object_name  Name of object
   */
   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN;

   /**
   * check if 2 objects have the same columns
   *
   * @param p_vc_dblink1       Db link for object 1
   * @param p_vc_owner1        Owner of object 1
   * @param p_vc_object1_name  Name of object 1
   * @param p_vc_owner2        Owner of object 2
   * @param p_vc_object2_name  Name of object 2
   */
   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN;

   /**
   * check if 2 objects have the same pk-columns
   *
   * @param p_vc_dblink1       Db link for object 1
   * @param p_vc_owner1        Owner of object 1
   * @param p_vc_object1_name  Name of object 1
   * @param p_vc_owner2        Owner of object 2
   * @param p_vc_object2_name  Name of object 2
   */
   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN;
END dwhutl_dict;
2014-11-28 13:56:58.137 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-def.sql executed
2014-11-28 13:56:58.137 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-impl.sql delimiter 
2014-11-28 13:56:58.143 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE BODY p#frm#dict
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   FUNCTION fct_column_in_list (
      p_vc_column_name    VARCHAR2
    , p_vc_column_list    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_l_column_list   DBMS_SQL.varchar2s;
      l_b_is_in_list    BOOLEAN := FALSE;
   BEGIN
      l_l_column_list :=
         p#frm#type.fct_string_to_list (
            p_vc_column_list
          , ','
         );

      FOR i IN l_l_column_list.FIRST .. l_l_column_list.LAST LOOP
         IF p_vc_column_name = l_l_column_list (i) THEN
            l_b_is_in_list := TRUE;
         END IF;
      END LOOP;

      RETURN l_b_is_in_list;
   END;

   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_SET_TEXT_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB)
   IS
      l_vc_prc_name   t_string := 'PRC_SET_SRC_PARAM';
   BEGIN
      prc_set_text_param (
         p_vc_code_string
       , 'owner'
       , CASE
            WHEN g_vc_src_obj_owner IS NOT NULL THEN
                  g_vc_src_obj_owner
               || '.'
         END
      );
      prc_set_text_param (
         p_vc_code_string
       , 'dblink'
       , CASE
            WHEN g_vc_src_obj_dblink IS NOT NULL THEN
                  '@'
               || g_vc_src_obj_dblink
         END
      );
   END prc_set_src_param;

   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   )
   IS
      l_sql_col_def           t_string := c_sql_col_def;
      l_sql_import_metadata   t_string := c_sql_import_metadata;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_text_param (
         l_sql_col_def
       , 'sql_obj_pk'
       , CASE
            WHEN p_b_check_dependencies THEN
               c_sql_obj_col_pk
            ELSE
               c_sql_obj_col_pk_nodep
         END
      );
      prc_set_src_param (l_sql_col_def);
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetObject'
       , p_vc_target_object
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetColumns'
       , CASE
            WHEN p_vc_target_columns IS NOT NULL THEN
                  '('
               || p_vc_target_columns
               || ')'
         END
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'sourceSelect'
       , l_sql_col_def
      );

      EXECUTE IMMEDIATE l_sql_import_metadata
         USING p_vc_owner
             , p_vc_object_name;

      COMMIT;
   END prc_import_metadata;

   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2
   IS
      l_sql_tab_comm   t_string := c_sql_tab_comm;
      l_vc_tab_comm    t_string;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_comm);

      EXECUTE IMMEDIATE l_sql_tab_comm
         INTO l_vc_tab_comm
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;
      RETURN l_vc_tab_comm;
   END fct_get_table_comment;

   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref       t_cur_ref;
      l_sql_col_all   t_string := c_sql_col_all;
      l_sql_col_npk   t_string := c_sql_col_npk;
      l_sql_col_pk    t_string := c_sql_col_pk;
      l_vc_buffer     t_string;
      l_vc_list       t_string;
      l_vc_owner      t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      l_vc_owner := NVL (p_vc_owner, USER);

      IF p_vc_column_type = 'ALL' THEN
         prc_set_src_param (l_sql_col_all);

         OPEN l_cur_ref FOR l_sql_col_all
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'PK' THEN
         prc_set_text_param (
            l_sql_col_pk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_pk);

         OPEN l_cur_ref FOR l_sql_col_pk
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'NPK' THEN
         prc_set_text_param (
            l_sql_col_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_npk);

         OPEN l_cur_ref FOR l_sql_col_npk
            USING l_vc_owner
                , p_vc_object_name
                , l_vc_owner
                , p_vc_object_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_NOTNULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_NULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type IN ('AND_NOTNULL', 'AND_NULL', 'AND_ALIAS') THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_list;

   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref              t_cur_ref;
      l_sql_col_common_all   t_string := c_sql_col_common_all;
      l_sql_col_common_npk   t_string := c_sql_col_common_npk;
      l_vc_buffer            t_string;
      l_vc_list              t_string;
      --
      l_vc_owner1            t_object_name;
      l_vc_owner2            t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink1;
      l_vc_owner1 := NVL (p_vc_owner1, USER);
      l_vc_owner2 := NVL (p_vc_owner2, USER);

      IF p_vc_column_type = 'COMMON_ALL' THEN
         prc_set_src_param (l_sql_col_common_all);

         OPEN l_cur_ref FOR l_sql_col_common_all
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name;
      ELSIF p_vc_column_type = 'COMMON_NPK' THEN
         prc_set_text_param (
            l_sql_col_common_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_common_npk);

         OPEN l_cur_ref FOR l_sql_col_common_npk
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type = 'AND_ALIAS' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_subset;

   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_n_cnt_part     NUMBER;
      l_sql_tab_part   t_string := c_sql_tab_part;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_part);

      EXECUTE IMMEDIATE l_sql_tab_part
         INTO l_n_cnt_part
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;

      IF l_n_cnt_part = 0 THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END fct_check_part;

   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_all_1   t_string;
      l_vc_col_all_2   t_string;
   BEGIN
      NULL;
   END fct_check_col;

   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_pk_1   t_string;
      l_vc_col_pk_2   t_string;
   BEGIN
      l_vc_col_pk_1 :=
         fct_get_column_list (
            p_vc_dblink1
          , p_vc_owner1
          , p_vc_object1_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      l_vc_col_pk_2 :=
         fct_get_column_list (
            NULL
          , p_vc_owner2
          , p_vc_object2_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      ROLLBACK;

      IF l_vc_col_pk_1 = l_vc_col_pk_2
      OR (l_vc_col_pk_1 IS NULL
      AND l_vc_col_pk_2 IS NULL) THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_check_pk;
BEGIN
   -- Versioning constants
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END p#frm#dict;
2014-11-28 13:56:58.156 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE BODY dwhutl_dict
AS
   /**
   * $Author: nmarangoni $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   FUNCTION fct_column_in_list (
      p_vc_column_name    VARCHAR2
    , p_vc_column_list    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_l_column_list   DBMS_SQL.varchar2s;
      l_b_is_in_list    BOOLEAN := FALSE;
   BEGIN
      l_l_column_list :=
         dwhutl_type.fct_string_to_list (
            p_vc_column_list
          , ','
         );

      FOR i IN l_l_column_list.FIRST .. l_l_column_list.LAST LOOP
         IF p_vc_column_name = l_l_column_list (i) THEN
            l_b_is_in_list := TRUE;
         END IF;
      END LOOP;

      RETURN l_b_is_in_list;
   END;

   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   )
   IS
      l_vc_prc_name        t_object_name := 'PRC_SET_TEXT_PARAM';
      l_vc_buffer_in       CLOB;
      l_vc_buffer_out      CLOB;
      l_vc_token           CLOB;
      l_i_position_begin   INTEGER;
      l_i_position_end     INTEGER;
   BEGIN
      l_vc_buffer_in := p_vc_code_string;
      l_i_position_begin :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         - 1;
      l_i_position_end :=
           INSTR (
              l_vc_buffer_in
            ,    '#'
              || p_vc_param_name
              || '#'
           )
         + LENGTH (p_vc_param_name)
         + 2;

      -- Loop on occurencies of the parameter into the root code
      WHILE l_i_position_begin >= 0 LOOP
         l_vc_token :=
            SUBSTR (
               l_vc_buffer_in
             , 1
             , l_i_position_begin
            );
         l_vc_buffer_out :=
               l_vc_buffer_out
            || l_vc_token;
         l_vc_buffer_out :=
               l_vc_buffer_out
            || p_vc_param_value;
         l_vc_buffer_in :=
            SUBSTR (
               l_vc_buffer_in
             , l_i_position_end
            );
         l_i_position_begin :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            - 1;
         l_i_position_end :=
              INSTR (
                 l_vc_buffer_in
               ,    '#'
                 || p_vc_param_name
                 || '#'
              )
            + LENGTH (p_vc_param_name)
            + 2;
      END LOOP;

      -- Append the rest token
      l_vc_buffer_out :=
            l_vc_buffer_out
         || l_vc_buffer_in;
      p_vc_code_string := l_vc_buffer_out;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE;
   END prc_set_text_param;

   PROCEDURE prc_set_src_param (p_vc_code_string IN OUT CLOB)
   IS
      l_vc_prc_name   t_string := 'PRC_SET_SRC_PARAM';
   BEGIN
      prc_set_text_param (
         p_vc_code_string
       , 'owner'
       , CASE
            WHEN g_vc_src_obj_owner IS NOT NULL THEN
                  g_vc_src_obj_owner
               || '.'
         END
      );
      prc_set_text_param (
         p_vc_code_string
       , 'dblink'
       , CASE
            WHEN g_vc_src_obj_dblink IS NOT NULL THEN
                  '@'
               || g_vc_src_obj_dblink
         END
      );
   END prc_set_src_param;

   PROCEDURE prc_import_metadata (
      p_vc_dblink               VARCHAR2
    , p_vc_owner                VARCHAR2
    , p_vc_object_name          VARCHAR2
    , p_vc_target_object        VARCHAR2
    , p_vc_target_columns       VARCHAR2 DEFAULT NULL
    , p_b_check_dependencies    BOOLEAN DEFAULT TRUE
   )
   IS
      l_sql_col_def           t_string := c_sql_col_def;
      l_sql_import_metadata   t_string := c_sql_import_metadata;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_text_param (
         l_sql_col_def
       , 'sql_obj_pk'
       , CASE
            WHEN p_b_check_dependencies THEN
               c_sql_obj_col_pk
            ELSE
               c_sql_obj_col_pk_nodep
         END
      );
      prc_set_src_param (l_sql_col_def);
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetObject'
       , p_vc_target_object
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'targetColumns'
       , CASE
            WHEN p_vc_target_columns IS NOT NULL THEN
                  '('
               || p_vc_target_columns
               || ')'
         END
      );
      prc_set_text_param (
         l_sql_import_metadata
       , 'sourceSelect'
       , l_sql_col_def
      );

      EXECUTE IMMEDIATE l_sql_import_metadata
         USING p_vc_owner
             , p_vc_object_name;

      COMMIT;
   END prc_import_metadata;

   FUNCTION fct_get_table_comment (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN VARCHAR2
   IS
      l_sql_tab_comm   t_string := c_sql_tab_comm;
      l_vc_tab_comm    t_string;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_comm);

      EXECUTE IMMEDIATE l_sql_tab_comm
         INTO l_vc_tab_comm
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;
      RETURN l_vc_tab_comm;
   END fct_get_table_comment;

   FUNCTION fct_get_column_list (
      p_vc_dblink          VARCHAR2
    , p_vc_owner           VARCHAR2
    , p_vc_object_name     VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref       t_cur_ref;
      l_sql_col_all   t_string := c_sql_col_all;
      l_sql_col_npk   t_string := c_sql_col_npk;
      l_sql_col_pk    t_string := c_sql_col_pk;
      l_vc_buffer     t_string;
      l_vc_list       t_string;
      l_vc_owner      t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      l_vc_owner := NVL (p_vc_owner, USER);

      IF p_vc_column_type = 'ALL' THEN
         prc_set_src_param (l_sql_col_all);

         OPEN l_cur_ref FOR l_sql_col_all
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'PK' THEN
         prc_set_text_param (
            l_sql_col_pk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_pk);

         OPEN l_cur_ref FOR l_sql_col_pk
            USING l_vc_owner
                , p_vc_object_name;
      ELSIF p_vc_column_type = 'NPK' THEN
         prc_set_text_param (
            l_sql_col_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_npk);

         OPEN l_cur_ref FOR l_sql_col_npk
            USING l_vc_owner
                , p_vc_object_name
                , l_vc_owner
                , p_vc_object_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_NOTNULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_NULL' THEN
                           l_vc_buffer
                        || ' IS NOT NULL AND '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type IN ('AND_NOTNULL', 'AND_NULL', 'AND_ALIAS') THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_list;

   FUNCTION fct_get_column_subset (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
    , p_vc_column_type     VARCHAR2
    , p_vc_list_type       VARCHAR2
    , p_vc_alias1          VARCHAR2 DEFAULT NULL
    , p_vc_alias2          VARCHAR2 DEFAULT NULL
    , p_vc_exclude_list    VARCHAR2 DEFAULT NULL
   )
      RETURN VARCHAR2
   IS
      TYPE t_cur_ref IS REF CURSOR;

      l_cur_ref              t_cur_ref;
      l_sql_col_common_all   t_string := c_sql_col_common_all;
      l_sql_col_common_npk   t_string := c_sql_col_common_npk;
      l_vc_buffer            t_string;
      l_vc_list              t_string;
      --
      l_vc_owner1            t_object_name;
      l_vc_owner2            t_object_name;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink1;
      l_vc_owner1 := NVL (p_vc_owner1, USER);
      l_vc_owner2 := NVL (p_vc_owner2, USER);

      IF p_vc_column_type = 'COMMON_ALL' THEN
         prc_set_src_param (l_sql_col_common_all);

         OPEN l_cur_ref FOR l_sql_col_common_all
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name;
      ELSIF p_vc_column_type = 'COMMON_NPK' THEN
         prc_set_text_param (
            l_sql_col_common_npk
          , 'sql_obj_pk'
          , c_sql_obj_col_pk
         );
         prc_set_src_param (l_sql_col_common_npk);

         OPEN l_cur_ref FOR l_sql_col_common_npk
            USING l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner1
                , p_vc_object1_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name
                , l_vc_owner2
                , p_vc_object2_name;
      END IF;

      LOOP
         FETCH l_cur_ref INTO l_vc_buffer;

         EXIT WHEN l_cur_ref%NOTFOUND;

         IF NOT fct_column_in_list (
                   l_vc_buffer
                 , p_vc_exclude_list
                ) THEN
            l_vc_list :=
                  l_vc_list
               || CHR (10)
               || CASE p_vc_list_type
                     WHEN 'LIST_SIMPLE' THEN
                           l_vc_buffer
                        || ', '
                     WHEN 'LIST_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'SET_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', '
                     WHEN 'AND_ALIAS' THEN
                           p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ' = '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ' AND '
                     WHEN 'LIST_NVL2' THEN
                           'NVL2 ('
                        || p_vc_alias1
                        || '.rowid, '
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ') AS '
                        || l_vc_buffer
                        || ', '
                     WHEN 'OR_DECODE' THEN
                           'DECODE ('
                        || p_vc_alias1
                        || '.'
                        || l_vc_buffer
                        || ', '
                        || p_vc_alias2
                        || '.'
                        || l_vc_buffer
                        || ', 0, 1) = 1 OR '
                  END;
         END IF;
      END LOOP;

      CLOSE l_cur_ref;

      IF p_vc_list_type IN ('LIST_SIMPLE', 'LIST_ALIAS', 'LIST_NVL2', 'SET_ALIAS') THEN
         l_vc_list :=
            RTRIM (
               l_vc_list
             , ', '
            );
      ELSIF p_vc_list_type = 'AND_ALIAS' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 5
            );
      ELSIF p_vc_list_type = 'OR_DECODE' THEN
         l_vc_list :=
            SUBSTR (
               l_vc_list
             , 1
             ,   LENGTH (l_vc_list)
               - 4
            );
      END IF;

      ROLLBACK;
      RETURN l_vc_list;
   END fct_get_column_subset;

   FUNCTION fct_check_part (
      p_vc_dblink         VARCHAR2
    , p_vc_owner          VARCHAR2
    , p_vc_object_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_n_cnt_part     NUMBER;
      l_sql_tab_part   t_string := c_sql_tab_part;
   BEGIN
      g_vc_src_obj_dblink := p_vc_dblink;
      prc_set_src_param (l_sql_tab_part);

      EXECUTE IMMEDIATE l_sql_tab_part
         INTO l_n_cnt_part
         USING p_vc_owner
             , p_vc_object_name;

      ROLLBACK;

      IF l_n_cnt_part = 0 THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END fct_check_part;

   FUNCTION fct_check_col (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_all_1   t_string;
      l_vc_col_all_2   t_string;
   BEGIN
      NULL;
   END fct_check_col;

   FUNCTION fct_check_pk (
      p_vc_dblink1         VARCHAR2
    , p_vc_owner1          VARCHAR2
    , p_vc_object1_name    VARCHAR2
    , p_vc_owner2          VARCHAR2
    , p_vc_object2_name    VARCHAR2
   )
      RETURN BOOLEAN
   IS
      l_vc_col_pk_1   t_string;
      l_vc_col_pk_2   t_string;
   BEGIN
      l_vc_col_pk_1 :=
         fct_get_column_list (
            p_vc_dblink1
          , p_vc_owner1
          , p_vc_object1_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      l_vc_col_pk_2 :=
         fct_get_column_list (
            NULL
          , p_vc_owner2
          , p_vc_object2_name
          , 'PK'
          , 'LIST_SIMPLE'
         );
      ROLLBACK;

      IF l_vc_col_pk_1 = l_vc_col_pk_2
      OR (l_vc_col_pk_1 IS NULL
      AND l_vc_col_pk_2 IS NULL) THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fct_check_pk;
BEGIN
   -- Versioning constants
   c_body_version := '$Id: $';
   c_body_url := '$HeadURL: $';
END dwhutl_dict;
2014-11-28 13:56:58.294 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/dict/dict-impl.sql executed
2014-11-28 13:56:58.295 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryInstaller - Script packages/stmt/stmt-def.sql delimiter 
2014-11-28 13:56:58.296 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - Before replacement:
CREATE OR REPLACE PACKAGE p#frm#stmt
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version        CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url            CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version                 VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                     VARCHAR2 (1024);
   --
   --
   -- Enable/disable parallel execution
   c_token_enable_parallel_dml    CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION ENABLE PARALLEL DML'';';
   c_token_disable_parallel_dml   CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION DISABLE PARALLEL DML'';';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_table         CLOB := 'EXECUTE IMMEDIATE ''TRUNCATE TABLE #tableName# DROP STORAGE'';
          p#frm#trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# truncated'');';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_partition     CLOB := 'EXECUTE IMMEDIATE ''ALTER TABLE #tableName# TRUNCATE #partition#'';
          p#frm#trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# #partition# truncated'');';
   --
   -- Copy the content of a source table into a target table
   c_sql_insert_copy              CLOB := '
        INSERT /*+APPEND*/ INTO #targetIdentifier# #partition# (
               #utlColumnList#
               #targetColumnList#)
        SELECT #utlValueList#
               #sourceColumnList#
          FROM #sourceIdentifier#
               #filterClause#;';
   --
   -- Copy the content of a source table into a target table
   -- deduplicating source values among a defined natural key
   c_sql_insert_dedupl            CLOB := '
        INSERT /*+APPEND*/
          WHEN row_rank = 1
           AND #notNullClause#
          THEN INTO #targetIdentifier# #partition# (
                #utlColumnList#
                #targetColumnList#)
             VALUES (
                #utlValueList#
                #sourceColumnList#)
          ELSE INTO #duplIdentifier# #partition# (
                #utlColumnListForDupl#
                #targetColumnList#)
             VALUES (
                #utlValueListForDupl#
                #sourceColumnList#)
         SELECT #sourceColumnList#
              , ROW_NUMBER () over (PARTITION BY #pkColumnList# #deduplRankClause#) AS row_rank
           FROM #sourceIdentifier#
                #filterClause#;';
   --
   -- Store the difference between 2 tables
   c_sql_insert_diff_with_nk      CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT
                 #nvl2ColumnList#
                , CASE
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NULL
                        THEN ''I'' -- new row in src
                        WHEN src.rowid       IS NULL
                        AND trg.rowid        IS NOT NULL
                        AND trg.#dmlOpColumnName# <> ''D''
                        THEN ''D'' -- row was deleted in src
                        WHEN src.rowid      IS NOT NULL
                        AND trg.rowid       IS NOT NULL
                        AND trg.#dmlOpColumnName# = ''D''
                        THEN ''R'' -- row was deleted and now reappeared
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#historyClause#)
                        THEN ''H''
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#updateClause#)
                        THEN ''U''
                        ELSE NULL -- nothing to be done
                    END AS #dmlOpColumnName#
                  , trg.#validFromColumnName#
                  , trg.#validToColumnName#
                FROM #sourceIdentifier# #sourcePartition# src
                #joinType# OUTER JOIN 
                (SELECT *
                   FROM #targetIdentifier# #targetPartition#
                  WHERE #validToColumnName# > SYSDATE) trg
                ON    #joinClause#)
        WHERE #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Diff token of the staging 2 procedure - nk non-present
   c_sql_insert_diff_without_nk   CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT #targetColumnList#
             , CASE
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst = 0
                     THEN ''I''                                                                                                                                                          -- new row in src
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# = ''D''
                     THEN ''R''
                  WHEN cnt_in_src = 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# <> ''D''
                     THEN ''D''
                  ELSE NULL
               END AS #dmlOpColumnName#
             , #validFromColumnName#
             , #validToColumnName#
          FROM (SELECT   #targetColumnList#
                       , MAX (#dmlOpColumnName#) AS #dmlOpColumnName#
                       , MAX (#validFromColumnName#) AS #validFromColumnName#
                       , MAX (#validToColumnName#) AS #validToColumnName#
                       , COUNT (rowid_src) AS cnt_in_src
                       , COUNT (rowid_dst) AS cnt_in_dst
                    FROM (SELECT #targetColumnList#
                               , NULL AS #validFromColumnName#
                               , NULL AS #validToColumnName#
                               , NULL AS #dmlOpColumnName#
                               , ROWID AS rowid_src
                               , NULL AS rowid_dst
                            FROM #sourceIdentifier# #sourcePartition#
                          UNION ALL
                          SELECT #targetColumnList#
                               , #validFromColumnName#
                               , #validToColumnName#
                               , #dmlOpColumnName# AS #dmlOpColumnName#
                               , NULL AS rowid_src
                               , ROWID AS rowid_dst
                            FROM #targetIdentifier# #targetPartition#
                           WHERE #validToColumnName# > SYSDATE)
                GROUP BY #targetColumnList#))
        WHERE
            #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_close          CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# IN (''D'',''H'')) src
                  ON (#joinClause#)
        WHEN MATCHED THEN
             UPDATE
                 SET trg.#dmlOpColumnName# = src.#dmlOpColumnName# 
                   , trg.#validToColumnName# = SYSDATE
               WHERE trg.#validToColumnName# > SYSDATE;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_update         CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# = ''U'') src
                  ON (#joinClause#
                  AND trg.#validToColumnName# > SYSDATE)
        WHEN MATCHED THEN
             UPDATE
                 SET #matchedClause#
                     trg.#dmlOpColumnName# = src.#dmlOpColumnName#;';
   --
   --
   -- Merge token of the hist2 procedure - 2 separate statement
   c_sql_reconcile_insert         CLOB := '
      INSERT /*+APPEND*/
        INTO #targetIdentifier# #targetPartition# (
             #utlColumnList#
           , #targetColumnList#)
      SELECT #utlValueList#
           , #diffColumnList#
        FROM #diffIdentifier# #diffPartition#
       WHERE #dmlOpColumnName# IN (''H'', ''I'', ''R'');';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );
/*PROCEDURE prc_get_identifier (
   p_vc_dblink         VARCHAR2
 , p_vc_schema_name    VARCHAR2
 , p_vc_object_name    VARCHAR2
);*/
END p#frm#stmt;
2014-11-28 13:56:58.297 [main] DEBUG org.openbusinessintelligence.dblibrary.DBLibraryReplacer - After replacement:
CREATE OR REPLACE PACKAGE dwhutl_stmt
   AUTHID CURRENT_USER
AS
   /**
   * Templates for standard ddls
   * APIs to construct list of columns and column definitions
   *
   * $Author: $
   * $Date: $
   * $Revision: $
   * $Id: $
   * $HeadURL: $
   */
   /**
   * Package spec version string.
   */
   c_spec_version        CONSTANT VARCHAR2 (1024) := '$Id: $';
   /**
   * Package spec repository URL.
   */
   c_spec_url            CONSTANT VARCHAR2 (1024) := '$HeadURL: $';
   /**
   * Package body version string.
   */
   c_body_version                 VARCHAR2 (1024);
   /**
   * Package body repository URL.
   */
   c_body_url                     VARCHAR2 (1024);
   --
   --
   -- Enable/disable parallel execution
   c_token_enable_parallel_dml    CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION ENABLE PARALLEL DML'';';
   c_token_disable_parallel_dml   CLOB := 'EXECUTE IMMEDIATE ''ALTER SESSION DISABLE PARALLEL DML'';';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_table         CLOB := 'EXECUTE IMMEDIATE ''TRUNCATE TABLE #tableName# DROP STORAGE'';
          dwhutl_trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# truncated'');';
   --
   -- Truncate token of the staging 1 procedure
   c_token_truncate_partition     CLOB := 'EXECUTE IMMEDIATE ''ALTER TABLE #tableName# TRUNCATE #partition#'';
          dwhutl_trac.log_sub_debug (l_vc_prc_name, ''Truncate'', ''Table #tableName# #partition# truncated'');';
   --
   -- Copy the content of a source table into a target table
   c_sql_insert_copy              CLOB := '
        INSERT /*+APPEND*/ INTO #targetIdentifier# #partition# (
               #utlColumnList#
               #targetColumnList#)
        SELECT #utlValueList#
               #sourceColumnList#
          FROM #sourceIdentifier#
               #filterClause#;';
   --
   -- Copy the content of a source table into a target table
   -- deduplicating source values among a defined natural key
   c_sql_insert_dedupl            CLOB := '
        INSERT /*+APPEND*/
          WHEN row_rank = 1
           AND #notNullClause#
          THEN INTO #targetIdentifier# #partition# (
                #utlColumnList#
                #targetColumnList#)
             VALUES (
                #utlValueList#
                #sourceColumnList#)
          ELSE INTO #duplIdentifier# #partition# (
                #utlColumnListForDupl#
                #targetColumnList#)
             VALUES (
                #utlValueListForDupl#
                #sourceColumnList#)
         SELECT #sourceColumnList#
              , ROW_NUMBER () over (PARTITION BY #pkColumnList# #deduplRankClause#) AS row_rank
           FROM #sourceIdentifier#
                #filterClause#;';
   --
   -- Store the difference between 2 tables
   c_sql_insert_diff_with_nk      CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT
                 #nvl2ColumnList#
                , CASE
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NULL
                        THEN ''I'' -- new row in src
                        WHEN src.rowid       IS NULL
                        AND trg.rowid        IS NOT NULL
                        AND trg.#dmlOpColumnName# <> ''D''
                        THEN ''D'' -- row was deleted in src
                        WHEN src.rowid      IS NOT NULL
                        AND trg.rowid       IS NOT NULL
                        AND trg.#dmlOpColumnName# = ''D''
                        THEN ''R'' -- row was deleted and now reappeared
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#historyClause#)
                        THEN ''H''
                        WHEN src.rowid IS NOT NULL
                        AND trg.rowid  IS NOT NULL
                        AND (#updateClause#)
                        THEN ''U''
                        ELSE NULL -- nothing to be done
                    END AS #dmlOpColumnName#
                  , trg.#validFromColumnName#
                  , trg.#validToColumnName#
                FROM #sourceIdentifier# #sourcePartition# src
                #joinType# OUTER JOIN 
                (SELECT *
                   FROM #targetIdentifier# #targetPartition#
                  WHERE #validToColumnName# > SYSDATE) trg
                ON    #joinClause#)
        WHERE #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Diff token of the staging 2 procedure - nk non-present
   c_sql_insert_diff_without_nk   CLOB := '
      INSERT
        INTO #diffIdentifier# #diffPartition# (
            #targetColumnList#
          , #utlColumnList#)
        SELECT
            #targetColumnList#
          , #utlColumnList#
        FROM (SELECT #targetColumnList#
             , CASE
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst = 0
                     THEN ''I''                                                                                                                                                          -- new row in src
                  WHEN cnt_in_src > 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# = ''D''
                     THEN ''R''
                  WHEN cnt_in_src = 0
                  AND cnt_in_dst > 0
                  AND #dmlOpColumnName# <> ''D''
                     THEN ''D''
                  ELSE NULL
               END AS #dmlOpColumnName#
             , #validFromColumnName#
             , #validToColumnName#
          FROM (SELECT   #targetColumnList#
                       , MAX (#dmlOpColumnName#) AS #dmlOpColumnName#
                       , MAX (#validFromColumnName#) AS #validFromColumnName#
                       , MAX (#validToColumnName#) AS #validToColumnName#
                       , COUNT (rowid_src) AS cnt_in_src
                       , COUNT (rowid_dst) AS cnt_in_dst
                    FROM (SELECT #targetColumnList#
                               , NULL AS #validFromColumnName#
                               , NULL AS #validToColumnName#
                               , NULL AS #dmlOpColumnName#
                               , ROWID AS rowid_src
                               , NULL AS rowid_dst
                            FROM #sourceIdentifier# #sourcePartition#
                          UNION ALL
                          SELECT #targetColumnList#
                               , #validFromColumnName#
                               , #validToColumnName#
                               , #dmlOpColumnName# AS #dmlOpColumnName#
                               , NULL AS rowid_src
                               , ROWID AS rowid_dst
                            FROM #targetIdentifier# #targetPartition#
                           WHERE #validToColumnName# > SYSDATE)
                GROUP BY #targetColumnList#))
        WHERE
            #dmlOpColumnName# IS NOT NULL;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_close          CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# IN (''D'',''H'')) src
                  ON (#joinClause#)
        WHEN MATCHED THEN
             UPDATE
                 SET trg.#dmlOpColumnName# = src.#dmlOpColumnName# 
                   , trg.#validToColumnName# = SYSDATE
               WHERE trg.#validToColumnName# > SYSDATE;';
   --
   --
   -- Merge token of the hist procedure - 2 separate statement
   c_sql_reconcile_update         CLOB := '
      MERGE /*+APPEND*/
         INTO #targetIdentifier# trg
      USING
            (SELECT #dmlOpColumnName#
                  , #diffColumnList#
               FROM #diffIdentifier# #diffPartition#
              WHERE #dmlOpColumnName# = ''U'') src
                  ON (#joinClause#
                  AND trg.#validToColumnName# > SYSDATE)
        WHEN MATCHED THEN
             UPDATE
                 SET #matchedClause#
                     trg.#dmlOpColumnName# = src.#dmlOpColumnName#;';
   --
   --
   -- Merge token of the hist2 procedure - 2 separate statement
   c_sql_reconcile_insert         CLOB := '
      INSERT /*+APPEND*/
        INTO #targetIdentifier# #targetPartition# (
             #utlColumnList#
           , #targetColumnList#)
      SELECT #utlValueList#
           , #diffColumnList#
        FROM #diffIdentifier# #diffPartition#
       WHERE #dmlOpColumnName# IN (''H'', ''I'', ''R'');';

   /**
   * Substitute a parameter (#parameter_name#) with a text
   *
   * @param p_vc_code_string     Parameterized string
   * @param p_vc_param_name      Name of the parameter, surrounded by "#"
   * @param p_vc_param_value     Substitute text
   */
   PROCEDURE prc_set_text_param (
      p_vc_code_string   IN OUT CLOB
    , p_vc_param_name    IN     VARCHAR2
    , p_vc_param_value   IN     CLOB
   );
/*PROCEDURE prc_get_identifier (
   p_vc_dblink         VARCHAR2
 , p_vc_schema_name    VARCHAR2
 , p_vc_object_name    VARCHAR2
);*/
END dwhutl_stmt;
